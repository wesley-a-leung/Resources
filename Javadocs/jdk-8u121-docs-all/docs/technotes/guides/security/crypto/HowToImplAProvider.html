<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en-US" xmlns="http://www.w3.org/1999/xhtml" xml:lang=
"en-US">
<head>
<title>How to Implement a Provider in the Java Cryptography
Architecture</title>
<link rel="stylesheet" type="text/css" href=
"../../../css/jdk_index_style.css" />
<link rel="stylesheet" type="text/css" href="../../../../technotes/css/guide.css" />
</head>
<!-- ******************************************** -->
<!-- ***************   BODY TOP   *************** -->
<!-- ******************************************** -->
<body>
<!-- STATIC HEADER -->

<!-- header start -->
<div id="javaseheader">
<div id="javaseheaderlogo">
<img src="../../../../images/javalogo.gif"
alt="Java logo" />
</div>
<div id="javaseheaderindex">

<a href=
"../../../../index.html">Documentation Contents</a>
</div>
<div class="clear"></div>
</div>

<!-- header end -->




<h1>How to Implement a Provider in the Java Cryptography
Architecture</h1>


<div class="a1"><a href="#javasemaincontent" class="skiplink">Skip Table of Contents</a></div>


<!-- ******************************************** -->
<!-- ************* TABLE OF CONTENTS  *********** -->
<!-- ******************************************** -->
<ul>
<li><a href="#Introduction">Introduction</a>
<ul>
<li><a href="#Who">Who Should Read This Document</a></li>
<li><a href="#RelatedDocumentation">Related Documentation</a>
<ul>
<li><a href="#Terminology">Notes on Terminology</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#Engine">Engine Classes and Corresponding SPI
Classes</a></li>
<li><a href="#Steps">Steps to Implement and Integrate a
Provider</a>
<ul>
<li><a href="#Step1">Step 1: Write your Service Implementation
Code</a>
<ul>
<li><a href="#Step1a">Step 1.1: Additional JCA Provider
Requirements and Recommendations for Encryption
Implementations</a></li>
</ul>
</li>
<li><a href="#Step2">Step 2: Give your Provider a Name</a></li>
<li><a href="#Step3">Step 3: Write your <i>Master Class</i>, a
subclass of Provider</a>
<ul>
<li><a href="#Step3a">Step 3.1: Additional Steps for Cipher
Implementations</a></li>
</ul>
</li>
<li><a href="#Step4">Step 4: Compile your Code</a></li>
<li><a href="#Step5">Step 5: Place your Provider in a Jar
File</a></li>
<li><a href="#Step6">Step 6: Sign your JAR File</a>
<ul>
<li><a href="#Step61">Step 6.1: Get a Code-Signing
Certificate</a></li>
<li><a href="#Step62">Step 6.2: Sign Your Provider</a></li>
</ul>
</li>
<li><a href="#Step7">Step 7: Prepare for Testing</a>
<ul>
<li><a href="#Step71">Step 7.1: Install the Provider</a></li>
<li><a href="#Step72">Step 7.2: Set Provider Permissions</a></li>
</ul>
</li>
<li><a href="#Step8">Step 8: Write and Compile your Test
Programs</a></li>
<li><a href="#Step9">Step 9: Run your Test Programs</a></li>
<li><a href="#Step10">Step 10: Apply for U.S. Government Export
Approval if Required</a></li>
<li><a href="#Step11">Step 11: Document your Provider and its
Supported Services</a>
<ul>
<li><a href="#Digests">Message Digests and MACs</a></li>
</ul>
</li>
<li><a href="#Step12">Step 12: Make your Class Files and
Documentation Available to Clients</a></li>
</ul>
</li>
<li><a href="#integritycheck">How a Provider Can Do Self-Integrity
Checking</a>
<ul>
<li><a href="#SampleCodeNotes">Notes on the Sample Code</a></li>
<li><a href="#FindJFBasics">Finding the Provider JAR File:
Basics</a>
<ul>
<li><a href="#FindJFURL">Determining the Provider's JAR File
URL</a></li>
<li><a href="#CreateJarFile">Creating a JarFile Referring to the
JAR File</a></li>
</ul>
</li>
<li><a href="#VerifyJFBasics">Verifying the Provider JAR File:
Basics</a>
<ul>
<li><a href="#VerifySetup">Verification Setup</a></li>
<li><a href="#CheckJARFile">JAR File Signature Check</a></li>
<li><a href="#VerifySigs">Verifying Signatures</a></li>
<li><a href="#JCEAuthTrust">Ensuring Signers Are Trusted</a>
<ul>
<li><a href="#GetSignerCerts">Getting the List of
Certificates</a></li>
<li><a href="#ChainRoots">Identifying Each of the Signers and
Determining If One is Trusted</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#VerifySigs">Verifying Signatures</a></li>
<li><a href="#JCEAuthTrust">Ensuring Signers Are Trusted</a>
<ul>
<li><a href="#GetSignerCerts">Getting the List of
Certificates</a></li>
<li><a href="#ChainRoots">Identifying Each of the Signers and
Determining If One is Trusted</a></li>
<li><a href="#myJCECodeNotes">Notes on <i>myJCE</i> Sample
Code</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#FurtherImplDetails">Further Implementation Details
and Requirements</a>
<ul>
<li><a href="#Aliases">Alias Names</a></li>
<li><a href="#AlgDependencies">Service Interdependencies</a></li>
<li><a href="#DefaultInits">Default Initializations</a></li>
<li><a href="#DefaultKPGParms">Default Key Pair Generator Parameter
Requirements</a></li>
<li><a href="#ProviderService">The <code>Provider.Service</code>
Class</a></li>
<li><a href="#SigFormats">Signature Formats</a></li>
<li><a href="#DSAInts">DSA Interfaces and their Required
Implementations</a></li>
<li><a href="#RSAInts">RSA Interfaces and their Required
Implementations</a></li>
<li><a href="#DHInts">Diffie-Hellman Interfaces and their Required
Implementations</a></li>
<li><a href="#NonDSAInts">Interfaces for Other Algorithm
Types</a></li>
<li><a href="#AlgParmSpecs">Algorithm Parameter Specification
Interfaces and Classes</a></li>
<li><a href="#KeySpecs">Key Specification Interfaces and Classes
Required by Key Factories</a></li>
<li><a href="#SecretKeyGen">Secret-Key Generation</a></li>
<li><a href="#EnsureExport">Ensuring Exportability</a></li>
</ul>
</li>
<li><a href="#AppA">Appendix A: The <i>Sun</i> Provider Master
Class</a></li>
<li><a href="#AppB">Appendix B: The <i>SunJCE</i> Provider Master
Class</a></li>
<li><a href="#AppC">Appendix C: The <code>java.security</code>
Properties File</a></li>
</ul>
<hr />

<a name="javasemaincontent"/>

<h2><a name="Introduction" id="Introduction">Introduction</a></h2>


<p>The Java platform defines a set of APIs spanning major security
areas, including cryptography, public key infrastructure,
authentication, secure communication, and access control. These
APIs allow developers to easily integrate security into their
application code. They were designed around the following
principles:</p>
<ol>
<li>
<p><b>Implementation independence</b></p>
<p>Applications do not need to implement security themselves.
Rather, they can request security services from the Java platform.
Security services are implemented in providers (see below), which
are plugged into the Java platform via a standard interface. An
application may rely on multiple independent providers for security
functionality.</p>
</li>
<li>
<p><b>Implementation interoperability</b></p>
<p>Providers are interoperable across applications. Specifically,
an application is not bound to a specific provider, and a provider
is not bound to a specific application.</p>
</li>
<li>
<p><b>Algorithm extensibility</b></p>
<p>The Java platform includes a number of built-in providers that
implement a basic set of security services that are widely used
today. However, some applications may rely on emerging standards
not yet implemented, or on proprietary services. The Java platform
supports the installation of custom providers that implement such
services.</p>
</li>
</ol>
<!-- **** 2a **** -->
<p>A <em>Cryptographic Service Provider</em> (provider) refers to a
package (or a set of packages) that supply a concrete
implementation of a subset of the cryptography aspects of the JDK
Security API. <!-- ************** --></p>
<p>The <code>java.security.Provider</code> class encapsulates the
notion of a security provider in the Java platform. It specifies
the provider's name and lists the security services it implements.
Multiple providers may be configured at the same time, and are
listed in order of preference. When a security service is
requested, the highest priority provider that implements that
service is selected.</p>

<p>The following figure illustrate these options for requesting an MD5
message digest implementation. The figure consists of two diagrams, both of which show three providers that implement message digest algorithms. The providers are ordered by preference from left to right (1-3). In the diagram to the left, an application requests an MD5 algorithm implementation without specifying a provider name. The providers are searched in preference order and the implementation from the first provider supplying that particular algorithm, ProviderB, is returned. In the diagram to the right, the application requests the MD5 algorithm implementation from a specific provider, ProviderC. This time the implementation from that provider is returned, even though a provider with a higher preference order, ProviderB, also supplies an MD5
implementation.</p>

<a name="md5-message-digest-implementation_image"/>

<img src="../images/jca/Overview.gif" alt=
"MD5 Message Digest Implementation" />
<p><a href="img_text/Overview.html">Description of Figure Options for Requesting an MD5 Message Digest Implementation</a></p>

<!--

<img src="../images/jca/Overview.gif" alt=
"Figures 1 and 2: Options for requesting an MD5 message digest implementation" />
<p>Figure 1 (left): Provider searching. Figure 2 (right): Specific provider
requested</p>


-->

<!-- *** copied up to "file locations" in jsoverview *****  -->
<!--  **** end of jsoverview copy  **** -->
<!--  **** **********************  **** -->
<!-- **** 3 **** -->
<!-- **** 4 and 5 **** -->
<p>Each installation has one or more provider packages installed.
Clients may configure their runtimes with different providers, and
specify a <i>preference order</i> for each of them. The preference
order is the order in which providers are searched for requested
algorithms when no particular provider is requested.</p>
<p>The Oracle version of the Java runtime environment (JRE)
comes standard with a default provider, named "SUN".
Other Java runtime
environments may not necessarily supply the "SUN" provider.</p>
<h2><a name="Who" id="Who">Who Should Read This Document</a></h2>
<p>Programmers that only need to use the Java Security API to
access existing cryptography algorithms and other services do
<i>not</i> need to read this document.</p>
<!-- ******  7,8,9,10,12,13 ****** -->
<p>This document is intended for experienced programmers wishing to
create their own provider packages supplying cryptographic service
implementations. It documents what you need to do in order to
integrate your provider into Java so that your algorithms and other
services can be found when Java Security API clients request them. 
<!-- 8 ***** --></p>
<h2><a name="RelatedDocumentation" id=
"RelatedDocumentation">Related Documentation</a></h2>
<p>This document assumes you have already read the <a href=
"CryptoSpec.html">Java Cryptography Architecture Reference
Guide</a>.</p>
<p>It documents the packages which contain the various classes and
interfaces in the Security API.</p>
<ul>
<li><a href=
"../../../../api/java/security/package-summary.html"><code>java.security</code></a></li>
<li><a href=
"../../../../api/java/security/spec/package-summary.html"><code>java.security.spec</code></a></li>
<li><a href=
"../../../../api/java/security/interfaces/package-summary.html"><code>
java.security.interfaces</code></a></li>
<li><a href=
"../../../../api/javax/crypto/package-summary.html"><code>javax.crypto</code></a></li>
<li><a href=
"../../../../api/javax/crypto/spec/package-summary.html"><code>javax.crypto.spec</code></a></li>
<li><a href=
"../../../../api/javax/crypto/interfaces/package-summary.html"><code>
javax.crypto.interfaces</code></a></li>
</ul>
<h3><a name="Terminology" id="Terminology">Notes on
Terminology</a></h3>
<ul>
<li>Prior to JDK 1.4, the JCE was an unbundled product, and as
such, the JCA and JCE were regularly referred to as separate,
distinct components. As JCE is now bundled in JDK, the distinction
is becoming less apparent. Since the JCE uses the same architecture
as the JCA, the JCE should be more properly thought of as a subset
of the JCA.</li>
<li>The JCA within the JDK includes two software components:
<ul>
<li>the framework that defines and supports cryptographic services
for which providers supply implementations. This framework includes
packages such as <code>java.security</code>,
<code>javax.crypto</code>, <code>javax.crypto.spec</code>, and
<code>javax.crypto.interfaces</code>.</li>
<li>the actual providers such as <i>Sun</i>, <i>SunRsaSign</i>,
<i>SunJCE</i>, which contain the actual cryptographic
implementations.</li>
</ul>
<!-- inner close --></li>
</ul>
<!-- outer close -->
<p>Throughout this document, the terms <i>JCA</i> by itself refers
to the JCA framework. Whenever this document notes a specific JCA
provider, it will be referred to explicitly by the provider
name.</p>
<!-- ****  9 **** -->
<h2><a name="Engine" id="Engine">Engine Classes and Corresponding
Service Provider Interface Classes</a></h2>
<p>An <i>engine class</i> defines a cryptographic service in an
abstract fashion (without a concrete implementation).</p>
<p>A <i>cryptographic service</i> is always associated with a
particular algorithm or type. It either provides cryptographic
operations (like those for digital signatures or message digests,
ciphers or key agreement protocols); generates or supplies the
cryptographic material (keys or parameters) required for
cryptographic operations; or generates data objects (keystores or
certificates) that encapsulate cryptographic keys (which can be
used in a cryptographic operation) in a secure fashion.</p>
<!--
<p class="red">merge this pp with the above pp</p>

<p><i>A cryptographic service is always associated with a particular
algorithm, and it either provides cryptographic operations (like those
for ciphers or key agreement protocols), or generates or supplies the
cryptographic material (keys or parameters) required for cryptographic
operations. </i> </p>

-->
<p>For example, here are four engine classes:</p>
<ul>
<li>The <code>Signature</code> class provides access to the
functionality of a digital signature algorithm.</li>
<li>A DSA <code>KeyFactory</code> class supplies a DSA private or
public key (from its encoding or transparent specification) in a
format usable by the initSign or initVerify methods, respectively,
of a DSA Signature object.</li>
<li>The <code>Cipher</code> class provides access to the
functionality of an encryption algorithm (such as DES)</li>
<li>the <code>KeyAgreement</code> class provides access to the
functionality of a key agreement protocol (such as
Diffie-Hellman)</li>
</ul>
<!-- 11 -->
<p>The Java Cryptography Architecture encompasses the classes
comprising the Security package that relate to cryptography,
including the engine classes. Users of the API request and utilize
instances of the engine classes to carry out corresponding
operations. The JDK defines the following engine classes:</p>
<ul>
<li><code>MessageDigest</code> - used to calculate the message
digest (hash) of specified data.</li>
<li><code>Signature</code> - used to sign data and verify digital
signatures.</li>
<li><code>KeyPairGenerator</code> - used to generate a pair of
public and private keys suitable for a specified algorithm.</li>
<li><code>KeyFactory</code> - used to convert opaque cryptographic
keys of type <code>Key</code> into <i>key specifications</i>
(transparent representations of the underlying key material), and
vice versa.</li>
<li><code>KeyStore</code> - used to create and manage a
<i>keystore</i>. A keystore is a database of keys. Private keys in
a keystore have a certificate chain associated with them, which
authenticates the corresponding public key. A keystore also
contains certificates from trusted entities.</li>
<li><code>CertificateFactory</code> - used to create public key
certificates and Certificate Revocation Lists (CRLs).</li>
<li><code>AlgorithmParameters</code> - used to manage the
parameters for a particular algorithm, including parameter encoding
and decoding.</li>
<li><code>AlgorithmParameterGenerator</code> - used to generate a
set of parameters suitable for a specified algorithm.</li>
<li><code>SecureRandom</code> - used to generate random or
pseudo-random numbers.</li>
<li><code>Cipher</code>: used to encrypt or decrypt some specified
data.</li>
<li><code>KeyAgreement</code>: used to execute a key agreement (key
exchange) protocol between 2 or more parties.</li>
<li><code>KeyGenerator</code>: used to generate a secret
(symmetric) key suitable for a specified algorithm.</li>
<li><code>Mac</code>: used to compute the <i>message authentication
code</i> of some specified data.</li>
<li><code>SecretKeyFactory</code>: used to convert opaque
cryptographic keys of type <code>SecretKey</code> into <i>key
specifications</i> (transparent representations of the underlying
key material), and vice versa.</li>
<li><code>ExemptionMechanism</code>: used to provide the
functionality of an exemption mechanism such as <i>key
recovery</i>, <i>key weakening</i>, <i>key escrow</i>, or any other
(custom) exemption mechanism. Applications or applets that use an
exemption mechanism may be granted stronger encryption capabilities
than those which don't. However, please note that cryptographic
restrictions are no longer required for most countries, and thus
exemption mechanisms may only be useful in those few countries
whose governments mandate restrictions.</li>
</ul>
<hr />
<p><b>Note: A <i>generator</i> creates objects with brand-new
contents, whereas a <i>factory</i> creates objects from existing
material (for example, an encoding).</b></p>
<hr />
<p>An <i>engine</i> class provides the interface to the
functionality of a specific type of cryptographic service
(independent of a particular cryptographic algorithm). It defines
<i>Application Programming Interface</i> (API) methods that allow
applications to access the specific type of cryptographic service
it provides. The actual implementations (from one or more
providers) are those for specific algorithms. For example, the
Signature engine class provides access to the functionality of a
digital signature algorithm. The actual implementation supplied in
a <code>SignatureSpi</code> subclass (see next paragraph) would be
that for a specific kind of signature algorithm, such as SHA1 with
DSA, SHA1 with RSA, or MD5 with RSA.</p>

<p>The application interfaces supplied by an engine class are
implemented in terms of a <b>Service Provider Interface (SPI)</b>.
That is, for each engine class, there is a corresponding abstract
SPI class, which defines the Service Provider Interface methods
that cryptographic service providers must implement.</p>

<a name="example-of-how-application-retrieves-aes-cipher-intstance_image"/>

<img src="../images/jca/ArchDesignPrincipals.gif" alt=
"Architecture of Service Provider Interface" />

<p><a href="img_text/ArchDesignPrincipals.html">Description of Architecture of Service Provider Interface</a></p>

<p>An instance of an engine class, the "API object", encapsulates
(as a private field) an instance of the corresponding SPI class,
the "SPI object". All API methods of an API object are declared
"final", and their implementations invoke the corresponding SPI
methods of the encapsulated SPI object. An instance of an engine
class (and of its corresponding SPI class) is created by a call to
the <code>getInstance</code> factory method of the engine
class.</p>
<p>The name of each SPI class is the same as that of the
corresponding engine class, followed by "Spi". For example, the SPI
class corresponding to the Signature engine class is the
SignatureSpi class.</p>
<p>Each SPI class is abstract. To supply the implementation of a
particular type of service and for a specific algorithm, a provider
must subclass the corresponding SPI class and provide
implementations for all the abstract methods.</p>
<p>Another example of an engine class is the MessageDigest class,
which provides access to a message digest algorithm. Its
implementations, in MessageDigestSpi subclasses, may be those of
various message digest algorithms such as SHA-1, MD5, or MD2.</p>
<p>As a final example, the KeyFactory engine class supports the
conversion from opaque keys to transparent key specifications, and
vice versa. See <a href="#KeySpecs">Key Specification Interfaces
and Classes Required by Key Factories</a> for details. The actual
implementation supplied in a KeyFactorySpi subclass would be that
for a specific type of keys, e.g., DSA public and private keys.</p>
<!-- **** end 8 - 13 **** -->
<!-- ***** 14 ****** -->
<h2><a name="Steps" id="Steps">Steps to Implement and Integrate a
Provider</a></h2>
<p>Follow the steps below to implement a provider and integrate it
into the JCA framework:</p>

<ul>
<li><a href="#Step1">Step 1: Write your Service Implementation
Code</a>
<ul>
<li><a href="#Step1a">Step 1.1: Additional JCA Provider
Requirements and Recommendations for Encryption
Implementations</a></li>
</ul>
</li>
<li><a href="#Step2">Step 2: Give your Provider a Name</a></li>
<li><a href="#Step3">Step 3: Write your <i>Master Class</i>, a
subclass of Provider</a>
<ul>
<li><a href="#Step3a">Step 3.1: Additional Steps for Cipher
Implementations</a></li>
</ul>
</li>
<li><a href="#Step4">Step 4: Compile your Code</a></li>
<li><a href="#Step5">Step 5: Place your Provider in a Jar
File</a></li>
<li><a href="#Step6">Step 6: Sign your JAR File</a>
<ul>
<li><a href="#Step61">Step 6.1: Get a Code-Signing
Certificate</a></li>
<li><a href="#Step62">Step 6.2: Sign Your Provider</a></li>
</ul>
</li>
<li><a href="#Step7">Step 7: Prepare for Testing</a>
<ul>
<li><a href="#Step71">Step 7.1: Install the Provider</a></li>
<li><a href="#Step72">Step 7.2: Set Provider Permissions</a></li>
</ul>
</li>
<li><a href="#Step8">Step 8: Write and Compile your Test
Programs</a></li>
<li><a href="#Step9">Step 9: Run your Test Programs</a></li>
<li><a href="#Step10">Step 10: Apply for U.S. Government Export
Approval if Required</a></li>
<li><a href="#Step11">Step 11: Document your Provider and its
Supported Services</a>
<ul>
<li><a href="#Digests">Message Digests and MACs</a></li>
</ul>
</li>
<li><a href="#Step12">Step 12: Make your Class Files and
Documentation Available to Clients</a></li>
</ul>

<!-- ***** end 14 ***** -->
<!-- ***** Unedited JCEProvider copy ***** -->
<!-- ****** running from 20 and up, but not ***** -->
<!-- ****** including CRYProvider copy ***** -->
<!-- ****** 20, 21, step 1a insert, ***** -->
<h2><a name="Step1" id="Step1">Step 1: Write your Service
Implementation Code</a></h2>
<p>The first thing you need to do is to write the code that
provides algorithm-specific implementations of the cryptographic
services you want to support.</p>
<p>Note that your provider may supply implementations of
cryptographic services already available in one or more of the
security components of the JDK.</p>
<!--
<p>Using the JCA, you can supply cipher, key agreement and MAC
algorithms, as well as secret-key factories, secret-key generation
services, and exemption mechanism implementations.
</p> -->
<p>For cryptographic services not defined in JCA (For example;
signatures and message digests), please refer to <a href=
"CryptoSpec.html">Java Cryptography Architecture Reference
Guide</a>.</p>
<p>For each cryptographic service you wish to implement, create a
subclass of the appropriate SPI class. JCA defines the following
engine classes:</p>
<ul>
<li><code>SignatureSpi</code></li>
<li><code>MessageDigestSpi</code></li>
<li><code>KeyPairGeneratorSpi</code></li>
<li><code>SecureRandomSpi</code></li>
<li><code>AlgorithmParameterGeneratorSpi</code></li>
<li><code>AlgorithmParametersSpi</code></li>
<li><code>KeyFactorySpi</code></li>
<li><code>CertificateFactorySpi</code></li>
<li><code>KeyStoreSpi</code></li>
<li><code>CipherSpi</code></li>
<li><code>KeyAgreementSpi</code></li>
<li><code>KeyGeneratorSpi</code></li>
<li><code>MacSpi</code></li>
<li><code>SecretKeyFactorySpi</code></li>
<li><code>ExemptionMechanismSpi</code></li>
</ul>
<p>(See <a href="#Engine">Engine Classes and Corresponding SPI
Classes</a> in this document for information on the JCA and other
cryptographic classes.)</p>
<p>In your subclass, you need to:</p>
<ol>
<li>Supply implementations for the abstract methods, whose names
usually begin with <code>engine</code>. See <a href=
"#FurtherImplDetails">Further Implementation Details and
Requirements</a> for additional information.</li>
<li>Ensure there is a public constructor without any arguments.
Here's why: When one of your services is requested, Java Security
looks up the subclass implementing that service, as specified by a
property in your "master class" (see <a href="#Step3">Step 3</a>).
Java Security then creates the <code>Class</code> object associated
with your subclass, and creates an instance of your subclass by
calling the <code>newInstance</code> method on that
<code>Class</code> object. <code>newInstance</code> requires your
subclass to have a public constructor without any parameters.</li>
<li>A default constructor without arguments will automatically be
generated if your subclass doesn't have any constructors. But if
your subclass defines any constructors, you must explicitly define
a public constructor without arguments.</li>
</ol>
<!-- end of insert 21 -->
<!-- step 1a inserts here -->
<h3><a name="Step1a" id="Step1a">Step 1.1: Additional JCA Provider
Requirements and Recommendations for Encryption
Implementations</a></h3>
<p>When instantiating a provider's implementation (class) of a
<code>Cipher, KeyAgreement, KeyGenerator, MAC</code> or
<code>SecretKey</code> factory, the framework will determine the
provider's codebase (JAR file) and verify its signature. In this
way, JCA authenticates the provider and ensures that only providers
signed by a trusted entity can be plugged into JCA. Thus, one
requirement for encryption providers is that they must be signed,
as described in later steps.</p>
<p>In addition, each provider should perform self-integrity
checking to ensure that the JAR file containing its code has not
been manipulated in an attempt to invoke provider methods directly
rather than through JCA. For further information, see <a href=
"#integritycheck">How a Provider Can Do Self-Integrity
Checking</a>.</p>
<p>In order for provider classes to become unusable if instantiated
by an application directly, bypassing JCA, providers should
implement the following:</p>
<ul>
<li>All SPI implementation classes in a provider package should be
declared <tt>final</tt> (so that they cannot be subclassed), and
their (SPI) implementation methods should be declared
<tt>protected</tt>.</li>
<li>All crypto-related helper classes in a provider package should
have package-private scope, so that they cannot be accessed from
outside the provider package.</li>
</ul>
<p>For providers that may be exported outside the U.S.,
<code>CipherSpi</code> implementations must include an
implementation of the <code>engineGetKeySize</code> method which,
given a <code>Key</code>, returns the key size. If there are
restrictions on available cryptographic strength specified in
jurisdiction policy files, each <code>Cipher</code> initialization
method calls <code>engineGetKeySize</code> and then compares the
result with the maximum allowable key size for the particular
location and circumstances of the applet or application being run.
If the key size is too large, the initialization method throws an
exception.</p>
<p>Additional <i>optional</i> features that providers may implement
are</p>
<ul>
<li>the <code>engineWrap</code> and <code>engineUnwrap</code>
methods of <code>CipherSpi</code>. Wrapping a key enables secure
transfer of the key from one place to another. Information about
wrapping and unwrapping keys is provided in the <a href=
"CryptoSpec.html#WrapUnwrap">Wrapping and Unwrapping Keys</a>
section of the <i>Java Cryptography Architecture Reference
Guide</i>.</li>
<li>one or more <i>exemption mechanisms</i>. An exemption mechanism
is something such as key recovery, key escrow, or key weakening
which, if implemented and enforced, may enable reduced
cryptographic restrictions for an application (or applet) that uses
it. For information on the requirements for apps that utilize
exemption mechanisms, see <a href="CryptoSpec.html#ExemptApps">How
to Make Applications "Exempt" from Cryptographic Restrictions</a>
in the <i>Java Cryptography Architecture Reference Guide</i>.</li>
</ul>
<!-- *** end of proposed step 1a ****** -->
<!-- ********* step 2 **** -->
<h2><a name="Step2" id="Step2">Step 2: Give your Provider a
Name</a></h2>
<p>Decide on a name for your provider. This is the name to be used
by client applications to refer to your provider. 
<!-- **** Step 3  --></p>
<h2><a name="Step3" id="Step3">Step 3: Write your <i>Master
Class,</i> a subclass of Provider</a></h2>
<p>The third step is to create a subclass of the
<code>java.security.Provider</code> class.</p>
<p>Your subclass should be a <code>final</code> class, and its
constructor should</p>
<ul>
<li>call <code>super</code>, specifying the provider name (see
<a href="#Step2">Step 2</a>), version number, and a string of
information about the provider and algorithms it supports. For
example:
<pre class="codeblock">
    super("CryptoX", 1.0, "CryptoX provider v1.0, implementing " +
        "RSA encryption and key pair generation, and DES encryption.");
</pre></li>
<li>set the values of various properties that are required for the
Java Security API to look up the cryptographic services implemented
by the provider. For each service implemented by the provider,
there must be a property whose name is the type of service (for
example; Signature, MessageDigest, Cipher, KeyAgreement) 
<!-- change this ul list back to a list included within the above paragraph -->
 <!--
<ul>
<code> -->
 Signature, MessageDigest, KeyPairGenerator, SecureRandom,
KeyFactory, KeyStore, CertificateFactory,
AlgorithmParameterGenerator, AlgorithmParameters, 
<!-- *** the list *** brad's list *** -->
 Cipher, KeyAgreement, KeyGenerator, Mac, SecretKeyFactory, or
ExemptionMechanism) <!-- </code>
</ul>
-->
 followed by a period and the name of the algorithm to which the
service applies. The property value must specify the fully
qualified name of the class implementing the service.</li>
<li>
<p>The list below shows the various types of JCA services, where
the actual algorithm name is substitued for <i>algName</i>:</p>
<ul>
<li><code>Signature.<i>algName</i></code></li>
<li><code>MessageDigest.<i>algName</i></code></li>
<li><code>KeyPairGenerator.<i>algName</i></code></li>
<li><code>SecureRandom.<i>algName</i></code></li>
<li><code>AlgorithmParameterGenerator.<i>algName</i></code></li>
<li><code>AlgorithmParameters.<i>algName</i></code></li>
<li><code>KeyFactory.<i>algName</i></code></li>
<li><code>CertificateFactory.<i>algName</i></code></li>
<li><code>KeyStore.<i>algName</i></code></li>
<li><code>Cipher.<i>algName</i></code></li>
<li><code>KeyAgreement.<i>algName</i></code></li>
<li><code>KeyGenerator.<i>algName</i></code></li>
<li><code>Mac.<i>algName</i></code></li>
<li><code>SecretKeyFactory.<i>algName</i></code></li>
<li><code>ExemptionMechanism.<i>algName</i></code></li>
</ul>
<!-- ****** end 22 ****** -->
<!-- *** start 23 one paragraph ******* -->
<p>In all of these except <code>ExemptionMechanism</code> and
<code>Cipher</code>, <code>algName, certType</code> , or
<code>storeType</code> is the "standard" name of the algorithm,
certificate type, or keystore type. See <a href=
"CryptoSpec.html#AppA">Appendix A of the Java Cryptography
Architecture Reference Guide</a> for the standard names that should
be used.)</p>
<!-- ****** start 24  ***** -->
<p>In the case of <code>ExemptionMechanism</code>, <i>algName</i>
refers to the name of the exemption mechanism, which can be one of
the following: <code>KeyRecovery</code>, <code>KeyEscrow</code>, or
<code>KeyWeakening</code>. Case does <i>not</i> matter.</p>
<p>In the case of <code>Cipher</code>, <i>algName</i> may actually
represent a <i>transformation</i>, and may be composed of an
algorithm name, a particular mode, and a padding scheme. See
<a href="CryptoSpec.html#AppA">Appendix A</a> of the Java
Cryptography Architecture Reference Guide for details.</p>
<!-- correct this url. This might be a deletion  -->
<!-- ****** end 24 ***** -->
<!-- ****** start 25 ***** -->
<p>The value of each property must be the fully qualified name of
the class implementing the specified algorithm, certificate type,
or keystore type. That is, it must be the package name followed by
the class name, where the two are separated by a period.</p>
<!-- ****** end 25 ***** -->
<!-- ****** start 26 ***** -->
<p>As an example, the default provider named <i>SUN</i> implements
the Digital Signature Algorithm (whose standard name is
<code>SHA1withDSA</code>) in a class named <code>DSA</code> in the
<code>sun.security.provider</code> package. Its subclass of
<code>Provider</code> (which is the Sun class in the
<code>sun.security.provider package</code>) sets the
<code>Signature.SHA1withDSA</code> property to have the value
<code>sun.security.provider.DSA</code> via the following:</p>
<pre class="codeblock">
    put("Signature.SHA1withDSA", "sun.security.provider.DSA")
</pre>
<p>The list below shows more properties that can be defined for the
various types of services, where the actual algorithm name is
substitued for <i>algName</i>, certificate type for
<i>certType,</i> keystore type for <i>storeType</i>, and attribute
name for <i>attrName</i>:</p>
<ul>
<li><code>Signature.algName <i>[one or more spaces]</i>
attrName</code></li>
<li><code>MessageDigest.algName <i>[one or more spaces]</i>
attrName</code></li>
<li><code>KeyPairGenerator.algName <i>[one or more spaces]</i>
attrName</code></li>
<li><code>SecureRandom.algName <i>[one or more spaces]</i>
attrName</code></li>
<li><code>KeyFactory.algName <i>[one or more spaces]</i>
attrName</code></li>
<li><code>CertificateFactory.certType <i>[one or more spaces]</i>
attrName</code></li>
<li><code>KeyStore.storeType <i>[one or more spaces]</i>
attrName</code></li>
<li><code>AlgorithmParameterGenerator.algName <i>[one or more
spaces]</i> attrName</code></li>
<li><code>AlgorithmParameters.algName <i>[one or more spaces]</i>
attrName</code></li>
<li><code>Cipher.algName <i>[one or more spaces]</i>
attrName</code></li>
<li><code>KeyAgreement.algName <i>[one or more spaces]</i>
attrName</code></li>
<li><code>KeyGenerator.algName <i>[one or more spaces]</i>
attrName</code></li>
<li><code>Mac.algName <i>[one or more spaces]</i>
attrName</code></li>
<li><code>SecretKeyFactory.algName <i>[one or more spaces]</i>
attrName</code></li>
<li><code>ExemptionMechanism.algName <i>[one or more spaces]</i>
attrName</code></li>
</ul>
</li>
</ul>
<p>In each of these, <code>algName, certType, storeType,</code> or
<code>attrName</code> is the "standard" name of the algorithm,
certificate type, keystore type, or attribute. (See Appendix A of
the Java Cryptography Architecture Reference Guide for the standard
names that should be used.)</p>
<p>For a property in the above format, the value of the property
must be the value for the corresponding attribute. (See <a href=
"CryptoSpec.html#AppA">Appendix A</a> of the Java Cryptography
Architecture API Specification &amp; Reference for the definition
of each standard attribute.)</p>
<p>As an example, the default provider named "SUN" implements the
<code>SHA1withDSA Digital</code> Signature Algorithm in software.
In the master class for the provider "SUN", it sets the
<code>Signature.SHA1withDSA ImplementedIn</code> to have the value
<code>Software</code> via the following:</p>
<pre class="codeblock">
    put("Signature.SHA1withDSA ImplementedIn", "Software")
</pre>
<!-- ****** end 26 ***** -->
<!-- ***** step 3a comes below this two paragraph deletion ***** -->
<!-- **** delete the next couple of paragraphs


        <p> The value of each property must be
the fully qualified name of the class implementing the specified
algorithm. That is, it must be the package name
followed by the class name, where the two are separated by
a period. </p>
        <p> As an example, the "SunJCE" provider implements the
Diffie-Hellman key agreement algorithm in a class named
        <code>DHKeyAgreement</code>
in the <code>com.sun.crypto.provider</code> package. Its subclass of
        <code>Provider</code> (which is the <code>SunJCE</code> class
in the <code>com.sun.crypto.provider</code> package) sets the
        <code>KeyAgreement.DiffieHellman </code>property to have the
value
        <code>com.sun.crypto.provider.DHKeyAgreement</code> via the
following:
        </p>

        <pre class="codeblock">    <code>put("KeyAgreement.DiffieHellman",
        <br></code>
        <code>"com.sun.crypto.provider.DHKeyAgreement")</code>

        </pre>
      </li>
    </ul>
    <p> For further master class property setting examples, see
    <a href="#AppA">Appendix A</a> to view the current <code>SunJCE.java</code>
source file. This shows
how the <code>SunJCE</code> class constructor sets all the properties
for the "SunJCE" provider.
    </p>
    *************** end two paragraph deletion -->
<p>For further master class property setting examples, see Appendix
A to view the current Sun.java source file or Appendix B to see the
<i>SunJCE</i> provider. These files show how the <i>Sun</i> and
<i>SunJCE</i> providers set properties.</p>
<!-- ****** start step 3a ***** -->
<h3><a name="Step3a" id="Step3a">Step 3.1: Additional Steps for
Cipher Implementations</a></h3>
<!-- **** is this also start 27 ?? ***** -->
<p>As mentioned above, in the case of a <code>Cipher</code>
property, <i>algName</i> may actually represent a
<i>transformation</i>. A <i>transformation</i> is a string that
describes the operation (or set of operations) to be performed by a
<code>Cipher</code> object on some given input. A transformation
always includes the name of a cryptographic algorithm (e.g.,
<i>DES</i>), and may be followed by a mode and a padding
scheme.</p>
<p>A transformation is of the form:</p>
<ul>
<li><i>algorithm/mode/padding</i>, or</li>
<li><i>algorithm</i></li>
</ul>
<p>(In the latter case, provider-specific default values for the
mode and padding scheme are used). For example, the following is a
valid transformation:</p>
<pre class="codeblock">
    Cipher c = Cipher.getInstance("DES/CBC/PKCS5Padding"); 
</pre>
<p>When requesting a block cipher in stream cipher mode (for
example; <code>DES</code> in <code>CFB</code> or <code>OFB</code>
mode), a client may optionally specify the number of bits to be
processed at a time, by appending this number to the mode name as
shown in the following sample transformations:</p>
<pre class="codeblock">
    Cipher c1 = Cipher.getInstance("DES/CFB8/NoPadding");
    Cipher c2 = Cipher.getInstance("DES/OFB32/PKCS5Padding");
</pre>
<p>If a number does not follow a stream cipher mode, a
provider-specific default is used. (For example, the <i>SunJCE</i>
provider uses a default of 64 bits.)</p>
<p>A provider may supply a separate class for each combination of
<i>algorithm/mode/padding</i>. Alternatively, a provider may decide
to provide more generic classes representing sub-transformations
corresponding to <i>algorithm</i> or <i>algorithm/mode</i> or
<i>algorithm//padding</i> (note the double slashes); in this case
the requested mode and/or padding are set automatically by the
<code>getInstance</code> methods of <code>Cipher</code>, which
invoke the <code>engineSetMode</code> and
<code>engineSetPadding</code> methods of the provider's subclass of
<code>CipherSpi</code>.</p>
<p>That is, a <code>Cipher</code> property in a provider master
class may have one of the formats shown in the table below.</p>

<table summary="Cipher property formats" width="535" border="1"
cellspacing="2" cellpadding="2">
<thead>
<tr>
<th id="h1" width="45%"><code>Cipher</code> Property Format</th>
<th id="h2" width="55%">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td headers="h1" width="45%"><code>Cipher.</code><i>algName</i></td>
<td headers="h2" width="55%">A provider's subclass of <code>CipherSpi</code>
implements <i>algName</i> with pluggable mode and padding</td>
</tr>
<tr>
<td headers="h1" width="45%"><code>Cipher.</code><i>algName/mode</i></td>
<td headers="h2" width="55%">A provider's subclass of <code>CipherSpi</code>
implements <i>algName</i> in the specified <i>mode</i>, with
pluggable padding</td>
</tr>
<tr>
<td headers="h1" width="45%"><code>Cipher.</code><i>algName//padding</i></td>
<td headers="h2" width="55%">A provider's subclass of <code>CipherSpi</code>
implements <i>algName</i> with the specified <i>padding</i>, with
pluggable mode</td>
</tr>
<tr>
<td headers="h1" width="45%">
<code>Cipher.</code><i>algName/mode/padding</i></td>
<td headers="h2" width="55%">A provider's subclass of <code>CipherSpi</code>
implements <i>algName</i> with the specified <i>mode</i> and
<i>padding</i></td>
</tr>
</tbody>
</table>

<!-- fix this link below!! -->
<p>(See <a href="CryptoSpec.html#AppA">Appendix A</a> of the
<i>Java Cryptography Architecture Reference Guide</i> for the
standard algorithm names, modes, and padding schemes that should be
used.)</p>
<p>For example, a provider may supply a subclass of
<code>CipherSpi</code> that implements <i>DES/ECB/PKCS5Padding</i>,
one that implements <i>DES/CBC/PKCS5Padding</i>, one that
implements <i>DES/CFB/PKCS5Padding</i>, and yet another one that
implements <i>DES/OFB/PKCS5Padding</i>. That provider would have
the following <code>Cipher</code> properties in its master
class:</p>
<ul>
<li><code>Cipher.<i>DES/ECB/PKCS5Padding</i></code></li>
<li><code>Cipher.<i>DES/CBC/PKCS5Padding</i></code></li>
<li><code>Cipher.<i>DES/CFB/PKCS5Padding</i></code></li>
<li><code>Cipher.<i>DES/OFB/PKCS5Padding</i></code></li>
</ul>
<p>Another provider may implement a class for each of the above
modes (i.e., one class for <i>ECB</i>, one for <i>CBC</i>, one for
<i>CFB</i>, and one for <i>OFB</i>), one class for
<i>PKCS5Padding</i>, and a generic <i>DES</i> class that subclasses
from <code>CipherSpi</code>. That provider would have the following
<code>Cipher</code> properties in its master class:</p>
<ul>
<li><code>Cipher.<i>DES</i></code></li>
<!-- add new properties for tiger and JDK 6 here -->
<li><code>Cipher.<i>DES</i> SupportedModes<br />
<i>Example: "ECB|CBC|CFB|OFB"</i></code></li>
<li><code>Cipher.<i>DES</i> SupportedPaddings<br />
<i>Example: "NOPADDING|PKCS5Padding"</i></code></li>
<li><code><!-- end add --></code></li>
</ul>
<!--
    We need to add new copy per #5044020:

6. Close to the end of the same section as of #5, the paragraph which
describes how Cipher.getInstance() works need to be re-written as the
lookup mechanism has been modified/changed by Andreas.Sterbenz@sun.com.
The paragraph starts with the sentence "The getInstance factory method
of the Cipher engine class follows these rules in order to instantiate
a provider's implementation of CipherSpi for a ..." and lasts til the
end of the section.

    -->
<a name="bug6" id="bug6"><!-- convenience marker for engr. -->
 <!--
    <p class="green">Andreas needs to read this section to provide
    examples.  </p>

 --></a>
<p>The <code>getInstance</code> factory method of the
<code>Cipher</code> engine class follows these rules in order to
instantiate a provider's implementation of <code>CipherSpi</code>
for a transformation of the form "<i>algorithm</i>":</p>
<ol>
<li>Check if the provider has registered a subclass of
<code>CipherSpi</code> for the specified "<i>algorithm</i>".<br />
<br />
If the answer is YES, instantiate this class, for whose mode and
padding scheme default values (as supplied by the provider) are
used.<br />
<br />
If the answer is NO, throw a <code>NoSuchAlgorithmException</code>
exception.</li>
</ol>
<p>The <code>getInstance</code> factory method of the
<code>Cipher</code> engine class follows these rules in order to
instantiate a provider's implementation of <code>CipherSpi</code>
for a transformation of the form
"<i>algorithm/mode/padding</i>":</p>
<ol>
<li>Check if the provider has registered a subclass of
<code>CipherSpi</code> for the specified
"<i>algorithm/mode/padding</i>" transformation.<br />
<br />
If the answer is YES, instantiate it.<br />
<br />
If the answer is NO, go to the next step.</li>
<li>Check if the provider has registered a subclass of
<code>CipherSpi</code> for the sub-transformation
"<i>algorithm/mode</i>".<br />
<br />
If the answer is YES, instantiate it, and call
<code>engineSetPadding(<i>padding</i>)</code> on the new
instance.<br />
<br />
If the answer is NO, go to the next step.</li>
<li>Check if the provider has registered a subclass of
<code>CipherSpi</code> for the sub-transformation
"<i>algorithm//padding</i>" (note the double slashes).<br />
<br />
If the answer is YES, instantiate it, and call
<code>engineSetMode(<i>mode</i>)</code> on the new instance.<br />
<br />
If the answer is NO, go to the next step.</li>
<li>Check if the provider has registered a subclass of
<code>CipherSpi</code> for the sub-transformation
"<i>algorithm</i>".<br />
<br />
If the answer is YES, instantiate it, and call
<code>engineSetMode(<i>mode</i>)</code> and
<code>engineSetPadding(<i>padding</i>)</code> on the new
instance.<br />
<br />
If the answer is NO, throw a <code>NoSuchAlgorithmException</code>
exception.</li>
</ol>
<!-- indent this at the step 3 level -->
<!-- ****** This is also marked as
             the end of proposed step 3a ***** -->
<!-- ****** probably the end of 27 ***** -->
<!-- ****** Andreas needs to provide the getinstancefactory ***** -->
<!-- ****** examples for the four steps above ***** -->
<!-- ******

note labelled 5.1:  If your provider is supplying encryption algorithms
through the xxxxx class (see the xxxx 1.a), you will need to sign your
jar file so that Java can authenticate the code at runtime. Link to
step 1a. If you are not providing an implementation, you can skip this
step.

***** -->
<!-- ****** Start 29 ***** -->
<!-- ********************************************* -->
<!-- ****** Insert 5b here and renumber it as 5 ***** -->
<!-- ****** Renumber this current step 5 as step 6 ***** -->
<h2><a name="Step4" id="Step4">Step 4: Compile your Code</a></h2>
<p>After you have created your implementation code (<a href=
"#Step1">Step 1</a>), given your provider a name (<a href=
"#Step2">Step 2</a>), and created the master class (<a href=
"#Step3">Step 3</a>), use the Java compiler to compile your
files.</p>
<!-- **** start new step 5 **** -->
<h2><a name="Step5" id="Step5">Step 5: Place Your Provider in a JAR
File</a></h2>
<p>Place your provider code in a JAR file, in preparation for
signing it in the next step. For more information on the <b>jar</b>
tool, see <b>jar</b> (<a href="../../../tools/unix/jar.html">for
Solaris, Linux, or Mac OS X</a>)
(<a href="../../../tools/windows/jar.html">for Microsoft Windows</a>).</p>
<pre class="codeblock">
    jar cvf &lt;JAR file name&gt; &lt;list of classes, separated by spaces&gt;
</pre>
<p>This command creates a JAR file with the specified name
containing the specified classes.</p>

<h2><a name="Step6" id="Step6">Step 6: Sign your JAR File</a></h2>
<p>If your provider is supplying encryption algorithms through the 
<code>Cipher KeyAgreement,
KeyGenerator, Mac,</code> or <code>SecretKeyFactory</code> classes,
you will need to sign your JAR file so that the JCA can
authenticate the code at runtime. For details, see <a href=
"#Step1a">Step 1a</a>. If you are <b>NOT</b> providing an
implementation of this type you can skip this step.</p>

<h3><a name="Step61" id="Step61">Step 6.1: Get a Code-Signing
Certificate</a></h3>
<p>The next step is to request a code-signing certificate so that
you can use it to sign your provider prior to testing. The
certificate will be good for both testing and production. It will
be valid for 5 years.</p>
<p>Below are the steps you should use to get a code-signing
certificate. For more information on the <b>keytool</b> tool, see
<b>keytool</b> (<a href="../../../tools/unix/keytool.html">for
Solaris, Linux, or Mac OS X</a>)
(<a href="../../../tools/windows/keytool.html">for
Microsoft Windows</a>).</p>
<ol>
<li>Use <b>keytool</b> to generate a DSA keypair, using DSA
algorithm as an example:
<pre class="codeblock">
    keytool -genkeypair -alias &lt;alias&gt; \
        -keyalg DSA -keysize 1024 \
        -dname "cn=&lt;Company Name&gt;, \
        ou=Java Software Code Signing,\
        o=Sun Microsystems Inc" \
        -keystore &lt;keystore file name&gt;\
        -storepass &lt;keystore password&gt;
        
</pre>
<p>This will generate a DSA keypair (a public key and an associated
private key) and store it in an entry in the specified keystore.
The public key is stored in a self-signed certificate. The keystore
entry can subsequently be accessed using the specified alias.</p>
<br />
<p>The option values in angle brackets ("&lt;" and "&gt;")
represent the actual values that must be supplied. For example,
<code>&lt;alias&gt;</code> must be replaced with whatever alias
name you wish to be used to refer to the newly-generated keystore
entry in the future, and <code>&lt;keystore file name&gt;</code>
must be replaced with the name of the keystore to be used.
<b>Note:</b> Do not surround actual values with angle brackets. For
example, if you want your alias to be <code>myTestAlias</code>,
specify the <code>-alias</code> option as follows:</p>
<pre class="codeblock">
    -alias myTestAlias
</pre>
If you specify a keystore that doesn't yet exist, it will be
created.<br />
<br />
<hr />
<p><b>Note:</b> If command lines you type are not allowed to be as
long as the <code>keytool -genkeypair</code> command you want to
execute (for example, if you are typing to a Microsoft Windows DOS
prompt), you can create and execute a plain-text batch file
containing the command. That is, create a new text file that
contains nothing but the full <code>keytool -genkeypair</code>
command. (Remember to type it all on one line.) Save the file with
a .bat extension. Then in your DOS window, type the file name (with
its path, if necessary). This will cause the command in the batch
file to be executed.</p>
<hr />
<br /></li>
<li>Use <b>keytool</b> to generate a certificate signing request.
<pre class="codeblock">
    keytool -certreq -alias &lt;alias&gt; \
        -file &lt;csr file name&gt; \
        -keystore &lt;keystore file name&gt; \
        -storepass &lt;keystore password&gt; 
</pre>
Here, <code><i>&lt;alias&gt;</i></code> is the alias for the DSA
keypair entry created in the previous step. This command generates
a Certificate Signing Request (CSR), using the PKCS#10 format. It
stores the CSR in the file whose name is specified in
<code><i>&lt;csr file name&gt;</i></code>.</li>
<li>Send the CSR, contact information, and other required
documentation to the JCA Code Signing Certification Authority. See
<a href=
"http://www.oracle.com/technetwork/java/javase/tech/getcodesigningcertificate-361306.html#jcacodesigning"
target="_blank">JCA Code Signing Certification Authority</a> for
contact info.</li>
<li>After the JCA Code Signing Certification Authority has received
your email message, they will send you a request number via email.
Once you receive this request number, you should print, fill out
and send the Certification Form for CSPs. See <a href=
"http://www.oracle.com/technetwork/java/javase/tech/getcodesigningcertificate-361306.html#sendingcertificationform"
target="_blank">Sending Certification Form for CSPs</a> for contact
information.</li>
<li>Use <b>keytool</b> to import the certificates received from the
CA.<br />
<br />
Once you have received the two certificates from the JCA Code
Signing Certification Authority, you can use <b>keytool</b> to
import them into your keystore.<br />
<br />
First import the CA's certificate as a "trusted certificate":
<pre class="codeblock">
    keytool -import -alias &lt;alias for the CA cert&gt; \
        -file &lt;CA cert file name&gt; \
        -keystore &lt;keystore file name&gt; \
        -storepass &lt;keystore password&gt;
</pre>
Then import the code-signing certificate:
<pre class="codeblock">
    keytool -import -alias &lt;alias&gt; \
        -file &lt;code-signing cert file name&gt; \
        -keystore &lt;keystore file name&gt; \
        -storepass &lt;keystore password&gt;
</pre>
Here, <code><i>&lt;alias&gt;</i></code> is the same alias as that
which you created in step 1 where you generated a DSA keypair. This
command replaces the self-signed certificate in the keystore entry
specified by <code><i>&lt;alias&gt;</i></code> with the one signed
by the JCA Code Signing Certification Authority.</li>
</ol>
<p>Now that you have in your keystore a certificate from an entity
trusted by JCA (the JCA Code Signing Certification Authority), you
can place your provider code in a JAR file (<a href="#Step5">Step
5</a>) and then use that certificate to sign the JAR file (<a href=
"#Step62">Step 6.2</a>).</p>
<!-- ****** this is the new step 5 ***** -->
<!-- ****** still part of 29 ***** -->
<!--
    <h3><a name="Step5b">Step 5b: Place Your Provider in a JAR File</a></h3>

      <p> Place your provider code in a JAR file, in preparation
for signing it in the next step. For more information on the <b>jar</b>
tool, see <b>jar</b> (<a href="../../../tools/unix/jar.html">for
Solaris, Linux, or Mac OS X</a>) (<a href="../../../tools/windows/jar.html">for
Microsoft Windows</a>).
      </p>
      <pre class="codeblock">
    jar cvf &lt;JAR file name&gt; &lt;list of classes, separated by spaces&gt;
    </pre>
      <p> This command creates a JAR file with the specified name
containing the specified classes.
      </p>
     -->
<!-- ****** this becomes step 5b ***** -->
<h3><a name="Step62" id="Step62">Step 6.2: Sign Your
Provider</a></h3>
<p>Sign the JAR file created in step five with the code-signing
certificate obtained in <a href="#Step6">Step 6</a>. For more
information on the <b>jarsigner</b> tool, see <b>jarsigner</b>
(<a href="../../../tools/unix/jarsigner.html">for Solaris, Linux,
or Mac OS X</a>)
(<a href="../../../tools/windows/jarsigner.html">for Microsoft
Windows</a>).</p>
<pre class="codeblock">
    jarsigner -keystore &lt;keystore file name&gt; \
        -storepass &lt;keystore password&gt; \
        &lt;JAR file name&gt; &lt;alias&gt;
</pre>
<p>Here, <code>&lt;alias&gt;</code> is the alias into the keystore
for the entry containing the code-signing certificate received from
the JCA Code Signing Certification Authority (the same alias as
that specified in the commands in <a href="#Step61">Step
6.1</a>).</p>
<p>You can test verification of the signature via the
following:</p>
<pre class="codeblock">
    jarsigner -verify &lt;JAR file name&gt; <br />
</pre>
<p>The text "jar verified" will be displayed if the verification
was successful.</p>
<hr />
<p><b>Note:</b> If you bundle a signed JCE provider as part of an RIA
(applet or webstart application), for the best user experience,
you should apply a second signature to the JCE provider
JAR with the same certificate/key that you used to sign the applet
or webstart application. See the
<a href="../../deploy/index.html">Java Platform, Standard Edition Deployment Guide</a>
for more information on deploying RIAs, and the
<tt>jarsigner</tt> (<a href="../../../tools/unix/jarsigner.html">Solaris, Linux, or Mac OS X</a> or
<a href="../../../tools/windows/jarsigner.html">Windows</a>)
man page for information on applying multiple signatures to a JAR file.</p>
<hr />

<h2><a name="Step7" id="Step7">Step 7: Prepare for Testing</a></h2>
<p>The next steps describe how to install and configure your new
provider so that it is available via the JCA.</p>
<h3><a name="Step71" id="Step71">Step 7.1: Install the
Provider</a></h3>
<p>In order to prepare for testing your provider, you must install
it in the same manner as will be done by clients wishing to use it.
The installation enables Java Security to find your algorithm
implementations when clients request them.</p>
<p>Installing a provider is done in two steps: installing the
provider package classes, and configuring the provider.</p>
<h4><a name="InstallProv" id="InstallProv">Installing the Provider
Classes</a></h4>
<p>The first thing you must do is make your classes available so
that they can be found when requested. You ship your provider
classes as a JAR (Java ARchive) file.</p>
<p>There are a two possible ways to install provider classes:</p>
<ul>
<li>Install the JAR file containing the provider classes as an
<i>installed</i> or <i>bundled</i> extension.</li>
<li>Place the JAR file containing the provider classes in your
CLASSPATH.</li>
</ul>
<p>The provider JAR file will be considered an installed extension
if it is placed in the standard place for the JAR files of an
installed extension:</p>

<ul>
  <li>Solaris, Linux, or Mac OS X:  <code><em>&lt;java-home&gt;</em>/lib/ext</code></li>
  <li>Windows:                      <code><em>&lt;java-home&gt;</em>\lib\ext</code></li>
</ul>
  
<p>Here <tt>&lt;java-home&gt;</tt> refers to the directory where
the runtime software is installed, which is the top-level directory
of the Java Runtime Environment (JRE) or the <tt>jre</tt>
directory in the Java SE (JDK) software. For example, if you
have the JDK installed on Solaris, Linux, or Mac OS X in a directory named
<code>/home/user1/jdk</code>, or on Microsoft Windows in a
directory named <code>C:\jdk</code>, then you need to install
the JAR file in the following directory:</p>

<ul>
  <li>Solaris, Linux, or Mac OS X:  <code>/home/user1/jdk/jre/lib/ext</code></li>
  <li>Windows:                      <code>C:\jdk\jre\lib\ext</code></li>
</ul>

<p>Similarly, if you have the JRE installed on Solaris, Linux,
or Mac OS X in a directory named <code>/home/user1/jre</code>,
or on Microsoft Windows in
a directory named <code>C:\jre</code>, you need to install the
JAR file in the following directory:</p>

<ul>
  <li>Solaris, Linux, or Mac OS X: <code>/home/user1/jre/lib/ext</code></li>
  <li>Windows:                     <code>C:\jre\lib\ext</code></li>
</ul>

<p>For more information on <i>installed</i> extensions, see
<a href="../../extensions/spec.html#installed">Installed
Extensions</a>.</p>
<p>For more information on <i>bundled</i> extensions, see <a href=
"../../extensions/spec.html#bundled">Bundled Extensions</a>.</p>
<h4><a name="Configuring" id="Configuring">Configuring the
Provider</a></h4>
<p>The next step is to add the provider to your list of approved
providers. This is done statically by editing the security
properties file</p>

<ul>
  <li>Solaris, Linux, or Mac OS X: <code><em>&lt;java-home&gt;</em>/lib/security/java.security</code></li>
  <li>Windows:                     <code><em>&lt;java-home&gt;</em>\lib\security\java.security</code></li>
</ul>

<p>Here <tt>&lt;java-home&gt;</tt> refers to the directory where
the JRE was installed. For example, if you have the JDK installed on
Solaris, Linux, or Mac OS X in a directory named
<code>/home/user1/jdk</code>, or
on Microsoft Windows in a directory named <code>C:\jdk</code>,
then you need to edit the following file:</p>

<ul>
  <li>Solaris, Linux, or Mac OS X: <code>/home/user1/jdk/jre/lib/security/java.security</code></li>
  <li>Windows:                     <code>C:\jdk\jre\lib\security\java.security</code></li>
</ul>

<p>Similarly, if you have the JRE installed on Solaris, Linux, or Mac OS X in a
directory named <code>/home/user1/jre</code>, or on Windows in
a directory named <code>C:\jre</code>, then you need to edit
this file:</p>

<ul>
  <li>Solaris, Linux, or Mac OS X: <code>/home/user1/jre/lib/security/java.security</code></li>
  <li>Windows:                     <code>C:\jre\lib\security\java.security</code></li>
</ul>

<p>For each provider, this file should have a statement of the
following form:</p>
<pre class="codeblock">
    security.provider.<i>n</i>=<i>masterClassName</i> 
</pre>
<p>This declares a provider, and specifies its preference order
<i>n</i>. The preference order is the order in which providers are
searched for requested algorithms when no specific provider is
requested. The order is 1-based; 1 is the most preferred, followed
by 2, and so on.</p>
<p><i>masterClassName</i> must specify the fully qualified name of
the provider's "master class", which you implemented in <a href=
"#Step3">Step 3</a>. This class is always a subclass of the
Provider class.</p>
<p><a name="bug8" id="bug8">Java comes standard with providers
named <i>SUN</i>, <i>SunRsaSign</i>, and <i>SunJCE</i> which are
automatically configured as a static provider in the
<code>java.security</code> properties file, as follows:</a></p>
<pre class="codeblock">
    security.provider.2=sun.security.provider.Sun
    security.provider.3=sun.security.rsa.SunRsaSign
    security.provider.4=sun.security.provider.SunJCE
</pre>
<p>(The <i>Sun</i> provider's master class is the <code>Sun</code>
class in the <code>sun.security.provider</code> package.)</p>
<p>The JCA provider <i>SunJCE</i> and other security-related
providers shipped with the Java platform are also automatically
configured as static providers.</p>
<p>To utilize another JCA provider, add a line registering the
alternate provider, giving it a lower preference order than the SUN
and SunRsaSign providers.</p>
<p>Suppose that your master class is the <code>CryptoX</code> class
in the <code>com.cryptox.provider</code> package, and that you
would like to make your provider the fourth preferred provider. To
do so, edit the <code>java.security</code> file as seen below:</p>
<pre class="codeblock">
    security.provider.2=sun.security.provider.Sun
    security.provider.3=sun.security.rsa.SunRsaSign
    security.provider.4=com.cryptox.provider.CryptoX
    security.provider.5=sun.security.provider.SunJCE
</pre>
<p><b>Note:</b> Providers may also be registered dynamically. To do
so, a program (such as your test program, to be written in <a href=
"#Step8">Step 8</a>) can call either the <code>addProvider</code>
or <code>insertProviderAt</code> method in the
<code>Security</code> class. This type of registration is not
persistent and can only be done by code which is granted the
following permission:</p>
<pre class="codeblock">
    java.security.SecurityPermission "insertProvider.{name}"
</pre>
<p>where <code>{name}</code> is replaced by the actual provider
name.</p>
<p>For example, if the provider name is "MyJCE" and if the
provider's code is in the <code>myjce_provider.jar</code> file in
the <code>/localWork</code> directory, then here is a sample policy
file <code>grant</code> statement granting that permission:</p>
<pre class="codeblock">
    grant codeBase "file:/localWork/myjce_provider.jar" {
        permission java.security.SecurityPermission
            "insertProvider.MyJCE";
    };
</pre>
<h3><a name="Step72" id="Step72">Step 7.2: Set Provider
Permissions</a></h3>
<p>Whenever providers are not installed extensions, <a href=
"../permissions.html">permissions</a> must be granted for when
applets or applications are run while a security manager is
installed. There is typically a security manager installed whenever
an applet is running, and a security manager may be installed for
an application either via code in the application itself or via a
command-line argument. Permissions do not need to be granted to
installed extensions, since the default system <a href=
"../PolicyFiles.html">policy file</a> grants all permissions to
installed extensions.</p>
<p>Whenever a client does not install your provider as an installed
extension, your provider may need the following permissions granted
to it in the client environment:</p>
<ul>
<li><code>java.lang.RuntimePermission</code> to get class
protection domains. The provider may need to get its own protection
domain in the process of doing self-integrity checking.</li>
<li><code>java.security.SecurityPermission</code> to set provider
properties.</li>
</ul>
<p>To ensure your provider works when a security manager is
installed and the provider is not an installed extension, you need
to test such an installation and execution environment. In
addition, prior to testing you need to grant appropriate
permissions to your provider and to any other providers it uses.
For example, a sample statement granting permissions to a provider
whose name is "MyJCE" and whose code is in
<code>myjce_provider.jar</code> appears below. Such a statement
could appear in a policy file. In this example, the
<code>myjce_provider.jar</code> file is assumed to be in the
<code>/localWork</code> directory.</p>
<pre class="codeblock">
    grant codeBase "file:/localWork/myjce_provider.jar" {
        permission java.lang.RuntimePermission "getProtectionDomain";
        permission java.security.SecurityPermission
            "putProviderProperty.MyJCE";
    };
</pre>
<h2><a name="Step8" id="Step8">Step 8: Write and Compile your Test
Programs</a></h2>
<p>Write and compile one or more test programs that test your
provider's incorporation into the Security API as well as the
correctness of its algorithm(s). Create any supporting files
needed, such as those for test data to be encrypted.</p>
<p>The first tests your program should perform are ones to ensure
that your provider is found, and that its name, version number, and
additional information is as expected. To do so, you could write
code like the following, substituting your provider name for
<code>MyPro</code>:</p>
<pre class="codeblock">
    import java.security.*;

    Provider p = Security.getProvider("MyPro");

    System.out.println("MyPro provider name is " + p.getName());
    System.out.println("MyPro provider version # is " + p.getVersion());
    System.out.println("MyPro provider info is " + p.getInfo());
</pre>
<p>Next, you should ensure that your services are found. For
instance, if you implemented the DES encryption algorithm, you
could check to ensure it's found when requested by using the
following code (again substituting your provider name for
"MyPro"):</p>
<pre class="codeblock">
    Cipher c = Cipher.getInstance("DES", "MyPro");

    System.out.println("My Cipher algorithm name is " + c.getAlgorithm());
</pre>
<p>If you don't specify a provider name in the call to
<code>getInstance</code>, all registered providers will be
searched, in preference order (see <a href=
"#Configuring">Configuring the Provider</a>), until one
implementing the algorithm is found.</p>
<p>If your provider implements an exemption mechanism, you should
write a test applet or application that uses the exemption
mechanism. Such an applet/application also needs to be signed, and
needs to have a "permission policy file" bundled with it. See
<a href="CryptoSpec.html#ExemptApps">How to Make Applications
"Exempt" from Cryptographic Restrictions</a> in the <i>Java
Cryptography Architecture Reference Guide</i> for complete
information on creating and testing such an application.</p>
<h2><a name="Step9" id="Step9">Step 9: Run your Test
Programs</a></h2>
<p>Run your test program(s). Debug your code and continue testing
as needed. If the Java Security API cannot seem to find one of your
algorithms, review the steps above and ensure they are all
completed.</p>
<p>Be sure to include testing of your programs using different
installation options (e.g. making the provider an installed
extension or placing it on the class path) and execution
environments (with or without a security manager running).
Installation options are discussed in <a href="#Step71">Step
7.1</a>. In particular, you need to ensure your provider works when
a security manager is installed and the provider is not an
installed extension -- and thus the provider must have permissions
granted to it; therefore, you need to test such an installation and
execution environment, after granting required permissions to your
provider and to any other providers it uses, as described in
<a href="#Step72">Step 7.2</a>.</p>
<p>If you find during testing that your code needs modification,
make the changes, recompile (<a href="#Step4">Step 4</a>), place
the updated provider code in a JAR file (<a href="#Step6">Step
6</a>), sign the JAR file if necessary (<a href="#Step62">Step
6.2</a>), re-install the provider (<a href="#Step71">Step 7.1</a>),
if needed fix or add to the permissions (<a href="#Step72">Step
7.2</a>), and then re-test your programs. Repeat these steps as
needed.</p>
<h2><a name="Step10" id="Step10">Step 10: Apply for U.S. Government
Export Approval If Required</a></h2>
<p>All U.S. vendors whose providers may be exported outside the
U.S. should apply to the Bureau of Industry and Security in the
U.S. Department of Commerce for export approval. Please consult
your export counsel for more information.</p>
<p><b>Note:</b> If your provider calls
<code>Cipher.getInstance()</code> and the returned
<code>Cipher</code> object needs to perform strong cryptography
regardless of what cryptographic strength is allowed by the user's
downloaded jurisdiction policy files, you should include a copy of
the <code>cryptoPerms</code> permission policy file which you
intend to bundle in the JAR file for your provider and which
specifies an appropriate permission for the required cryptographic
strength. The necessity for this file is just like the requirement
that applets and applications "exempt" from cryptographic
restrictions must include a <code>cryptoPerms</code> permission
policy file in their JAR file. For more information on the creation
and inclusion of such a file, see <a href=
"CryptoSpec.html#ExemptApps">How to Make Applications "Exempt" from
Cryptographic Restrictions</a> in the <i>Java Cryptography
Architecture Reference Guide</i>.</p>
<p>Here are two URLs that may be useful:</p>
<ul>
<li>U.S. Department of Commerce: <a href=
"http://www.commerce.gov">http://www.commerce.gov</a></li>
<li>Bureau of Industry and Security: <a href=
"http://www.bis.doc.gov">http://www.bis.doc.gov</a></li>
</ul>
<h2><a name="Step11" id="Step11">Step 11: Document your Provider
and its Supported Services</a></h2>
<p>The next step is to write documentation for your clients. At the
minimum, you need to specify:</p>
<ul>
<li>the name programs should use to refer to your provider.
<b>Note:</b> As of this writing, provider name searches are
<b>case-sensitive</b>. That is, if your master class specifies your
provider name as "CryptoX" but a user requests "CRYPTOx", your
provider will not be found. This behavior may change in the future,
but for now be sure to warn your clients to use the exact case you
specify.</li>
<li>the types of algorithms and other services implemented by your
provider.</li>
<li>instructions for installing the provider, similar to those
provided in <a href="#Step71">Step 7.1</a>, except that the
information and examples should be specific to your provider.</li>
<li>the permissions your provider will require if it is not
installed as an installed extension and if a security manager is
run, as described in <a href="#Step72">Step 7.2</a>.</li>
</ul>
<p>In addition, your documentation should specify anything else of
interest to clients, such as any default algorithm parameters. 
<!-- ****** looks like the end of 30. ***** -->
<!-- ***************************************** -->
 <!-- ****** 31 start ***** -->
<!-- ***************************************** -->
 <!-- ****** Message Digests and MACs ***** -->
<!-- ****** Merge these two sections here ***** --></p>
<h3><a name="Digests" id="Digests">Message Digests and
MACs</a></h3>

<p>For each Message Digest and MAC algorithm, indicate whether or
not your implementation is cloneable. This is not technically
necessary, but it may save clients some time and coding by telling
them whether or not intermediate Message Digests or MACs may be
possible through cloning. Clients who do not know whether or not a
<code>MessageDigest</code> or <code>Mac</code> implementation is
cloneable can find out by attempting to clone the object and
catching the potential exception, as illustrated by the following
example:</p>
<pre class="codeblock">
    try {
        // try and clone it
        /* compute the MAC for i1 */
        mac.update(i1);
        byte[] i1Mac = mac.clone().doFinal();

        /* compute the MAC for i1 and i2 */
        mac.update(i2);
        byte[] i12Mac = mac.clone().doFinal();

        /* compute the MAC for i1, i2 and i3 */
        mac.update(i3);
        byte[] i123Mac = mac.doFinal();
    } catch (CloneNotSupportedException cnse) {
        // have to use an approach not involving cloning
    } 
</pre>
<p>where:</p>
<ul>
<li><code>mac</code> is the MAC object they received when they
requested one via a call to <code>Mac.getInstance</code>,</li>
<li><code>i1</code>, <code>i2</code> and <code>i3</code> are input
byte arrays, and</li>
<li>they want to calculate separate hashes for:
<ul>
<li><code>i1</code></li>
<li><code>i1 and i2</code></li>
<li><code>i1, i2, and i3</code></li>
</ul>
</li>
</ul>
<h4>Key Pair Generators</h4>
<p>For a key pair generator algorithm, in case the client does not
explicitly initialize the key pair generator (via a call to an
<code>initialize</code> method), each provider must supply and
document a default initialization. For example, the Diffie-Hellman
key pair generator supplied by the <i>SunJCE</i> provider uses a
default prime modulus size (<code>keysize</code>) of 1024 bits.</p>
<h4>Key Factories</h4>
<p>A provider should document all the key specifications supported
by its (secret-)key factory.</p>
<h4>Algorithm Parameter Generators</h4>
<p>In case the client does not explicitly initialize the algorithm
parameter generator (via a call to an <code>init</code> method in
the <code>AlgorithmParameterGenerator</code> engine class), each
provider must supply and document a default initialization. For
example, the <i>SunJCE</i> provider uses a default prime modulus
size (<code>keysize</code>) of 1024 bits for the generation of
Diffie-Hellman parameters, the <i>Sun</i> provider a default
modulus prime size of 1024 bits for the generation of DSA
parameters.</p>
<h4>Signature Algorithms</h4>
<p>If you implement a signature algorithm, you should document the
format in which the signature (generated by one of the
<code>sign</code> methods) is encoded. For example, the SHA1withDSA
signature algorithm supplied by the "SUN" provider encodes the
signature as a standard <code>ASN.1 SEQUENCE</code> of two
integers, <code>r</code> and <code>s</code>.</p>
<h4>Random Number Generation (SecureRandom) Algorithms</h4>
<p>For a random number generation algorithm, provide information
regarding how "random" the numbers generated are, and the quality
of the seed when the random number generator is self-seeding. Also
note what happens when a SecureRandom object (and its encapsulated
SecureRandomSpi implementation object) is deserialized: If
subsequent calls to the <code>nextBytes</code> method (which
invokes the <code>engineNextBytes</code> method of the encapsulated
SecureRandomSpi object) of the restored object yield the exact same
(random) bytes as the original object would, then let users know
that if this behaviour is undesirable, they should seed the
restored random object by calling its <code>setSeed</code>
method.</p>
<h4>Certificate Factories</h4>
<p>A provider should document what types of certificates (and their
version numbers, if relevant), can be created by the factory.</p>
<h4>Keystores</h4>
<p>A provider should document any relevant information regarding
the keystore implementation, such as its underlying data
format.</p>
<h2><a name="Step12" id="Step12">Step 12: Make your Class Files and
Documentation Available to Clients</a></h2>
<p>After writing, configuring, testing, installing and documenting
your provider software, make documentation available to your
customers.</p>
<!-- ****** 32 end ***** -->
<!-- ****** Start 33 ***** -->
<!-- ** expand "encryption services"  below to include "the list"
-->
<!-- this is a major head in the document -->
<h2><a name="integritycheck" id="integritycheck">How a Provider Can
Do Self-Integrity Checking</a></h2>
<p>Each provider should do self-integrity checking to ensure that
the JAR file containing its code has not been tampered with, for
example in an attempt to invoke provider methods directly rather
than through JCA. Providers that provide implementations for
encryption services (<code>Cipher, KeyAgreement, KeyGenerator,
MAC</code> or <code>SecretKey</code> factory) must be digitally
signed and should be signed with a certificate issued by "trusted"
Certification Authorities. Currently, the following two
Certification Authorities are considered "trusted":</p>
<ul>
<li>Sun Microsystems' JCA Code Signing CA, and</li>
<li>IBM JCA Code Signing CA.</li>
</ul>
<p>Please refer to <a href="#Step62">Step 6.2</a> for detailed
information on how to get a code-signing certificate from Sun
Microsystems' JCA Code Signing CA and the certificate of that
CA.</p>
<p>After getting the signing certificate from above Certification
Authority, provider packages should embed within themselves the
bytes for its own signing certificate, for example in an array like
the <code>bytesOfProviderCert</code> array referred to in the
<a href="#ChainRoots">Identifying Each of the Signers and
Determining If One is Trusted</a> section below. At runtime, the
embedded certificate will be used in determining whether or not the
provider code is authentic.</p>
<p>The basic approach a provider can use to check its own integrity
is:</p>
<ol>
<li>Determine the URL of the JAR file containing the provider code,
and</li>
<li>Verify the JAR file's digital signatures to ensure that at
least one signer of each entry of the JAR file is trusted.</li>
</ol>
<p>Each of these steps is described in the following sections:</p>
<ul>
<li><a href="#SampleCodeNotes">Notes on the Sample Code</a></li>
<li><a href="#FindJFBasics">Finding the Provider JAR File:
Basics</a>
<ul>
<li><a href="#FindJFURL">Determining the Provider's JAR File
URL</a></li>
<li><a href="#CreateJarFile">Creating a JarFile Referring to the
JAR File</a></li>
</ul>
</li>
<li><a href="#VerifyJFBasics">Verifying the Provider JAR File:
Basics</a>
<ul>
<li><a href="#VerifySetup">Verification Setup</a></li>
<li><a href="#CheckJARFile">JAR File Signature Check</a></li>
<li><a href="#VerifySigs">Verifying Signatures</a></li>
<li><a href="#JCEAuthTrust">Ensuring Signers Are Trusted</a>
<ul>
<li><a href="#GetSignerCerts">Getting the List of
Certificates</a></li>
<li><a href="#ChainRoots">Identifying Each of the Signers and
Determining If One is Trusted</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#VerifySigs">Verifying Signatures</a></li>
<li><a href="#JCEAuthTrust">Ensuring Signers Are Trusted</a>
<ul>
<li><a href="#GetSignerCerts">Getting the List of
Certificates</a></li>
<li><a href="#ChainRoots">Identifying Each of the Signers and
Determining If One is Trusted</a></li>
<li><a href="#myJCECodeNotes">Notes on <i>myJCE</i> Sample
Code</a></li>
</ul>
</li>
</ul>
<dl>
<dt><a name="SampleCodeNotes" id="SampleCodeNotes">Notes on the
Sample Code</a></dt>
</dl>
<hr />
<p><b>Note:</b> The sample code <a href=
"MyJCE.java"><b><code>MyJCE.java</code></b></a> is a complete code
example that implements these steps. You can download this code for
your reference. The <a href="#SampleCodeNotes">Notes on the Sample
Code</a> section traces how these concepts are implemented in the
sample code.</p>
<hr />

<p><b>IMPORTANT NOTE:</b> In the unbundled version of JCE 1.2.x,
(used with JDKs 1.2.x and 1.3.x), providers needed to include code
to authenticate the JCA framework to assure themselves of the
integrity and authenticity of the JCA that they plugged into. In
JDK 6 and later, this is no longer necessary.</p>

<p>One implication is that a provider written just for JCE 1.2.2
will not work in JDK 6 because the provider's JCE framework
authentication check will not work; the JCE framework code is no
longer where the provider expects it to be. If you want your
provider to work only with JDK 6, it should not have code to
authenticate the JCE framework. On the other hand, if you want your
provider to work both with JCE 1.2.2 and with JDK 6, then add a
conditional statement. This way the provider code to authenticate
the JCE framework is executed only when the provider is run with
JCE 1.2.2. The following is sample code:</p>
<pre class="codeblock">
    Class cipherCls = Class.forName("javax.crypto.Cipher");

    CodeSource cs = cipherCls.getProtectionDomain().getCodeSource();
    if (cs != null) {
        // Authenticate JCE framework<br />         . . .
    } 
</pre>
<hr />
<h2><a name="FindJFBasics" id="FindJFBasics">Finding the Provider
JAR File: Basics</a></h2>
<a name="FindJFURL" id="FindJFURL"></a>
<h3>Determining the Provider's JAR File URL</h3>
<p>The URL for the provider's JAR file can be obtained by
determining the provider's <code>CodeSource</code> and then calling
the <code>getLocation</code> method on the
<code>CodeSource</code>.</p>
<pre class="codeblock">
    URL providerURL = (URL) AccessController.doPrivileged(
        new PrivilegedAction) {
            public Object run() {
                CodeSource cs =
                    MyJCE.class.getProtectionDomain().getCodeSource();
                return cs.getLocation();
            }
        }); 
</pre>
<h3><a name="CreateJarFile" id="CreateJarFile">Creating a JarFile
Referring to the JAR File</a></h3>
<p>Once you have the URL for the provider's JAR file, you can
create a <code>java.util.jar.JarFile</code> referring to the JAR
file. This instance is needed in the step for <a href=
"#VerifyJFBasics">verifying the Provider JAR file</a>.</p>
<p>To create the JAR file, first open a connection to the specified
URL by calling its <code>openConnection</code> method. Since the
URL is a JAR URL, the type is
<code>java.net.JarURLConnection</code>. Here's the basic code:</p>
<pre class="codeblock">
    // Prep the url with the appropriate protocol.
    jarURL =
        url.getProtocol().equalsIgnoreCase("jar") ? url :
            new URL("jar:" + url.toString() + "!/");

    // Retrieve the jar file using JarURLConnection
    JarFile jf = (JarFile) AccessController.doPrivileged(
        new PrivilegedExceptionAction() {
            public Object run() throws Exception {
                <b>JarURLConnection conn =
                    (JarURLConnection) jarURL.openConnection();</b>
        ...  
</pre>
<p>Now that you have a <code>JarURLConnection</code>, you can call
its <code>getJarFile</code> method to get the JAR file:</p>
<pre class="codeblock">
    // Always get a fresh copy, so we don't have to
    // worry about the stale file handle when the
    // cached jar is closed by some other application.
    conn.setUseCaches(false);
    <b>jf = conn.getJarFile();</b> 
</pre>
<h2><a name="VerifyJFBasics" id="VerifyJFBasics">Verifying the
Provider JAR File: Basics</a></h2>
<p>Once you have determined the URL for your provider JAR file and
you have created a <code>JarFile</code> referring to the JAR file,
as shown in the steps above, you can then verify the file.</p>
<p>The basic approach is:</p>
<ol>
<li>Ensure that at least one of each entry's signer's certificates
is equal to the provider's own code signing certificate.</li>
<li>Go through all the entries in the JAR file and ensure the
signature on each one verifies correctly.</li>
<li>Ensure that at least one of each entry's signer's certificates
can be traced back to a trusted Certification Authority.</li>
</ol>
<p>Sample code for each of these steps is presented and described
in the following sections:</p>
<!-- Third mini-TC -->
<!-- Third mini-TC -->
<!-- Third mini-TC -->
<ul>
<li><a href="#VerifySetup">Verification Setup</a></li>
<li><a href="#CheckJARFile">JAR File Signature Check</a></li>
<li><a href="#VerifySigs">Verifying Signatures</a></li>
<li><a href="#JCEAuthTrust">Ensuring Signers Are Trusted</a>
<ul>
<li><a href="#GetSignerCerts">Getting the List of
Certificates</a></li>
<li><a href="#ChainRoots">Identifying Each of the Signers and
Determining If One is Trusted</a></li>
</ul>
</li>
</ul>
<h3><a href="#ChainRoots"></a><a name="VerifySetup" id=
"VerifySetup">Verification Setup</a></h3>
<p>Our approach is to define a class <code>JarVerifier</code> to
handle the retrieval of a JAR file from a given URL and verify
whether the JAR file is signed with the specified certificate.</p>
<p>The constructor of <code>JarVerifier</code> takes the provider
URL as a parameter which will be used to retrieve the JAR file
later.</p>
<p>The actual jar verification is implemented in the
<code>verify</code> method which takes the provider code signing
certificate as a parameter.</p>
<pre class="codeblock">
    public void verify(X509Certificate targetCert) throws IOException {
        // variable 'jarFile' is a JarFile object created
        // from the provider's Jar URL.
        ...
        Vector entriesVec = new Vector(); 
</pre>
<p>Basically the <code>verify</code> method will go through the JAR
file entries twice: the first time checking the signature on each
entry and the second time verifying the signer is trusted.</p>
<p><b>Note:</b> In our code snippets the <code>jarFile</code>
variable is the <code>JarFile</code> object of the provider's jar
file.</p>
<h3><a name="CheckJARFile" id="CheckJARFile">JAR File Signature
Check</a></h3>
<p>An authentic provider JAR file is signed. So the JAR file has
been tampered with if it isn't signed:</p>
<pre class="codeblock">
    // Ensure the jar file is signed.
    Manifest man = jarFile.getManifest();
    if (man == null) {
        throw new SecurityException("The provider is not signed");
    } 
</pre>
<h3><a name="VerifySigs" id="VerifySigs">Verifying
Signatures</a></h3>
<p>The next step is to go through all the entries in the JAR file
and ensure the signature on each one verifies correctly. One
possible way to verify the signature on a JAR file entry is to
simply read the file. If a JAR file is signed, the
<code>read</code> method itself automatically performs the
signature verification. Here is sample code:</p>
<pre class="codeblock">
    // Ensure all the entries' signatures verify correctly
    byte[] buffer = new byte[8192];
    Enumeration entries = jarFile.entries();

    while (entries.hasMoreElements()) {
        JarEntry je = (JarEntry) entries.nextElement();

        // Skip directories.
        if (je.isDirectory())
            continue;

        entriesVec.addElement(je);
        InputStream is = jarFile.getInputStream(je);

        // Read in each jar entry. A security exception will
        // be thrown if a signature/digest check fails.
        int n;
        while ((n = is.read(buffer, 0, buffer.length)) != -1) {
            // Don't care
        }
        is.close();
    }
    
</pre>
<h3><a name="JCEAuthTrust" id="JCEAuthTrust">Ensuring Signers Are
Trusted</a></h3>
<p>The code in the previous section verified the signatures of all
the provider JAR file entries. The fact that they all verify
correctly is a requirement, but it is not sufficient to verify the
authenticity of the JAR file. A final requirement is that the
signatures were generated by the same entity as the one that
developed this provider. To test that the signatures are trusted,
we can again go through each entry in the JAR file (this time using
the <code>entriesVec</code> built in the previous step), and for
each entry that must be signed (that is, each entry that is not a
directory and that is not in the META-INF directory):</p>
<ol>
<li>Get the list of signer certificates for the entry.</li>
<li>Identify each of the certificate chains and determine whether
any of the certificate chains are trusted. At least one of the
certificate chains must be trusted.</li>
</ol>
<p>The loop setup is the following:</p>
<pre class="codeblock">
    Enumeration e = entriesVec.elements();
    while (e.hasMoreElements()) {
        JarEntry je = (JarEntry) e.nextElement();
        ...
    } 
</pre>
<h4><a name="GetSignerCerts" id="GetSignerCerts">Getting the List
of Certificates</a></h4>
<p>The certificates for the signers of a JAR file entry
<code>JarEntry</code> can be obtained simply by calling the
<code>JarEntry</code> <code>getCertificates</code> method:</p>
<pre class="codeblock">
    Certificate[] certs = je.getCertificates();
</pre>
<p>Adding this line of code to the previous loop setup code, and
adding code to ignore directories and files in the META-INF
directory gives us:</p>
<pre class="codeblock">
    while (e.hasMoreElements()) {
        JarEntry je = (JarEntry) e.nextElement();

        // Every file must be signed except files in META-INF.
        Certificate[] certs = je.getCertificates();
        if ((certs == null) || (certs.length == 0)) {
            if (!je.getName().startsWith("META-INF"))
                throw new SecurityException(
                    "The provider has unsigned class files.");
            } else {
                // Check whether the file is signed by the expected
                // signer. The jar may be signed by multiple signers.
                // See if one of the signers is 'targetCert'.
                ...
            }
        ...  
</pre>
<h4><a name="ChainRoots" id="ChainRoots">Identifying Each of the
Signers and Determining If One is Trusted</a></h4>
<p>The certificate array returned by the <code>JarEntry</code>
<code>getCertificates</code> method contains one or more
<b>certificate chains</b>. There is one chain per signer of the
entry. Each chain contains one or more certificates. Each
certificate in a chain authenticates the public key in the previous
certificate.</p>
<p>The first certificate in a chain is the signer's certificate
which contains the public key corresponding to the private key
actually used to sign the entry. Each subsequent certificate is a
certificate for the issuer of the previous certificate. Since the
self-integrity check is based on whether the JAR file is signed
with the provider's signing cert, the trust decision will be made
upon only the first certificate, the signer's certificate.</p>
<p>We need to go through the array of certificate chains and check
each chain and the associated signers until we find a
<em>trusted</em> entity. For each JAR file entry, at least one of
the signers must be trusted. A signer is considered "trusted" if
and only if its certificate is equals to the embedded provider
signing certificate.</p>
<p>The following sample code loops through all the certificate
chains, compares the first certificate in a chain to the embedded
provider signing certificate, and only returns <code>true</code> if
a match is found.</p>
<pre class="codeblock">
    int startIndex = 0;
    X509Certificate[] certChain;
    boolean signedAsExpected = false;

    while ((certChain = getAChain(certs, startIndex)) != null) {
        if (certChain[0].equals(targetCert)) {
            // Stop since one trusted signer is found.
            signedAsExpected = true;
            break;
        }

        // Proceed to the next chain.
        startIndex += certChain.length;
    }

    if (!signedAsExpected) {
        throw new SecurityException(
            "The provider is not signed by a trusted signer");
    }
    
</pre>
<p>The <code>getAChain</code> method is defined as follows:</p>
<pre class="codeblock">
    /**
     * Extracts ONE certificate chain from the specified certificate array
     * which may contain multiple certificate chains, starting from index
     * 'startIndex'.
     */
    private static X509Certificate[] getAChain(
            Certificate[] certs, int startIndex) {

        if (startIndex &gt; certs.length - 1)
            return null;

        int i;
        // Keep going until the next certificate is not the
        // issuer of this certificate.
        for (i = startIndex; i &lt; certs.length - 1; i++) {
            if (!((X509Certificate)certs[i + 1]).getSubjectDN().
                    equals(((X509Certificate)certs[i]).getIssuerDN())) {
                break;
            }
        }

        // Construct and return the found certificate chain.
        int certChainSize = (i-startIndex) + 1;
        X509Certificate[] ret = new X509Certificate[certChainSize];
        for (int j = 0; j &lt; certChainSize; j++ ) {
            ret[j] = (X509Certificate) certs[startIndex + j];
        }
        return ret;
    }
    
</pre>
<a name="myJCECodeNotes" id="myJCECodeNotes"></a>
<h2>Notes on the <i>myJCE</i> Code Sample</h2>
<p>The sample code, <a href=
"MyJCE.java"><code><i>MyJCE.java</i></code></a>, is a sample
provider which has a method <code>selfIntegrityChecking</code>
which performs self-integrity checking. It first determines the URL
of its own provider JAR file and then verifies that the provider
JAR file is signed with the embedded code-signing certificate.</p>
<p><b>Note:</b> The method <code>selfIntegrityChecking</code>
should be called by all the constructors of its cryptographic
engine classes to ensure that its integrity is not compromised.</p>
<p>Provider <code>MyJCE</code> performs self-integrity checking in
the following steps:</p>
<ol>
<li>Determine the URL to access the provider JAR file using its own
class, <code>MyJCE.class</code>.</li>
<li>Instantiate a <code>JarVerifier</code> object with the provider
URL in Step 1.</li>
<li>Create a <code>X509Certificate</code> object from the embedded
byte array <code>bytesOfProviderCert</code>.</li>
<li>Call the <code>JarVerifier.verify</code> method to verify all
entries in the provider JAR file are signed and are signed with the
same certificate instantiated in Step 3.</li>
</ol>
<p><b>Note:</b> The class <code>JarVerifier</code> will retrieve
the JAR file from the given URL, make sure the JAR file is signed,
all entries have valid signatures, and that entries are signed with
the specified <code>X509Certificate</code>.</p>
<p>A security exception is thrown by
<code>JarVerifier.verify</code> in several cases:</p>
<ul>
<li>The certificate passed to <code>verify</code> is null
(invalid).</li>
<li>When unable to retrieve JAR file from the given URL.</li>
<li>The provider is not signed. (The jar has no manifest.)</li>
<li>The provider has unsigned class files.</li>
<li>The provider is not signed with the specified certificate.</li>
</ul>
<p>The <a href="MyJCE.java"><code>MyJCE.java</code></a> sample code
is comprised of the code snippets shown above. In addition, it
includes error handling, sample code signing certificate bytes, and
code for instantiating a <code>X509Certificate</code> object from
the embedded sample code signing certificate bytes.</p>
<p>Regarding the use of <code>AccessController.doPrivileged</code>,
please see <a href="../doprivileged.html">API For Privileged
Blocks</a> for information on the use of
<code>doPrivileged</code>.</p>
<!-- ****** end 33 ***** -->
<!-- ******************************************* -->
<!-- ****** delete some stuff below ***** -->
<h2><a name="FurtherImplDetails" id="FurtherImplDetails">Further
Implementation Details and Requirements</a></h2>
<!-- -->
<!--

  <h2 class="toc"><a name="AlgAliases">Algorithm Aliases</a></h2>


-->
<h2><a name="Aliases" id="Aliases">Alias Names</a></h2>
<p>For many cryptographic algorithms and types, there is a single
official "standard name" defined in <a href=
"CryptoSpec.html#AppA">Appendix A</a> of the <i>Java Cryptography
Architecture Reference Guide</i>.</p>
<p>For example, "MD5" is the standard name for the RSA-MD5 Message
Digest algorithm defined by RSA DSI in RFC 1321.
<code>DiffieHellman</code> is the standard for the Diffie-Hellman
key agreement algorithm defined in PKCS3.</p>
<p>In the JDK, there is an aliasing scheme that enables clients to
use aliases when referring to algorithms or types, rather than
their standard names. For example, the "SUN" provider's master
class (<code>Sun.java</code>) defines the alias "SHA1/DSA" for the
algorithm whose standard name is "SHA1withDSA". Thus, the following
statements are equivalent:</p>
<pre class="codeblock">
    Signature sig = Signature.getInstance("SHA1withDSA", "SUN");

    Signature sig = Signature.getInstance("SHA1/DSA", "SUN");
</pre>
<p>Aliases can be defined in your "master class" (see <a href=
"#Step3">Step 3</a>). To define an alias, create a property
named</p>
<pre class="codeblock">
    <code>Alg.Alias.</code><i>engineClassName.aliasName</i>
</pre>
<p>where <i>engineClassName</i> is the name of an engine class
(e.g., <code>Signature</code>), and <i>aliasName</i> is your alias
name. The <i>value</i> of the property must be the standard
algorithm (or type) name for the algorithm (or type) being
aliased.</p>
<p>As an example, the "SUN" provider defines the alias "SHA1/DSA"
for the signature algorithm whose standard name is "SHA1withDSA" by
setting a property named <code>Alg.Alias.Signature.SHA1/DSA</code>
to have the value <code>SHA1withDSA</code> via the following:</p>
<pre class="codeblock">
    put("Alg.Alias.Signature.SHA1/DSA", "SHA1withDSA");
</pre>
<!-- ****** start 35 ***** -->
<p>Note that aliases defined by one provider are available only to
that provider and not to any other providers. Thus, aliases defined
by the <i>SunJCE</i> provider are available only to the
<i>SunJCE</i> provider.<br /></p>
<!-- ****** end 35 ***** -->
<h2><a name="AlgDependencies" id="AlgDependencies">Service
Interdependencies</a></h2>
<!-- ****** start 36 ***** -->
<p>Some algorithms require the use of other types of algorithms.
For example, a PBE algorithm usually needs to use a message digest
algorithm in order to transform a password into a key.</p>
<p>If you are implementing one type of algorithm that requires
another, you can do one of the following:</p>
<ol>
<li>Provide your own implementations for both.</li>
<li>Let your implementation of one algorithm use an instance of the
other type of algorithm, as supplied by the default <i>Sun</i>
provider that is included with every Java SE Platform installation.
For example, if you are implementing a PBE algorithm that requires
a message digest algorithm, you can obtain an instance of a class
implementing the MD5 message digest algorithm by calling
<pre class="codeblock">
    MessageDigest.getInstance("MD5", "SUN")<br />
</pre></li>
<li>Let your implementation of one algorithm use an instance of the
other type of algorithm, as supplied by another specific provider.
This is only appropriate if you are sure that all clients who will
use your provider will also have the other provider installed.</li>
<li>Let your implementation of one algorithm use an instance of the
other type of algorithm, as supplied by another (unspecified)
provider. That is, you can request an algorithm by name, but
without specifying any particular provider, as in
<pre class="codeblock">
    MessageDigest.getInstance("MD5")<br />
</pre>
This is only appropriate if you are sure that there will be at
least one implementation of the requested algorithm (in this case,
MD5) installed on each Java platform where your provider will be
used.</li>
</ol>
<!-- ***
  Insert Signature and Message Digest Algorithms' to xxxx -->
<p>Here are some common types of algorithm interdependencies:</p>
<h3>Signature and Message Digest Algorithms</h3>
<p>A signature algorithm often requires use of a message digest
algorithm. For example, the <i>SHA1withDSA</i> signature algorithm
requires the <i>SHA-1</i> message digest algorithm.</p>
<h3>Signature and (Pseudo-)Random Number Generation Algorithms</h3>
<p>A signature algorithm often requires use of a (pseudo-)random
number generation algorithm. For example, such an algorithm is
required in order to generate a DSA signature.</p>
<h3>Key Pair Generation and Message Digest Algorithms</h3>
<p>A key pair generation algorithm often requires use of a message
digest algorithm. For example, DSA keys are generated using the
SHA-1 message digest algorithm.</p>
<h3>Algorithm Parameter Generation and Message Digest
Algorithms</h3>
<p>An algorithm parameter generator often requires use of a message
digest algorithm. For example, DSA parameters are generated using
the SHA-1 message digest algorithm.</p>
<h3>KeyStores and Message Digest Algorithms</h3>
<p>A keystore implementation will often utilize a message digest
algorithm to compute keyed hashes (where the <code>key</code> is a
user-provided password) to check the integrity of a keystore and
make sure that the keystore has not been tampered with.</p>
<h3>Key Pair Generation Algorithms and Algorithm Parameter
Generators</h3>
<p>A key pair generation algorithm sometimes needs to generate a
new set of algorithm parameters. It can either generate the
parameters directly, or use an algorithm parameter generator.</p>
<h3>Key Pair Generation, Algorithm Parameter Generation, and
(Pseudo-)Random Number Generation Algorithms</h3>
<p>A key pair generation algorithm may require a source of
randomness in order to generate a new key pair and possibly a new
set of parameters associated with the keys. That source of
randomness is represented by a <code>SecureRandom</code> object.
The implementation of the key pair generation algorithm may
generate the key parameters itself, or may use an algorithm
parameter generator to generate them, in which case it may or may
not initialize the algorithm parameter generator with a source of
randomness.</p>
<h3>Algorithm Parameter Generators and Algorithm Parameters</h3>
<p>An algorithm parameter generator's
<code>engineGenerateParameters</code> method must return an
<code>AlgorithmParameters</code> instance.</p>
<h3>Signature and Key Pair Generation Algorithms or Key
Factories</h3>
<p>If you are implementing a signature algorithm, your
implementation's <code>engineInitSign</code> and
<code>engineInitVerify</code> methods will require passed-in keys
that are valid for the underlying algorithm (e.g., DSA keys for the
DSS algorithm). You can do one of the following:</p>
<ol>
<li>Also create your own classes implementing appropriate
interfaces (e.g. classes implementing the
<code>DSAPrivateKey</code> and <code>DSAPublicKey</code> interfaces
from the package <code>java.security.interfaces</code>), and create
your own key pair generator and/or key factory returning keys of
those types. Require the keys passed to <code>engineInitSign</code>
and <code>engineInitVerify</code> to be the types of keys you have
implemented, that is, keys generated from your key pair generator
or key factory. Or you can,</li>
<li>Accept keys from other key pair generators or other key
factories, as long as they are instances of appropriate interfaces
that enable your signature implementation to obtain the information
it needs (such as the private and public keys and the key
parameters). For example, the <code>engineInitSign</code> method
for a DSS Signature class could accept any private keys that are
instances of
<code>java.security.interfaces.DSAPrivateKey</code>.</li>
</ol>
<h3>KeyStores and Key and Certificate Factories</h3>
<p>A keystore implementation will often utilize a key factory to
parse the keys stored in the keystore, and a certificate factory to
parse the certificates stored in the keystore.</p>
<h2><a name="DefaultInits" id="DefaultInits">Default
Initializations</a></h2>
<p>In case the client does not explicitly initialize a key pair
generator or an algorithm parameter generator, each provider of
such a service must supply (and document) a default initialization.
For example, the <i>Sun</i> provider uses a default modulus size
(strength) of 1024 bits for the generation of DSA parameters, and
the "SunJCE" provider uses a default modulus size (keysize) of 1024
bits for the generation of Diffie-Hellman parameters.</p>
<h2><a name="DefaultKPGParms" id="DefaultKPGParms">Default Key Pair
Generator Parameter Requirements</a></h2>
<p>If you implement a key pair generator, your implementation
should supply default parameters that are used when clients don't
specify parameters. The documentation you supply (<a href=
"#Step11">Step 11</a>) should state what the default parameters
are.</p>
<p>For example, the DSA key pair generator in the <i>Sun</i>
provider supplies a set of pre-computed <code>p</code>,
<code>q</code>, and <code>g</code> default values for the
generation of 512, 768, and 1024-bit key pairs. The following
<code>p</code>, <code>q</code>, and <code>g</code> values are used
as the default values for the generation of 1024-bit DSA key
pairs:</p>
<pre class="codeblock">
p = fd7f5381 1d751229 52df4a9c 2eece4e7 f611b752 3cef4400 c31e3f80
    b6512669 455d4022 51fb593d 8d58fabf c5f5ba30 f6cb9b55 6cd7813b
    801d346f f26660b7 6b9950a5 a49f9fe8 047b1022 c24fbba9 d7feb7c6
    1bf83b57 e7c6a8a6 150f04fb 83f6d3c5 1ec30235 54135a16 9132f675
    f3ae2b61 d72aeff2 2203199d d14801c7

q = 9760508f 15230bcc b292b982 a2eb840b f0581cf5

g = f7e1a085 d69b3dde cbbcab5c 36b857b9 7994afbb fa3aea82 f9574c0b
    3d078267 5159578e bad4594f e6710710 8180b449 167123e8 4c281613
    b7cf0932 8cc8a6e1 3c167a8b 547c8d28 e0a3ae1e 2bb3a675 916ea37f
    0bfa2135 62f1fb62 7a01243b cca4f1be a8519089 a883dfe1 5ae59f06
    928b665e 807b5525 64014c3b fecf492a
</pre>
<p>(The <code>p</code> and <code>q</code> values given here were
generated by the prime generation standard, using the 160-bit</p>
<pre class="codeblock">
SEED:  8d515589 4229d5e6 89ee01e6 018a237e 2cae64cd
</pre>
<p>With this seed, the algorithm found <code>p</code> and
<code>q</code> when the counter was at 92.)</p>
<a name="ProviderService" id="ProviderService"></a>
<h2>The <code>Provider.Service</code> Class</h2>
<p>Since its introduction, security providers have published their
service information via appropriately formatted key-value String
pairs they put in their Hashtable entries. While this mechanism is
simple and convenient, it limits the amount customization possible.
As a result, JDK 5.0 introduced a second option, the
<code>Provider.Service</code> class. It offers an alternative way
for providers to advertise their services and supports additional
features as described below. Note that this addition is fully
compatible with the older method of using String valued Hashtable
entries. A provider on JDK 5.0 can choose either method as it
prefers, or even use both at the same time.</p>
<p>A <code>Provider.Service</code> object encapsulates all
information about a service. This is the provider that offers the
service, its type (e.g. <code>MessageDigest</code> or
<code>Signature</code>), the algorithm name, and the name of the
class that implements the service. Optionally, it also includes a
list of alternate algorithm names for this service (aliases) and
attributes, which are a map of (name, value) String pairs. In
addition, it defines the methods <code>newInstance()</code> and
<code>supportsParameter()</code>. They have default
implementations, but can be overridden by providers if needed, as
may be the case with providers that interface with hardware
security tokens.</p>
<p>The <code>newInstance()</code> method is used by the security
framework when it needs to construct new implementation instances.
The default implementation uses reflection to invoke the standard
constructor for the respective type of service. For all standard
services except <code>CertStore</code>, this is the no-args
constructor. The <tt>constructorParameter</tt> to
<code>newInstance()</code> must be null in theses cases. For
services of type <code>CertStore</code>, the constructor that takes
a <code>CertStoreParameters</code> object is invoked, and
<tt>constructorParameter</tt> must be a non-null instance of
<code>CertStoreParameters.</code> A security provider can override
the <code>newInstance()</code> method to implement instantiation as
appropriate for that implementation. It could use direct invocation
or call a constructor that passes additional information specific
to the Provider instance or token. For example, if multiple
Smartcard readers are present on the system, it might pass
information about which reader the newly created service is to be
associated with. However, despite customization all implementations
must follow the conventions about <tt>constructorParameter</tt>
described above.</p>
<p>The <code>supportsParameter()</code> tests whether the Service
can use the specified parameter. It returns false if this service
cannot use the parameter. It returns true if this service can use
the parameter, if a fast test is infeasible, or if the status is
unknown. It is used by the security framework with some types of
services to quickly exclude non-matching implementations from
consideration. It is currently only defined for the following
standard services: <code>Signature</code>, <code>Cipher</code>,
<code>Mac</code>, and <code>KeyAgreement</code>. The
<tt>parameter</tt> must be an instance of <tt>Key</tt> in these
cases. For example, for <code>Signature</code> services, the
framework tests whether the service can use the supplied Key before
instantiating the service. The default implementation examines the
attributes <code>SupportedKeyFormats</code> and
<code>SupportedKeyClasses</code> as described below. Again, a
provider may override this methods to implement additional
tests.</p>
<p>The <code>SupportedKeyFormats</code> attribute is a list of the
supported formats for encoded keys (as returned by
<tt>key.getFormat()</tt>) separated by the "|" (pipe) character.
For example, <code>X.509|PKCS#8</code>. The
<code>SupportedKeyClasses</code> attribute is a list of the names
of classes of interfaces separated by the "|" character. A key
object is considered to be acceptable if it is assignable to at
least one of those classes or interfaces named. In other words, if
the class of the key object is a subclass of one of the listed
classes (or the class itself) or if it implements the listed
interface. An example value is
<code>"java.security.interfaces.RSAPrivateKey|java.security.interfaces.RSAPublicKey"</code>
.</p>
<p>Four methods have been added to the Provider class for adding
and looking up Services. As mentioned earlier, the implementation
of those methods and also of the existing Properties methods have
been specifically designed to ensure compatibility with existing
Provider subclasses. This is achieved as follows:</p>
<p>If legacy Properties methods are used to add entries, the
Provider class makes sure that the property strings are parsed into
equivalent Service objects prior to lookup via
<tt>getService()</tt>. Similarly, if the <tt>putService()</tt>
method is used, equivalent property strings are placed into the
provider's hashtable at the same time. If a provider implementation
overrides any of the methods in the Provider class, it has to
ensure that its implementation does not interfere with this
conversion. To avoid problems, we recommend that implementations do
not override any of the methods in the <code>Provider</code>
class.</p>
<h2><a name="SigFormats" id="SigFormats">Signature Formats</a></h2>
<p>If you implement a signature algorithm, the documentation you
supply (<a href="#Step11">Step 11</a>) should specify the format in
which the signature (generated by one of the <code>sign</code>
methods) is encoded.</p>
<p>For example, the <i>SHA1withDSA</i> signature algorithm supplied
by the <i>Sun</i> provider encodes the signature as a standard
ASN.1 sequence of two <code>ASN.1 INTEGER</code> values:
<code>r</code> and <code>s</code>, in that order:</p>
<pre class="codeblock">
SEQUENCE ::= {
        r INTEGER,
        s INTEGER }
</pre>
<h2><a name="DSAInts" id="DSAInts">DSA Interfaces and their
Required Implementations</a></h2>
<p>The Java Security API contains the following interfaces (in the
<code>java.security.interfaces</code> package) for the convenience
of programmers implementing DSA services:</p>
<ul>
<li><a href=
"../../../../api/java/security/interfaces/DSAKey.html">DSAKey</a></li>
<li><a href=
"../../../../api/java/security/interfaces/DSAKeyPairGenerator.html">
DSAKeyPairGenerator</a></li>
<li><a href=
"../../../../api/java/security/interfaces/DSAParams.html">DSAParams</a></li>
<li><a href=
"../../../../api/java/security/interfaces/DSAPrivateKey.html">DSAPrivateKey</a></li>
<li><a href=
"../../../../api/java/security/interfaces/DSAPublicKey.html">DSAPublicKey</a></li>
</ul>
<p>The following sections discuss requirements for implementations
of these interfaces.</p>

<h2><a name="DSAKeyPairGenerator" id=
"DSAKeyPairGenerator"></a><code>DSAKeyPairGenerator</code></h2>

<p>The interface <a href=
"../../../../api/java/security/interfaces/DSAKeyPairGenerator.html"><code>DSAKeyPairGenerator</code></a> is obsolete. It used to be needed to enable
clients to provide DSA-specific parameters to be used rather than
the default parameters your implementation supplies. However, in
Java it is no longer necessary; a new <code>KeyPairGenerator</code>
<code>initialize</code> method that takes an
<code>AlgorithmParameterSpec</code> parameter enables clients to
indicate algorithm-specific parameters.</p>

<h3><a name="DSAParams" id="DSAParams"></a><code>DSAParams</code>
Implementation</h3>

<p>If you are implementing a DSA key pair generator, you need a
class implementing <a href=
"../../../../api/java/security/interfaces/DSAParams.html"><code>DSAParams</code></a> for holding and returning
the <code>p</code>, <code>q</code>, and <code>g</code>
parameters.</p>
<p>A <code>DSAParams</code> implementation is also required if you
implement the <code>DSAPrivateKey</code> and
<code>DSAPublicKey</code> interfaces. <code>DSAPublicKey</code> and
<code>DSAPrivateKey</code> both extend the DSAKey interface, which
contains a <code>getParams</code> method that must return a
<code>DSAParams</code> object. See <a href=
"#DSAPrivAndPubKeys">DSAPrivateKey and DSAPublicKey
Implementations</a> for more information.</p>
<p><b>Note:</b> there is a <code>DSAParams</code> implementation
built into the JDK: the
<code>java.security.spec.DSAParameterSpec</code> class.</p>

<h4><a name="DSAPrivAndPubKeys" id="DSAPrivAndPubKeys"></a><code>DSAPrivateKey</code>
and <code>DSAPublicKey</code>
Implementations</h4>

<p>If you implement a DSA key pair generator or key factory, you
need to create classes implementing the <a href=
"../../../../api/java/security/interfaces/DSAPrivateKey.html"><code>DSAPrivateKey</code></a>
and <a href=
"../../../../api/java/security/interfaces/DSAPublicKey.html"><code>DSAPublicKey</code></a> interfaces.</p>
<p>If you implement a DSA key pair generator, your
<code>generateKeyPair</code> method (in your
<code>KeyPairGeneratorSpi</code> subclass) will return instances of
your implementations of those interfaces.</p>
<p>If you implement a DSA key factory, your
<code>engineGeneratePrivate</code> method (in your
<code>KeyFactorySpi</code> subclass) will return an instance of
your <code>DSAPrivateKey</code> implementation, and your
<code>engineGeneratePublic</code> method will return an instance of
your <code>DSAPublicKey</code> implementation.</p>
<p>Also, your <code>engineGetKeySpec</code> and
<code>engineTranslateKey</code> methods will expect the passed-in
key to be an instance of a <code>DSAPrivateKey</code> or
<code>DSAPublicKey</code> implementation. The
<code>getParams</code> method provided by the interface
implementations is useful for obtaining and extracting the
parameters from the keys and then using the parameters, for example
as parameters to the <code>DSAParameterSpec</code> constructor
called to create a parameter specification from parameter values
that could be used to initialize a <code>KeyPairGenerator</code>
object for DSA.</p>
<p>If you implement a DSA signature algorithm, your
<code>engineInitSign</code> method (in your
<code>SignatureSpi</code> subclass) will expect to be passed a
<code>DSAPrivateKey</code> and your <code>engineInitVerify</code>
method will expect to be passed a <code>DSAPublicKey</code>.</p>
<p>Please note: The <code>DSAPublicKey</code> and
<code>DSAPrivateKey</code> interfaces define a very generic,
provider-independent interface to DSA public and private keys,
respectively. The <code>engineGetKeySpec</code> and
<code>engineTranslateKey</code> methods (in your
<code>KeyFactorySpi</code> subclass) could additionally check if
the passed-in key is actually an instance of their provider's own
implementation of <code>DSAPrivateKey</code> or
<code>DSAPublicKey</code>, e.g., to take advantage of
provider-specific implementation details. The same is true for the
DSA signature algorithm <code>engineInitSign</code> and
<code>engineInitVerify</code> methods (in your
<code>SignatureSpi</code> subclass).</p>
<p>To see what methods need to be implemented by classes that
implement the <code>DSAPublicKey</code> and
<code>DSAPrivateKey</code> interfaces, first note the following
interface signatures:</p>
<p>In the <code>java.security.interfaces</code> package:</p>
<pre class="codeblock">
   public interface DSAPrivateKey extends DSAKey,
                java.security.PrivateKey

   public interface DSAPublicKey extends DSAKey,
                java.security.PublicKey

   public interface DSAKey 
</pre>
<p>In the <code>java.security</code> package:</p>
<pre class="codeblock">
   public interface PrivateKey extends Key

   public interface PublicKey extends Key

   public interface Key extends java.io.Serializable 
</pre>
<p>In order to implement the <code>DSAPrivateKey</code> and
<code>DSAPublicKey</code> interfaces, you must implement the
methods they define as well as those defined by interfaces they
extend, directly or indirectly.</p>
<p>Thus, for private keys, you need to supply a class that
implements</p>
<ul>
<li>the <code>getX</code> method from the <a href=
"../../../../api/java/security/interfaces/DSAPrivateKey.html"><code>
DSAPrivateKey</code></a> interface.</li>
<li>the <code>getParams</code> method from the <a href=
"../../../../api/java/security/interfaces/DSAKey.html"><code>java.security.interfaces.DSAKey</code></a>
interface, since <code>DSAPrivateKey</code> extends
<code>DSAKey</code>. Note: The <code>getParams</code> method
returns a <code>DSAParams</code> object, so you must also have a
<a href="#DSAParams"><code>DSAParams</code>
implementation</a>.</li>
<li>the <code>getAlgorithm</code>, <code>getEncoded</code>, and
<code>getFormat</code> methods from the <a href=
"../../../../api/java/security/Key.html"><code>java.security.Key</code></a>
interface, since <code>DSAPrivateKey</code> extends
<code>java.security.PrivateKey</code>, and <code>PrivateKey</code>
extends <code>Key</code>.
<p>Similarly, for public DSA keys, you need to supply a class that
implements:</p>
<ul>
<li>the <code>getY</code> method from the <a href=
"../../../../api/java/security/interfaces/DSAPublicKey.html">DSAPublicKey</a>
interface.</li>
<li>the <code>getParams</code> method from the <a href=
"../../../../api/java/security/interfaces/DSAKey.html"><code>java.security.interfaces.DSAKey</code></a>
interface, since <code>DSAPublicKey</code> extends DSAKey. Note:
The <code>getParams</code> method returns a <code>DSAParams</code>
object, so you must also have a <a href=
"#DSAParams"><code>DSAParams</code> implementation</a>.</li>
<li>the <code>getAlgorithm</code>, <code>getEncoded</code>, and
<code>getFormat</code> methods from the <a href=
"../../../../api/java/security/Key.html"><code>java.security.Key</code></a>
interface, since <code>DSAPublicKey</code> extends
<code>java.security.PublicKey</code>, and <code>PublicKey</code>
extends <code>Key</code>.</li>
</ul>
</li>
</ul>
<h2><a name="RSAInts" id="RSAInts">RSA Interfaces and their
Required Implementations</a></h2>

<p>The Java Security API contains the following interfaces (in the
<code>java.security.interfaces</code> package) for the convenience
of programmers implementing RSA services:</p>
<ul>
<li><a href=
"../../../../api/java/security/interfaces/RSAPrivateKey.html">RSAPrivateKey</a></li>
<li><a href=
"../../../../api/java/security/interfaces/RSAPrivateCrtKey.html">RSAPrivateCrtKey</a></li>
<li><a href=
"../../../../api/java/security/interfaces/RSAPublicKey.html">RSAPublicKey</a></li>
</ul>
<p>The following sections discuss requirements for implementations
of these interfaces.</p>


<h3><a name="RSAPrivAndPubKeys" id="RSAPrivAndPubKeys"></a>
<code>RSAPrivateKey</code>, <code>RSAPrivateCrtKey</code>, and <code>RSAPublicKey</code> Implementations</h3>
<p>If you implement an RSA key pair generator or key factory, you
need to create classes implementing the <a href=
"../../../../api/java/security/interfaces/RSAPrivateKey.html"><code>RSAPrivateKey</code></a>
(and/or <a href=
"../../../../api/java/security/interfaces/RSAPrivateCrtKey.html"><code>
RSAPrivateCrtKey</code></a>) and
<a href=
"../../../../api/java/security/interfaces/RSAPublicKey.html"><code>RSAPublicKey</code></a> interfaces.
(<code>RSAPrivateCrtKey</code> is the interface to an RSA private
key, using the <i>Chinese Remainder Theorem</i> (CRT)
representation.)</p>
<p>If you implement an RSA key pair generator, your
<code>generateKeyPair</code> method (in your
<code>KeyPairGeneratorSpi</code> subclass) will return instances of
your implementations of those interfaces.</p>
<p>If you implement an RSA key factory, your
<code>engineGeneratePrivate</code> method (in your
<code>KeyFactorySpi</code> subclass) will return an instance of
your <code>RSAPrivateKey</code> (or <code>RSAPrivateCrtKey</code>)
implementation, and your <code>engineGeneratePublic</code> method
will return an instance of your <code>RSAPublicKey</code>
implementation.</p>
<p>Also, your <code>engineGetKeySpec</code> and
<code>engineTranslateKey</code> methods will expect the passed-in
key to be an instance of an <code>RSAPrivateKey</code>,
<code>RSAPrivateCrtKey</code>, or <code>RSAPublicKey</code>
implementation.</p>
<p>If you implement an RSA signature algorithm, your
<code>engineInitSign</code> method (in your
<code>SignatureSpi</code> subclass) will expect to be passed either
an <code>RSAPrivateKey</code> or an <code>RSAPrivateCrtKey</code>,
and your <code>engineInitVerify</code> method will expect to be
passed an <code>RSAPublicKey</code>.</p>
<p>Please note: The <code>RSAPublicKey</code>,
<code>RSAPrivateKey</code>, and <code>RSAPrivateCrtKey</code>
interfaces define a very generic, provider-independent interface to
RSA public and private keys. The <code>engineGetKeySpec</code> and
<code>engineTranslateKey</code> methods (in your
<code>KeyFactorySpi</code> subclass) could additionally check if
the passed-in key is actually an instance of their provider's own
implementation of <code>RSAPrivateKey</code>,
<code>RSAPrivateCrtKey</code>, or <code>RSAPublicKey</code>, e.g.,
to take advantage of provider-specific implementation details. The
same is true for the RSA signature algorithm
<code>engineInitSign</code> and <code>engineInitVerify</code>
methods (in your <code>SignatureSpi</code> subclass).</p>
<p>To see what methods need to be implemented by classes that
implement the <code>RSAPublicKey</code>,
<code>RSAPrivateKey</code>, and <code>RSAPrivateCrtKey</code>
interfaces, first note the following interface signatures:</p>
<p>In the <code>java.security.interfaces</code> package:</p>
<pre class="codeblock">
    public interface RSAPrivateKey extends java.security.PrivateKey

    public interface RSAPrivateCrtKey extends RSAPrivateKey

    public interface RSAPublicKey extends java.security.PublicKey

</pre>
<p>In the <code>java.security</code> package:</p>
<pre class="codeblock">
    public interface PrivateKey extends Key

    public interface PublicKey extends Key

    public interface Key extends java.io.Serializable
</pre>
<p>In order to implement the <code>RSAPrivateKey</code>,
<code>RSAPrivateCrtKey</code>, and <code>RSAPublicKey</code>
interfaces, you must implement the methods they define as well as
those defined by interfaces they extend, directly or
indirectly.</p>
<p>Thus, for RSA private keys, you need to supply a class that
implements:</p>
<ul>
<li>the <code>getModulus</code> and <code>getPrivateExponent</code>
methods from the <a href=
"../../../../api/java/security/interfaces/RSAPrivateKey.html"><code>
RSAPrivateKey</code></a> interface.</li>
<li>the <code>getAlgorithm</code>, <code>getEncoded</code>, and
<code>getFormat</code> methods from the <a href=
"../../../../api/java/security/Key.html">java.security.Key</a>
interface, since <code>RSAPrivateKey</code> extends
<code>java.security.PrivateKey</code>, and <code>PrivateKey</code>
extends <code>Key</code>.</li>
</ul>
<p>Similarly, for RSA private keys using the <i>Chinese Remainder
Theorem</i> (CRT) representation, you need to supply a class that
implements:</p>
<ul>
<li>all the methods listed above for RSA private keys, since
<code>RSAPrivateCrtKey</code> extends
<code>java.security.interfaces.RSAPrivateKey</code>.</li>
<li>the <code>getPublicExponent</code>, <code>getPrimeP</code>,
<code>getPrimeQ</code>, <code>getPrimeExponentP</code>,
<code>getPrimeExponentQ</code>, and <code>getCrtCoefficient</code>
methods from the <a href=
"../../../../api/java/security/interfaces/RSAPrivateCrtKey.html"><code>
RSAPrivateKey</code></a> interface.</li>
</ul>
<p>For public RSA keys, you need to supply a class that
implements:</p>
<ul>
<li>the <code>getModulus</code> and <code>getPublicExponent</code>
methods from the <a href=
"../../../../api/java/security/interfaces/RSAPublicKey.html"><code>RSAPublicKey</code></a>
interface.</li>
<li>the <code>getAlgorithm</code>, <code>getEncoded</code>, and
<code>getFormat</code> methods from the <a href=
"../../../../api/java/security/Key.html">java.security.Key</a>
interface, since <code>RSAPublicKey</code> extends
<code>java.security.PublicKey</code>, and <code>PublicKey</code>
extends <code>Key</code>.</li>
</ul>
<!-- ********** end 36 insert ********* -->
<!-- ****  tag says insert 37a here??  **** -->
<p>JCA contains a number of <code>AlgorithmParameterSpec</code>
implementations for the most frequently used cipher and key
agreement algorithm parameters. If you are operating on algorithm
parameters that should be for a different type of algorithm not
provided by JCA, you will need to supply your own
<code>AlgorithmParameterSpec</code> implementation appropriate for
that type of algorithm.</p>
<!-- continue 36 insert here at

"Interfaces for other alg. types"  is the next heading after the Diffie
Hellman insert


  ***** -->
<!-- Insert 37 here (Diffie-Hellman heading) ****-->

<h2><a name="DHInts" id="DHInts">Diffie-Hellman Interfaces and
their Required Implementations</a></h2>
<p>JCA contains the following interfaces (in the
<code>javax.crypto.interfaces</code> package) for the convenience
of programmers implementing Diffie-Hellman services:</p>
<ul>
<li><a href=
"../../../../api/javax/crypto/interfaces/DHKey.html"><code>DHKey</code></a></li>
<li><a href=
"../../../../api/javax/crypto/interfaces/DHPrivateKey.html"><code>DHPrivateKey</code></a></li>
<li><a href=
"../../../../api/javax/crypto/interfaces/DHPublicKey.html"><code>DHPublicKey</code></a></li>
</ul>
<p>The following sections discuss requirements for implementations
of these interfaces.</p>

<h3><a name="DHPrivAndPubKeys" id="DHPrivAndPubKeys"></a> <code>DHPrivateKey</code>
and <code>DHPublicKey</code> Implementations</h3>
<p>If you implement a Diffie-Hellman key pair generator or key
factory, you need to create classes implementing the
<a href=
"../../../../api/javax/crypto/interfaces/DHPrivateKey.html"><code>DHPrivateKey</code></a> and <a href=
"../../../../api/javax/crypto/interfaces/DHPublicKey.html"><code>DHPublicKey</code></a>
interfaces.</p>
<p>If you implement a Diffie-Hellman key pair generator, your
<code>generateKeyPair</code> method (in your
<code>KeyPairGeneratorSpi</code> subclass) will return instances of
your implementations of those interfaces.</p>
<p>If you implement a Diffie-Hellman key factory, your
<code>engineGeneratePrivate</code> method (in your
<code>KeyFactorySpi</code> subclass) will return an instance of
your <code>DHPrivateKey</code> implementation, and your
<code>engineGeneratePublic</code> method will return an instance of
your <code>DHPublicKey</code> implementation.</p>
<p>Also, your <code>engineGetKeySpec</code> and
<code>engineTranslateKey</code> methods will expect the passed-in
key to be an instance of a <code>DHPrivateKey</code> or
<code>DHPublicKey</code> implementation. The <code>getParams</code>
method provided by the interface implementations is useful for
obtaining and extracting the parameters from the keys. You can then
use the parameters, for example, as parameters to the
<code>DHParameterSpec</code> constructor called to create a
parameter specification from parameter values used to initialize a
<code>KeyPairGenerator</code> object for Diffie-Hellman.</p>
<p>If you implement the Diffie-Hellman key agreement algorithm,
your <code>engineInit</code> method (in your
<code>KeyAgreementSpi</code> subclass) will expect to be passed a
<code>DHPrivateKey</code> and your <code>engineDoPhase</code>
method will expect to be passed a <code>DHPublicKey</code>.</p>
<p><b>Note:</b> The <code>DHPublicKey</code> and
<code>DHPrivateKey</code> interfaces define a very generic,
provider-independent interface to Diffie-Hellman public and private
keys, respectively. The <code>engineGetKeySpec</code> and
<code>engineTranslateKey</code> methods (in your
<code>KeyFactorySpi</code> subclass) could additionally check if
the passed-in key is actually an instance of their provider's own
implementation of <code>DHPrivateKey</code> or
<code>DHPublicKey</code>, e.g., to take advantage of
provider-specific implementation details. The same is true for the
Diffie-Hellman algorithm <code>engineInit</code> and
<code>engineDoPhase</code> methods (in your
<code>KeyAgreementSpi</code> subclass).</p>
<p>To see what methods need to be implemented by classes that
implement the <code>DHPublicKey</code> and
<code>DHPrivateKey</code> interfaces, first note the following
interface signatures:</p>
<p>In the <code>javax.crypto.interfaces</code> package:</p>
<pre class="codeblock">
    public interface DHPrivateKey extends DHKey, java.security.PrivateKey

    public interface DHPublicKey extends DHKey, java.security.PublicKey

    public interface DHKey 
</pre>
<p>In the <code>java.security</code> package:</p>
<pre class="codeblock">
    public interface PrivateKey extends Key

    public interface PublicKey extends Key

    public interface Key extends java.io.Serializable 
</pre>
<p>To implement the <code>DHPrivateKey</code> and
<code>DHPublicKey</code> interfaces, you must implement the methods
they define as well as those defined by interfaces they extend,
directly or indirectly.</p>
<p>Thus, for private keys, you need to supply a class that
implements:</p>
<ul>
<li>the <code>getX</code> method from the <a href=
"../../../../api/javax/crypto/interfaces/DHPrivateKey.html"><code>DHPrivateKey</code></a>
interface.</li>
<li>the <code>getParams</code> method from the <a href=
"../../../../api/javax/crypto/interfaces/DHKey.html">javax.crypto.interfaces.DHKey</a>
interface, since <code>DHPrivateKey</code> extends
<code>DHKey</code>.</li>
<li>the <code>getAlgorithm</code>, <code>getEncoded</code>, and
<code>getFormat</code> methods from the <a href=
"../../../../api/java/security/Key.html">java.security.Key</a>
interface, since <code>DHPrivateKey</code> extends
<code>java.security.PrivateKey</code>, and <code>PrivateKey</code>
extends <code>Key</code>.</li>
</ul>
<p>Similarly, for public Diffie-Hellman keys, you need to supply a
class that implements:</p>
<ul>
<li>the <code>getY</code> method from the <a href=
"../../../../api/javax/crypto/interfaces/DHPublicKey.html"><code>DHPublicKey</code></a>
interface.</li>
<li>the <code>getParams</code> method from the <a href=
"../../../../api/javax/crypto/interfaces/DHKey.html"><code>javax.crypto.interfaces.DHKey</code></a>
interface, since <code>DHPublicKey</code> extends
<code>DHKey</code>.</li>
<li>the <code>getAlgorithm</code>, <code>getEncoded</code>, and
<code>getFormat</code> methods from the <a href=
"../../../../api/java/security/Key.html">java.security.Key</a>
interface, since <code>DHPublicKey</code> extends
<code>java.security.PublicKey</code>, and <code>PublicKey</code>
extends <code>Key</code>.</li>
</ul>
<!-- ***** end 37 diffie-hellman instert *** -->
<h2><a name="NonDSAInts" id="NonDSAInts">Interfaces for Other
Algorithm Types</a></h2>
<p>As noted above, the Java Security API contains interfaces for
the convenience of programmers implementing services like DSA, RSA
and ECC. If there are services without API support, you need to
define your own APIs.</p>
<p>If you are implementing a key pair generator for a different
algorithm, you should create an interface with one or more
<code>initialize</code> methods that clients can call when they
want to provide algorithm-specific parameters to be used rather
than the default parameters your implementation supplies. Your
subclass of <code>KeyPairGeneratorSpi</code> should implement this
interface.</p>
<p>For algorithms without direct API support, it is recommended
that you create similar interfaces and provide implementation
classes. Your public key interface should extend the <a href=
"../../../../api/java/security/PublicKey.html"><code>PublicKey</code></a>
interface. Similarly, your private key interface should extend the
<a href=
"../../../../api/java/security/PrivateKey.html"><code>PrivateKey</code></a>
interface.</p>
<h2><a name="AlgParmSpecs" id="AlgParmSpecs">Algorithm Parameter
Specification Interfaces and Classes</a></h2>
<p>An algorithm parameter specification is a transparent
representation of the sets of parameters used with an
algorithm.</p>
<p>A <i>transparent</i> representation of parameters means that you
can access each value individually, through one of the <i>get</i>
methods defined in the corresponding specification class (e.g.,
<code>DSAParameterSpec</code> defines <code>getP</code>,
<code>getQ</code>, and <code>getG</code> methods, to access the p,
q, and g parameters, respectively).</p>
<p>This is contrasted with an <i>opaque</i> representation, as
supplied by the AlgorithmParameters engine class, in which you have
no direct access to the key material values; you can only get the
name of the algorithm associated with the parameter set (via
<code>getAlgorithm</code>) and some kind of encoding for the
parameter set (via <code>getEncoded</code>).</p>
<p>If you supply an <code>AlgorithmParametersSpi</code>,
<code>AlgorithmParameterGeneratorSpi</code>, or
<code>KeyPairGeneratorSpi</code> implementation, you must utilize
the <code>AlgorithmParameterSpec</code> interface, since each of
those classes contain methods that take an
<code>AlgorithmParameterSpec</code> parameter. Such methods need to
determine which actual implementation of that interface has been
passed in, and act accordingly. <!-- ***** end 36 ****** -->
 <!-- ***** start 37a alpha ?? ****** --></p>
<p>JCA contains a number of <code>AlgorithmParameterSpec</code>
implementations for the most frequently used signature, cipher and
key agreement algorithm parameters. If you are operating on
algorithm parameters that should be for a different type of
algorithm not provided by JCA, you will need to supply your own
<code>AlgorithmParameterSpec</code> implementation appropriate for
that type of algorithm.</p>
<!-- ***** end 37a ****** -->
<!-- ***** start 38 ****** -->
<p>Java defines the following algorithm parameter specification
interfaces and classes in the <code>java.security.spec</code> and
<code>javax.crypto.spec</code> packages:</p>
<h3>The <a href=
"../../../../api/java/security/spec/AlgorithmParameterSpec.html"><code>
AlgorithmParameterSpec</code></a> Interface</h3>
<p><code>AlgorithmParameterSpec</code> is an interface to a
transparent specification of cryptographic parameters.</p>
<p>This interface contains no methods or constants. Its only
purpose is to group (and provide type safety for) all parameter
specifications. All parameter specifications must implement this
interface.</p>
<h3><a name="DSAParameterSpec" id="DSAParameterSpec">The</a>
<a href=
"../../../../api/java/security/spec/DSAParameterSpec.html"><i><code>
DSAParameterSpec</code></i></a> Class</h3>
<p>This class (which implements the
<code>AlgorithmParameterSpec</code> and <code>DSAParams</code>
interfaces) specifies the set of parameters used with the DSA
algorithm. It has the following methods:</p>
<!-- ** put a lot of these callouts into tables -->
<pre class="codeblock">
    public BigInteger getP()

    public BigInteger getQ()

    public BigInteger getG()
</pre>
<p>These methods return the DSA algorithm parameters: the prime
<code>p</code>, the sub-prime <code>q</code>, and the base
<code>g</code>.</p>
<p>Many types of DSA services will find this class useful - for
example, it is utilized by the DSA signature, key pair generator,
algorithm parameter generator, and algorithm parameters classes
implemented by the <i>Sun</i> provider. As a specific example, an
algorithm parameters implementation must include an implementation
for the <code>getParameterSpec</code> method, which returns an
<code>AlgorithmParameterSpec</code>. The DSA algorithm parameters
implementation supplied by <i>Sun</i> returns an instance of the
<code>DSAParameterSpec</code> class. <!-- ***** end 38 ****** -->
<!-- ***** start 39 from jce file****** --></p>
<h3><a name="IvParameterSpec" id="IvParameterSpec">The</a> <a href=
"../../../../api/javax/crypto/spec/IvParameterSpec.html"><code>IvParameterSpec</code></a>
Class</h3>
<p>This class (which implements the
<code>AlgorithmParameterSpec</code> interface) specifies the
initialization vector (IV) used with a cipher in feedback mode.</p>
<table summary="method in IvParameterSpec" border="1">
<caption><b>Method in <code>IvParameterSpec</code></b></caption>
<thead>
<tr>
<th id="h101">Method</th>
<th id="h102">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td headers="h101"><code>byte[] getIV()</code></td>
<td headers="h102">Returns the initialization vector (IV).</td>
</tr>
</tbody>
</table>
<!-- insert new class here -->
<h3><a name="bug7" id="bug7"></a><a name="OAEPParameterSpec" id=
"OAEPParameterSpec">The</a> <a href=
"../../../../api/javax/crypto/spec/OAEPParameterSpec.html"><code>OAEPParameterSpec</code></a>
Class</h3>
<p>This class specifies the set of parameters used with OAEP
Padding, as defined in the PKCS #1 standard.</p>
<table summary="methods in OAEPParameterSpec" border="1">
<caption><b>Methods in <code>OAEPParameterSpec</code></b></caption>
<thead>
<tr>
<th id="h201">Method</th>
<th id="h202">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td headers="h201"><code>String getDigestAlgorithm()</code></td>
<td headers="h202">Returns the message digest algorithm name.</td>
</tr>
<tr>
<td headers="h201"><code>String getMGFAlgorithm()</code></td>
<td headers="h202">Returns the mask generation function algorithm name.</td>
</tr>
<tr>
<td headers="h201"><code>AlgorithmParameterSpec getMGFParameters()</code></td>
<td headers="h202">Returns the parameters for the mask generation function.</td>
</tr>
<tr>
<td headers="h201"><code>PSource getPSource()</code></td>
<td headers="h202">Returns the source of encoding input P.</td>
</tr>
</tbody>
</table>
<!-- ***** end insert new class here.  -->

<h3><a name="PBEParameterSpec" id="PBEParameterSpec">The</a>
<a href=
"../../../../api/javax/crypto/spec/PBEParameterSpec.html"><code>PBEParameterSpec</code></a>
Class</h3>
<p>This class (which implements the
<code>AlgorithmParameterSpec</code> interface) specifies the set of
parameters used with a password-based encryption (PBE)
algorithm.</p>
<table summary="methods in PBEParameterSpec" border="1">
<caption><b>Methods in <code>PBEParameterSpec</code></b></caption>
<thead>
<tr>
<th id="h301">Method</th>
<th id="h302">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td headers="h301"><code>int getIterationCount()</code></td>
<td headers="h302">Returns the iteration count.</td>
</tr>
<tr>
<td headers="h301"><code>byte[] getSalt()</code></td>
<td headers="h302">Returns the salt.</td>
</tr>
</tbody>
</table>
<h3><a name="RC2ParameterSpec" id="RC2ParameterSpec">The</a>
<a href=
"../../../../api/javax/crypto/spec/RC2ParameterSpec.html"><code>RC2ParameterSpec</code></a>
Class</h3>
<p>This class (which implements the
<code>AlgorithmParameterSpec</code> interface) specifies the set of
parameters used with the RC2 algorithm.</p>
<table summary="RC2ParameterSpec" border="1">
<caption><b>Methods in <code>RC2ParameterSpec</code></b></caption>
<thead>
<tr>
<th id="h401">Method</th>
<th id="h402">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td headers="h401"><code>boolean equals(Object obj)</code></td>
<td headers="h402">Tests for equality between the specified object and this
object.</td>
</tr>
<tr>
<td headers="h401"><code>int getEffectiveKeyBits()</code></td>
<td headers="h402">Returns the effective key size in bits.</td>
</tr>
<tr>
<td headers="h401"><code>byte[] getIV()</code></td>
<td headers="h402">Returns the IV or null if this parameter set does not contain
an IV.</td>
</tr>
<tr>
<td headers="h401"><code>int hashCode()</code></td>
<td headers="h402">Calculates a hash code value for the object.</td>
</tr>
</tbody>
</table>
<h3><a name="RC5ParameterSpec" id="RC5ParameterSpec">The</a>
<a href=
"../../../../api/javax/crypto/spec/RC5ParameterSpec.html"><code>RC5ParameterSpec</code></a>
Class</h3>
<p>This class (which implements the
<code>AlgorithmParameterSpec</code> interface) specifies the set of
parameters used with the RC5 algorithm.</p>
<table summary="methods in RC5ParameterSpec" border="1">
<caption><b>Methods in <code>RC5ParameterSpec</code></b></caption>
<thead>
<tr>
<th id="h501">Method</th>
<th id="h502">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td headers="h501"><code>boolean equals(Object obj)</code></td>
<td headers="h502">Tests for equality between the specified object and this
object.</td>
</tr>
<tr>
<td headers="h501"><code>byte[] getIV()</code></td>
<td headers="h502">Returns the IV or null if this parameter set does not contain
an IV.</td>
</tr>
<tr>
<td headers="h501"><code>int getRounds()</code></td>
<td headers="h502">Returns the number of rounds.</td>
</tr>
<tr>
<td headers="h501"><code>int getVersion()</code></td>
<td headers="h502">Returns the version.</td>
</tr>
<tr>
<td headers="h501"><code>int getWordSize()</code></td>
<td headers="h502">Returns the word size in bits.</td>
</tr>
<tr>
<td headers="h501"><code>int hashCode()</code></td>
<td headers="h502">Calculates a hash code value for the object.</td>
</tr>
</tbody>
</table>
<h3><a name="DHParameterSpec" id="DHParameterSpec">The</a> <a href=
"../../../../api/javax/crypto/spec/DHParameterSpec.html"><code>DHParameterSpec</code></a>
Class</h3>
<p>This class (which implements the
<code>AlgorithmParameterSpec</code> interface) specifies the set of
parameters used with the Diffie-Hellman algorithm.</p>
<table summary="Methods in DHParameterSpec" border="1">
<caption>Methods in <code>DHParameterSpec</code></caption>
<thead>
<tr>
<th id="h601">Method</th>
<th id="h602">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td headers="h601"><code>BigInteger getG()</code></td>
<td headers="h602">Returns the base generator <code>g</code>.</td>
</tr>
<tr>
<td headers="h601"><code>int getL()</code></td>
<td headers="h602">Returns the size in bits, <code>l</code>, of the random
exponent (private value).</td>
</tr>
<tr>
<td headers="h601"><code>BigInteger getP()</code></td>
<td headers="h602">Returns the prime modulus <code>p</code>.</td>
</tr>
</tbody>
</table>
<p>Many types of Diffie-Hellman services will find this class
useful; for example, it is used by the Diffie-Hellman key
agreement, key pair generator, algorithm parameter generator, and
algorithm parameters classes implemented by the "SunJCE" provider.
As a specific example, an algorithm parameters implementation must
include an implementation for the <code>getParameterSpec</code>
method, which returns an <code>AlgorithmParameterSpec</code>. The
Diffie-Hellman algorithm parameters implementation supplied by
"SunJCE" returns an instance of the <code>DHParameterSpec</code>
class.</p>
<!-- ***** end 39 ****** -->
<!-- ***** start 40 ****** -->
<h2><a name="KeySpecs" id="KeySpecs">Key Specification Interfaces
and Classes Required by Key Factories</a></h2>
<p>A key factory provides bi-directional conversions between opaque
keys (of type <code>Key</code>) and key specifications. If you
implement a key factory, you thus need to understand and utilize
key specifications. In some cases, you also need to implement your
own key specifications.</p>
<p>Further information about key specifications, the interfaces and
classes supplied in Java, and key factory requirements with respect
to specifications, is provided below.</p>
<p>Key specifications are transparent representations of the key
material that constitutes a key. If the key is stored on a hardware
device, its specification may contain information that helps
identify the key on the device.</p>
<p>A <i>transparent</i> representation of keys means that you can
access each key material value individually, through one of the
<i>get</i> methods defined in the corresponding specification
class. For example,
<code>java.security.spec.</code>DSAPrivateKeySpec defines
<code>getX</code>, <code>getP</code>, <code>getQ</code>, and
<code>getG</code> methods, to access the private key
<code>x</code>, and the DSA algorithm parameters used to calculate
the key: the prime <code>p</code>, the sub-prime <code>q</code>,
and the base <code>g</code>.</p>
<p>This is contrasted with an <i>opaque</i> representation, as
defined by the Key interface, in which you have no direct access to
the parameter fields. In other words, an "opaque" representation
gives you limited access to the key - just the three methods
defined by the Key interface: <code>getAlgorithm</code>,
<code>getFormat</code>, and <code>getEncoded</code>.</p>
<p>A key may be specified in an algorithm-specific way, or in an
algorithm-independent encoding format (such as ASN.1). For example,
a DSA private key may be specified by its components
<code><i>x</i></code>, <code><i>p</i></code>,
<code><i>q</i></code>, and <code><i>g</i></code> (see <a href=
"#DSAPrivateKeySpec"><code>DSAPrivateKeySpec</code></a>), or it may
be specified using its DER encoding (see <a href=
"#PKCS8EncodedKeySpec"><code>PKCS8EncodedKeySpec</code></a>).</p>
<p>Java defines the following key specification interfaces and
classes in the <code>java.security.spec</code> and
<code>javax.crypto.spec</code> packages:</p>
<h3><a name="KeySpec" id="KeySpec">The</a> <a href=
"../../../../api/java/security/spec/KeySpec.html"><code>KeySpec</code></a>
Interface</h3>
<p>This interface contains no methods or constants. Its only
purpose is to group (and provide type safety for) all key
specifications. All key specifications must implement this
interface.</p>
<p>Java supplies several classes implementing the
<code>KeySpec</code> interface: <a href=
"#DSAPrivateKeySpec"><code>DSAPrivateKeySpec</code></a>, <a href=
"#DSAPublicKeySpec"><code>DSAPublicKeySpec</code></a>, <a href=
"#RSAPrivateKeySpec"><code>RSAPrivateKeySpec</code></a>, <a href=
"#RSAPublicKeySpec"><code>RSAPublicKeySpec</code></a>, <a href=
"#EncodedKeySpec"><code>EncodedKeySpec</code></a>, <a href=
"#PKCS8EncodedKeySpec"><code>PKCS8EncodedKeySpec</code></a>, and
<a href=
"#X509EncodedKeySpec"><code>X509EncodedKeySpec</code></a>.</p>
<p>If your provider uses key types (e.g.,
<code>Your_PublicKey_type</code> and
<code>Your_PrivateKey_type</code>) for which the JDK does not
already provide corresponding <code>KeySpec</code> classes, there
are two possible scenarios, one of which requires that you
implement your own key specifications:</p>
<ol>
<li>If your users will never have to access specific key material
values of your key type, you will not have to provide any
<code>KeySpec</code> classes for your key type.<br />
<br />
In this scenario, your users will always create
<code>Your_PublicKey_type</code> and
<code>Your_PrivateKey_type</code> keys through the appropriate
<code>KeyPairGenerator</code> supplied by your provider for that
key type. If they want to store the generated keys for later usage,
they retrieve the keys' encodings (using the
<code>getEncoded</code> method of the <code>Key</code> interface).
When they want to create an <code>Your_PublicKey_type</code> or
<code>Your_PrivateKey_type</code> key from the encoding (e.g., in
order to initialize a Signature object for signing or
verification), they create an instance of
<code>X509EncodedKeySpec</code> or <code>PKCS8EncodedKeySpec</code>
from the encoding, and feed it to the appropriate
<code>KeyFactory</code> supplied by your provider for that
algorithm, whose <code>generatePublic</code> and
<code>generatePrivate</code> methods will return the requested
<code>PublicKey</code> (an instance of
<code>Your_PublicKey_type</code>) or <code>PrivateKey</code> (an
instance of <code>Your_PrivateKey_type</code>) object,
respectively.</li>
<li>If you anticipate a need for users to access specific key
material values of your key type, or to construct a key of your key
type from key material and associated parameter values, rather than
from its encoding (as in the above case), you have to specify new
<code>KeySpec</code> classes (classes that implement the
<code>KeySpec</code> interface) with the appropriate constructor
methods and <i>get</i> methods for returning key material fields
and associated parameter values for your key type. You will specify
those classes in a similar manner as is done by the
<code>DSAPrivateKeySpec</code> and <code>DSAPublicKeySpec</code>
classes. You need to ship those classes along
with your provider classes, for example, as part of your provider
JAR file.</li>
</ol>
<h3><a name="DSAPrivateKeySpec" id="DSAPrivateKeySpec">The</a>
<a href=
"../../../../api/java/security/spec/DSAPrivateKeySpec.html"><code>DSAPrivateKeySpec</code></a>
Class</h3>
<p>This class (which implements the <a href=
"#KeySpec"><code>KeySpec</code></a> Interface) specifies a DSA
private key with its associated parameters. It has the following
methods:</p>
<!-- **** start table **** -->
<table summary="method in DSAPrivateKeySpec" border="1">
<thead>
<tr>
<th id="h701">Method in <code>DSAPrivateKeySpec</code></th>
<th id="h702">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td headers="h701"><code>public BigInteger getX()</code></td>
<td headers="h702">Returns the private key x.</td>
</tr>
<tr>
<td headers="h701"><code>public BigInteger getP()</code></td>
<td headers="h702">Returns the prime p.</td>
</tr>
<tr>
<td headers="h701"><code>public BigInteger getQ()</code></td>
<td headers="h702">Returns the sub-prime q.</td>
</tr>
<tr>
<td headers="h701"><code>public BigInteger getG()</code></td>
<td headers="h702">Returns the base g.</td>
</tr>
</tbody>
</table>
<!-- **** end table **** -->
<p>These methods return the private key <code>x</code>, and the DSA
algorithm parameters used to calculate the key: the prime
<code>p</code>, the sub-prime <code>q</code>, and the base
<code>g</code>.</p>
<h3><a name="DSAPublicKeySpec" id="DSAPublicKeySpec">The</a>
<a href=
"../../../../api/java/security/spec/DSAPublicKeySpec.html">DSAPublicKeySpec</a>
Class</h3>
<p>This class (which implements the <a href=
"#KeySpec"><code>KeySpec</code></a> Interface) specifies a DSA
public key with its associated parameters. It has the following
methods:</p>
<table summary="method in DSAPublicKeySpec" border="1">
<thead>
<tr>
<th id="h801">Method in <code>DSAPublicKeySpec</code></th>
<th id="h802">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td headers="h801"><code>public BigInteger getY()</code></td>
<td headers="h802">returns the public key y.</td>
</tr>
<tr>
<td headers="h801"><code>public BigInteger getP()</code></td>
<td headers="h802">Returns the prime p.</td>
</tr>
<tr>
<td headers="h801"><code>public BigInteger getQ()</code></td>
<td headers="h802">Returns the sub-prime q.</td>
</tr>
<tr>
<td headers="h801"><code>public BigInteger getG()</code></td>
<td headers="h802">Returns the base g.</td>
</tr>
</tbody>
</table>
<p>These methods return the public key <code>y</code>, and the DSA
algorithm parameters used to calculate the key: the prime
<code>p</code>, the sub-prime <code>q</code>, and the base
<code>g</code>.</p>
<h3><a name="RSAPrivateKeySpec" id="RSAPrivateKeySpec">The</a>
<a href=
"../../../../api/java/security/spec/RSAPrivateKeySpec.html">RSAPrivateKeySpec</a>
Class</h3>
<p>This class (which implements the <a href=
"#KeySpec"><code>KeySpec</code></a> Interface) specifies an RSA
private key. It has the following methods:</p>
<table summary="methods in RSAPrivateKeySpec" border="1">
<thead>
<tr>
<th id="h901">Method in <code>RSAPrivateKeySpec</code></th>
<th id="h902">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td headers="h901"><code>public BigInteger getModulus()</code></td>
<td headers="h902">Returns the modulus.</td>
</tr>
<tr>
<td headers="h901"><code>public BigInteger getPrivateExponent()</code></td>
<td headers="h902">Returns the private exponent.</td>
</tr>
</tbody>
</table>
<p>These methods return the RSA modulus <code>n</code> and private
exponent <code>d</code> values that constitute the RSA private
key.</p>
<h3><a name="RSAPrivateCrtKeySpec" id=
"RSAPrivateCrtKeySpec">The</a> <a href=
"../../../../api/java/security/spec/RSAPrivateCrtKeySpec.html">RSAPrivateCrtKeySpec</a>
Class</h3>
<p>This class (which extends the <a href=
"#RSAPrivateKeySpec"><code>RSAPrivateKeySpec</code></a> class)
specifies an RSA private key, as defined in the PKCS#1 standard,
using the <i>Chinese Remainder Theorem</i> (CRT) information
values. It has the following methods (in addition to the methods
inherited from its superclass <code>RSAPrivateKeySpec</code> ):</p>
<table summary="method in RSAPrivateCrtKeySpec" border="1">
<thead>
<tr>
<th id="h1001">Method in <code>RSAPrivateCrtKeySpec</code></th>
<th id="h1002">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td headers="h1001"><code>public BigInteger getPublicExponent()</code></td>
<td headers="h1002">Returns the public exponent.</td>
</tr>
<tr>
<td headers="h1001"><code>public BigInteger getPrimeP()</code></td>
<td headers="h1002">Returns the prime P.</td>
</tr>
<tr>
<td headers="h1001"><code>public BigInteger getPrimeQ()</code></td>
<td headers="h1002">Returns the prime Q.</td>
</tr>
<tr>
<td headers="h1001"><code>public BigInteger getPrimeExponentP()</code></td>
<td headers="h1002">Returns the primeExponentP.</td>
</tr>
<tr>
<td headers="h1001"><code>public BigInteger getPrimeExponentQ()</code></td>
<td headers="h1002">Returns the primeExponentQ.</td>
</tr>
<tr>
<td headers="h1001"><code>public BigInteger getCrtCoefficient()</code></td>
<td headers="h1002">Returns the crtCoefficient.</td>
</tr>
</tbody>
</table>
<p>These methods return the public exponent <code>e</code> and the
CRT information integers: the prime factor <code>p</code> of the
modulus <code>n</code>, the prime factor <code>q</code> of
<code>n</code>, the exponent <code>d mod (p-1)</code>, the exponent
<code>d mod (q-1)</code>, and the Chinese Remainder Theorem
coefficient <code>(inverse of q) mod p</code>.</p>
<p>An RSA private key logically consists of only the modulus and
the private exponent. The presence of the CRT values is intended
for efficiency.</p>
<h3><a name="RSAPublicKeySpec" id="RSAPublicKeySpec">The</a>
<a href=
"../../../../api/java/security/spec/RSAPublicKeySpec.html">RSAPublicKeySpec</a>
Class</h3>
<p>This class (which implements the <a href=
"#KeySpec"><code>KeySpec</code></a> Interface) specifies an RSA
public key. It has the following methods:</p>
<table summary="method in RSAPublicKeySpec" border="1">
<thead>
<tr>
<th id="h1101">Method in <code>RSAPublicKeySpec</code></th>
<th id="h1102">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td headers="h1101"><code>public BigInteger getModulus()</code></td>
<td headers="h1102">Returns the modulus.</td>
</tr>
<tr>
<td headers="h1101"><code>public BigInteger getPublicExponent()</code></td>
<td headers="h1102">Returns the public exponent.</td>
</tr>
</tbody>
</table>
<p>These methods return the RSA modulus <code>n</code> and public
exponent <code>e</code> values that constitute the RSA public
key.</p>
<h3><a name="EncodedKeySpec" id="EncodedKeySpec">The</a> <a href=
"../../../../api/java/security/spec/EncodedKeySpec.html">EncodedKeySpec</a>
Class</h3>
<p>This abstract class (which implements the <a href=
"#KeySpec"><code>KeySpec</code></a> Interface) represents a public
or private key in encoded format.</p>
<!-- Its <code>getEncoded</code> method returns the encoded key:</p> -->
<!--

<pre class="codeblock">
    public abstract byte[] getEncoded();
</pre>
-->
<table summary="method in EncodedKeySpec" border="1">
<thead>
<tr>
<th id="h1201">Method in <code>EncodedKeySpec</code></th>
<th id="h1202">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td headers="h1201"><code>public abstract byte[] getEncoded()</code></td>
<td headers="h1202">Returns the encoded key.</td>
</tr>
<tr>
<td headers="h1201"><code>public abstract String getFormat()</code></td>
<td headers="h1202">Returns the name of the encoding format.</td>
</tr>
</tbody>
</table>
<!--
<p>and its <code>getFormat</code> method returns the name of the encoding
format:</p>

<pre class="codeblock">
    public abstract String getFormat();
</pre>
-->
<p>The JDK supplies two classes implementing the
<code>EncodedKeySpec</code> interface: <a href=
"#PKCS8EncodedKeySpec">PKCS8EncodedKeySpec</a> and <a href=
"#X509EncodedKeySpec">X509EncodedKeySpec</a>. If desired, you can
supply your own <code>EncodedKeySpec</code> implementations for
those or other types of key encodings.</p>
<h4><a name="PKCS8EncodedKeySpec" id="PKCS8EncodedKeySpec">The</a>
<a href=
"../../../../api/java/security/spec/PKCS8EncodedKeySpec.html"><code>
PKCS8EncodedKeySpec</code></a> Class</h4>
<p>This class, which is a subclass of <a href=
"#EncodedKeySpec"><code>EncodedKeySpec</code></a>, represents the
DER encoding of a private key, according to the format specified in
the PKCS #8 standard.</p>
<p>Its <code>getEncoded</code> method returns the key bytes,
encoded according to the PKCS #8 standard. Its
<code>getFormat</code> method returns the string "PKCS#8".</p>
<h4><a name="X509EncodedKeySpec" id="X509EncodedKeySpec">The</a>
<a href=
"../../../../api/java/security/spec/X509EncodedKeySpec.html">X509EncodedKeySpec</a>
Class</h4>
<p>This class, which is a subclass of <a href=
"#EncodedKeySpec"><code>EncodedKeySpec</code></a>, represents the
DER encoding of a public or private key, according to the format
specified in the X.509 standard.</p>
<p>Its <code>getEncoded</code> method returns the key bytes,
encoded according to the X.509 standard. Its <code>getFormat</code>
method returns the string "X.509". <!-- ***** end 40 ****** -->
<!-- ***** start 41 ****** -->
 <a href="#DHPrivateKeySpec"><code>DHPrivateKeySpec</code></a>,
<a href="#DHPublicKeySpec"><code>DHPublicKeySpec</code></a>,
<a href="#DESKeySpec"><code>DESKeySpec</code></a>, <a href=
"#DESedeKeySpec"><code>DESedeKeySpec</code></a>, <a href=
"#PBEKeySpec"><code>PBEKeySpec</code></a>, and <a href=
"#SecretKeySpec"><code>SecretKeySpec</code></a>.</p>
<h3><a name="DHPrivateKeySpec" id="DHPrivateKeySpec">The</a>
<a href=
"../../../../api/javax/crypto/spec/DHPrivateKeySpec.html"><code>DHPrivateKeySpec</code></a>
Class</h3>
<p>This class (which implements the <a href=
"../../../../api/java/security/spec/KeySpec.html"><code>KeySpec</code></a>
interface) specifies a Diffie-Hellman private key with its
associated parameters.</p>
<table summary="methods in DHPrviateKeySpec" border="1">
<thead>
<tr>
<th id="h1301">Method in <code>DHPrivateKeySpec</code></th>
<th id="h1302">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td headers="h1301"><code>BigInteger getG()</code></td>
<td headers="h1302">Returns the base generator <code>g</code>.</td>
</tr>
<tr>
<td headers="h1301"><code>BigInteger getP()</code></td>
<td headers="h1302">Returns the prime modulus <code>p</code>.</td>
</tr>
<tr>
<td headers="h1301"><code>BigInteger getX()</code></td>
<td headers="h1302">Returns the private value <code>x</code>.</td>
</tr>
</tbody>
</table>
<h3><a name="DHPublicKeySpec" id="DHPublicKeySpec">The</a> <a href=
"../../../../api/javax/crypto/spec/DHPublicKeySpec.html"><code>DHPublicKeySpec</code></a>
Class</h3>
<p>This class (which implements the <a href=
"../../../../api/java/security/spec/KeySpec.html"><code>KeySpec</code></a>
interface) specifies a Diffie-Hellman public key with its
associated parameters.</p>
<table summary="methods in DHPublicKeySpec" border="1">
<thead>
<tr>
<th id="h1401">Method in <code>DHPublicKeySpec</code></th>
<th id="h1402">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td headers="h1401"><code>BigInteger getG()</code></td>
<td headers="h1402">Returns the base generator <code>g</code>.</td>
</tr>
<tr>
<td headers="h1401"><code>BigInteger getP()</code></td>
<td headers="h1402">Returns the prime modulus <code>p</code>.</td>
</tr>
<tr>
<td headers="h1401"><code>BigInteger getY()</code></td>
<td headers="h1402">Returns the public value <code>y</code>.</td>
</tr>
</tbody>
</table>
<h3><a name="DESKeySpec" id="DESKeySpec">The</a> <a href=
"../../../../api/javax/crypto/spec/DESKeySpec.html"><code>DESKeySpec</code></a>
Class</h3>
<p>This class (which implements the <a href=
"../../../../api/java/security/spec/KeySpec.html"><code>KeySpec</code></a>
interface) specifies a DES key.</p>
<table summary="methods in DESKeySpec" border="1">
<thead>
<tr>
<th id="h1501">Method in <code>DESKeySpec</code></th>
<th id="h1502">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td headers="h1501"><code>byte[] getKey()</code></td>
<td headers="h1502">Returns the DES key bytes.</td>
</tr>
<tr>
<td headers="h1501"><code>static boolean isParityAdjusted(byte[] key, int
offset)</code></td>
<td headers="h1502">Checks if the given DES key material is parity-adjusted.</td>
</tr>
<tr>
<td headers="h1501"><code>static boolean isWeak(byte[] key, int offset)</code></td>
<td headers="h1502">Checks if the given DES key material is weak or semi-weak.</td>
</tr>
</tbody>
</table>
<h3><a name="DESedeKeySpec" id="DESedeKeySpec">The</a> <a href=
"../../../../api/javax/crypto/spec/DESedeKeySpec.html"><code>DESedeKeySpec</code></a>
Class</h3>
<p>This class (which implements the <a href=
"../../../../api/java/security/spec/KeySpec.html"><code>KeySpec</code></a>
interface) specifies a DES-EDE (Triple DES) key.</p>
<table summary="methods in DESedeKeySpec" border="1">
<thead>
<tr>
<th id="h1601">Method in <code>DESedeKeySpec</code></th>
<th id="h1602">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td headers="h1601"><code>byte[] getKey()</code></td>
<td headers="h1602">Returns the DES-EDE key.</td>
</tr>
<tr>
<td headers="h1601"><code>static boolean isParityAdjusted(byte[] key, int
offset)</code></td>
<td headers="h1602">Checks if the given DES-EDE key is parity-adjusted.</td>
</tr>
</tbody>
</table>
<h3><a name="PBEKeySpec" id="PBEKeySpec">The</a> <a href=
"../../../../api/javax/crypto/spec/PBEKeySpec.html"><code>PBEKeySpec</code></a>
Class</h3>
<p>This class implements the <a href=
"../../../../api/java/security/spec/KeySpec.html"><code>KeySpec</code></a>
interface. A user-chosen password can be used with password-based
encryption (PBE); the password can be viewed as a type of raw key
material. An encryption mechanism that uses this class can derive a
cryptographic key from the raw key material.</p>
<table summary="methods in PBEKeySpec" border="1">
<thead>
<tr>
<th id="h1701">Method in <code>PBEKeySpec</code></th>
<th id="h1702">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td headers="h1701"><code>void clearPassword</code></td>
<td headers="h1702">Clears the internal copy of the password.</td>
</tr>
<tr>
<td headers="h1701" width="250"><code>int getIterationCount</code></td>
<td headers="h1702">Returns the iteration count or 0 if not specified.</td>
</tr>
<tr>
<td headers="h1701"><code>int getKeyLength</code></td>
<td headers="h1702">Returns the to-be-derived key length or 0 if not
specified.</td>
</tr>
<tr>
<td headers="h1701"><code>char[] getPassword</code></td>
<td headers="h1702">Returns a copy of the password.</td>
</tr>
<tr>
<td headers="h1701"><code>byte[] getSalt</code></td>
<td headers="h1702">Returns a copy of the salt or null if not specified.</td>
</tr>
</tbody>
</table>
<h3><a name="SecretKeySpec" id="SecretKeySpec">The</a> <a href=
"../../../../api/javax/crypto/spec/SecretKeySpec.html"><code>SecretKeySpec</code></a>
Class</h3>
<p>This class implements the <a href=
"../../../../api/java/security/spec/KeySpec.html"><code>KeySpec</code></a>
interface. Since it also implements the <a href=
"../../../../api/javax/crypto/SecretKey.html"><code>SecretKey</code></a>
interface, it can be used to construct a <code>SecretKey</code>
object in a provider-independent fashion, i.e., without having to
go through a provider-based <code>SecretKeyFactory</code>.</p>
<table summary="methods in SecretKeySpec" border="1">
<thead>
<tr>
<th id="h1801">Method in <code>SecretKeySpec</code></th>
<th id="h1802">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td headers="h1801"><code>boolean equals (Object obj)</code></td>
<td headers="h1802">Indicates whether some other object is "equal to" this
one.</td>
</tr>
<tr>
<td headers="h1801"><code>String getAlgorithm()</code></td>
<td headers="h1802">Returns the name of the algorithm associated with this secret
key.</td>
</tr>
<tr>
<td headers="h1801"><code>byte[] getEncoded()</code></td>
<td headers="h1802">Returns the key material of this secret key.</td>
</tr>
<tr>
<td headers="h1801"><code>String getFormat()</code></td>
<td headers="h1802">Returns the name of the encoding format for this secret
key.</td>
</tr>
<tr>
<td headers="h1801"><code>int hashCode()</code></td>
<td headers="h1802">Calculates a hash code value for the object.</td>
</tr>
</tbody>
</table>
<h2><a name="SecretKeyGen" id="SecretKeyGen">Secret-Key
Generation</a></h2>
<p>If you provide a secret-key generator (subclass of
<code>javax.crypto.KeyGeneratorSpi</code>) for a particular
secret-key algorithm, you may return the generated secret-key
object (which must be an instance of
<code>javax.crypto.SecretKey</code>, see <a href=
"../../../../api/javax/crypto/KeyGeneratorSpi.html#engineGenerateKey--">
<code>engineGenerateKey</code></a>) in one of the following
ways:</p>
<ul>
<li>You implement a class whose instances represent secret-keys of
the algorithm associated with your key generator. Your key
generator implementation returns instances of that class. This
approach is useful if the keys generated by your key generator have
provider-specific properties.</li>
<li>Your key generator returns an instance of <a href=
"../../../../api/javax/crypto/spec/SecretKeySpec.html"><code>SecretKeySpec</code></a>,
which already implements the <code>javax.crypto.SecretKey</code>
interface. You pass the (raw) key bytes and the name of the
secret-key algorithm associated with your key generator to the
<code>SecretKeySpec</code> constructor. This approach is useful if
the underlying (raw) key bytes can be represented as a byte array
and have no key-parameters associated with them.</li>
</ul>
<!-- ***** end 41 ****** -->
<!-- ***** start 42 ****** -->
<h2><a name="NewOIDs" id="NewOIDs">Adding New Object
Identifiers</a></h2>
<p>The following information applies to providers who supply an
algorithm that is not listed as one of the standard algorithms in
<a href="CryptoSpec.html#AppA">Appendix A</a> of the <i>Java
Cryptography Architecture Reference Guide</i>.</p>
<h3>Mapping from OID to Name</h3>
<p>Sometimes the JCA needs to instantiate a cryptographic algorithm
implementation from an algorithm identifier (for example, as
encoded in a certificate), which by definition includes the object
identifier (OID) of the algorithm. For example, in order to verify
the signature on an X.509 certificate, the JCA determines the
signature algorithm from the signature algorithm identifier that is
encoded in the certificate, instantiates a Signature object for
that algorithm, and initializes the Signature object for
verification.</p>
<p>For the JCA to find your algorithm, you must provide the object
identifier of your algorithm as an alias entry for your algorithm
in the provider master file.</p>
<pre class="codeblock">
    put("Alg.Alias.&lt;engine_type&gt;.1.2.3.4.5.6.7.8",
        "&lt;algorithm_alias_name&gt;");
</pre>
<p>Note that if your algorithm is known under more than one object
identifier, you need to create an alias entry for each object
identifier under which it is known.</p>
<p>An example of where the JCA needs to perform this type of
mapping is when your algorithm ("<code>Foo</code>") is a signature
algorithm and users run the <code>keytool</code> command and
specify your (signature) algorithm alias.</p>
<pre class="codeblock">
    % keytool -genkeypair -sigalg 1.2.3.4.5.6.7.8
</pre>
<p>In this case, your provider master file should contain the
following entries:</p>
<pre class="codeblock">
    put("Signature.Foo", "com.xyz.MyFooSignatureImpl");
    put("Alg.Alias.Signature.1.2.3.4.5.6.7.8", "Foo");
</pre>
<p>Other examples of where this type of mapping is performed are
(1) when your algorithm is a keytype algorithm and your program
parses a certificate (using the X.509 implementation of the SUN
provider) and extracts the public key from the certificate in order
to initialize a Signature object for verification, and (2) when
<code>keytool</code> users try to access a private key of your
keytype (for example, to perform a digital signature) after having
generated the corresponding keypair. In these cases, your provider
master file should contain the following entries:</p>
<pre class="codeblock">
    put("KeyFactory.Foo", "com.xyz.MyFooKeyFactoryImpl");
    put("Alg.Alias.KeyFactory.1.2.3.4.5.6.7.8", "Foo");
</pre>
<h3>Mapping from Name to OID</h3>
<p>If the JCA needs to perform the inverse mapping (that is, from
your algorithm name to its associated OID), you need to provide an
alias entry of the following form for one of the OIDs under which
your algorithm should be known:</p>
<pre class="codeblock">
    put("Alg.Alias.Signature.OID.1.2.3.4.5.6.7.8", "MySigAlg");
</pre>
<p>If your algorithm is known under more than one object
identifier, prefix the preferred one with "OID."</p>
<p>An example of where the JCA needs to perform this kind of
mapping is when users run <code>keytool</code> in any mode that
takes a <code>-sigalg</code> option. For example, when the
<code>-genkeypair</code> and <code>-certreq</code> commands are
invoked, the user can specify your (signature) algorithm with the
<code>-sigalg</code> option.</p>
<!-- ***** end 42 ****** -->
<!-- ***** insert 43 Ensuring Exportability ****** -->
<h2><a name="EnsureExport" id="EnsureExport">Ensuring
Exportability</a></h2>
<p>A key feature of JCA is the exportability of the JCA framework
and of the provider cryptography implementations if certain
conditions are met.</p>
<p>Due to import control restrictions by the governments of a few
countries, the jurisdiction policy files shipped with the JDK specify that "strong" but limited
cryptography may be used. An "unlimited" version of these files
indicating no restrictions on cryptographic strengths is available
for those living in eligible countries (which is most countries).
But only the "strong" version can be imported into those countries
whose governments mandate restrictions. The JCA framework will
enforce the restrictions specified in the installed jurisdiction
policy files.</p>
<p>As noted elsewhere, you can write just one version of your
provider software, implementing cryptography of maximum strength.
It is up to JCA, not your provider, to enforce any jurisdiction
policy file-mandated restrictions regarding the cryptographic
algorithms and maximum cryptographic strengths available to
applets/applications in different locations.</p>
<p>The conditions that must be met by your provider in order to
enable it to be plugged into JCA are the following:</p>
<ul>
<li>The constructor of each SPI implementation class should do
self-integrity checking, as described in <a href=
"#integritycheck">How a Provider Can Do Self-Integrity
Checking</a>.</li>
<li>The provider code should be written in such a way that provider
classes become unusable if instantiated by an application directly,
bypassing JCA. See <a href="#Step1">Step 1: Write Your Service
Implementation Code</a> in the <i>Steps to Implement and Integrate
a Provider</i> section.</li>
<li>The provider package must be signed by an entity trusted by the
JCA framework. (See <a href="#Step61">Step 6.1</a> through <a href=
"#Step62">Step 6.2</a>.) U.S. vendors whose providers may be
exported outside the U.S. first need to apply for U.S. government
export approval. (See <a href="#Step10">Step 10</a>.)</li>
</ul>

<!-- this div is for the above color block -->
<!-- ******  end 43 and probably the end of text ***** -->
<!-- ******  end 43 and probably the end of text ***** -->
<!-- ******  end 43 and probably the end of text ***** -->
<!-- ******  Appendix A ***** -->
<h2><a name="AppA" id="AppA">Appendix A: The <i>Sun</i> Provider
Master Class</a></h2>
<p>Below is an edited version of the <code>Sun.java</code> file,
which contains a class named <code>Sun</code> that is the <a href=
"#Step3"><i>master class</i></a> for the provider named
<i>Sun</i>.</p>
<p>As with all master classes, this class is a subclass of
<code>Provider</code>. It specifies the class names and package
locations of all service implementations supplied by the <i>Sun</i>
provider. This information is used by the <code>getInstance</code>
methods of the engine classes to look up the various algorithms and
other services when they are requested.</p>
<p>This code is supplied as an example of a provider master
class.</p>

<pre class="codeblock">
/*
 * @(#)Sun.java 1.28 99/05/27
 *
 * Copyright (c) 1996, 1998, Oracle and/or its affiliates. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *   - Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *
 *   - Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 *   - Neither the name of Oracle nor the names of its
 *     contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
 * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package sun.security.provider;

import java.io.*;
import java.util.*;
import java.security.*;

/**
 * The SUN Security Provider.
 *
 * @author Benjamin Renaud
 *
 * @version 1.28, 05/27/99
 */

/**
 * Defines the SUN provider.
 *
 * Algorithms supported, and their names:
 *
 * - SHA is the message digest scheme described in FIPS 180-1.
 *   Aliases for SHA are SHA-1 and SHA1.
 *
 * - SHA1withDSA is the signature scheme described in FIPS 186.
 *   (SHA used in DSA is SHA-1: FIPS 186 with Change No 1.)
 *   Aliases for SHA1withDSA are DSA, DSS, SHA/DSA, SHA-1/DSA, SHA1/DSA,
 *   SHAwithDSA, DSAWithSHA1, and the object
 *   identifier strings "OID.1.3.14.3.2.13", "OID.1.3.14.3.2.27" and
 *   "OID.1.2.840.10040.4.3".
 *
 * - DSA is the key generation scheme as described in FIPS 186.
 *   Aliases for DSA include the OID strings "OID.1.3.14.3.2.12"
 *   and "OID.1.2.840.10040.4.1".
 *
 * - MD5 is the message digest scheme described in RFC 1321.
 *   There are no aliases for MD5.
 */

public final class Sun extends Provider {

    private static final String INFO = "SUN " +
    "(DSA key/parameter generation; DSA signing; " +
    "SHA-1, MD5 digests; SecureRandom; X.509 certificates; JKS keystore)";

    public Sun() {
        /* We are the SUN provider */
        super("SUN", 1.2, INFO);

        AccessController.doPrivileged(new java.security.PrivilegedAction() {
            public Object run() {

                /*
                 * Signature engines
                 */
                put("Signature.SHA1withDSA", "sun.security.provider.DSA");

                put("Alg.Alias.Signature.DSA", "SHA1withDSA");
                put("Alg.Alias.Signature.DSS", "SHA1withDSA");
                put("Alg.Alias.Signature.SHA/DSA", "SHA1withDSA");
                put("Alg.Alias.Signature.SHA-1/DSA", "SHA1withDSA");
                put("Alg.Alias.Signature.SHA1/DSA", "SHA1withDSA");
                put("Alg.Alias.Signature.SHAwithDSA", "SHA1withDSA");
                put("Alg.Alias.Signature.DSAWithSHA1", "SHA1withDSA");
                put("Alg.Alias.Signature.OID.1.2.840.10040.4.3",
                    "SHA1withDSA");
                put("Alg.Alias.Signature.1.2.840.10040.4.3", "SHA1withDSA");
                put("Alg.Alias.Signature.1.3.14.3.2.13", "SHA1withDSA");
                put("Alg.Alias.Signature.1.3.14.3.2.27", "SHA1withDSA");

                /*
                 *  Key Pair Generator engines
                 */
                put("KeyPairGenerator.DSA",
                    "sun.security.provider.DSAKeyPairGenerator");
                put("Alg.Alias.KeyPairGenerator.OID.1.2.840.10040.4.1", "DSA");
                put("Alg.Alias.KeyPairGenerator.1.2.840.10040.4.1", "DSA");
                put("Alg.Alias.KeyPairGenerator.1.3.14.3.2.12", "DSA");

                /*
                 * Digest engines
                 */
                put("MessageDigest.MD5", "sun.security.provider.MD5");
                put("MessageDigest.SHA", "sun.security.provider.SHA");

                put("Alg.Alias.MessageDigest.SHA-1", "SHA");
                put("Alg.Alias.MessageDigest.SHA1", "SHA");

                /*
                 * Algorithm Parameter Generator engines
                 */
                put("AlgorithmParameterGenerator.DSA",
                    "sun.security.provider.DSAParameterGenerator");

                /*
                 * Algorithm Parameter engines
                 */
                put("AlgorithmParameters.DSA",
                    "sun.security.provider.DSAParameters");
                put("Alg.Alias.AlgorithmParameters.1.3.14.3.2.12", "DSA");
                put("Alg.Alias.AlgorithmParameters.1.2.840.10040.4.1", "DSA");

                /*
                 * Key factories
                 */
                put("KeyFactory.DSA", "sun.security.provider.DSAKeyFactory");
                put("Alg.Alias.KeyFactory.1.3.14.3.2.12", "DSA");
                put("Alg.Alias.KeyFactory.1.2.840.10040.4.1", "DSA");

                /*
                 * SecureRandom
                 */
                 put("SecureRandom.SHA1PRNG",
                     "sun.security.provider.SecureRandom");

                /*
                 * Certificates
                 */
                put("CertificateFactory.X509",
                    "sun.security.provider.X509Factory");
                put("Alg.Alias.CertificateFactory.X.509", "X509");

                /*
                 * KeyStore
                 */
                put("KeyStore.JKS", "sun.security.provider.JavaKeyStore");

                /*
                 * KeySize
                 */
                put("Signature.SHA1withDSA KeySize", "1024");
                put("KeyPairGenerator.DSA KeySize", "1024");
                put("AlgorithmParameterGenerator.DSA KeySize", "1024");

                /*
                 * Implementation type: software or hardware
                 */
                put("Signature.SHA1withDSA ImplementedIn", "Software");
                put("KeyPairGenerator.DSA ImplementedIn", "Software");
                put("MessageDigest.MD5 ImplementedIn", "Software");
                put("MessageDigest.SHA ImplementedIn", "Software");
                put("AlgorithmParameterGenerator.DSA ImplementedIn",
                    "Software");
                put("AlgorithmParameters.DSA ImplementedIn", "Software");
                put("KeyFactory.DSA ImplementedIn", "Software");
                put("SecureRandom.SHA1PRNG ImplementedIn", "Software");
                put("CertificateFactory.X509 ImplementedIn", "Software");
                put("KeyStore.JKS ImplementedIn", "Software");

                return null;
            }
        });
    }
}
</pre>
<!-- ******  Appendix B ***** -->
<h2><a name="AppB" id="AppB">Appendix B: The <i>SunJCE</i> Provider
Master Class</a></h2>
<p>Below is an edited version of the <code>SunJCE.java</code> file,
which contains a class named <code>SunJCE</code> that is the
<a href="#Step3"><i>master class</i></a> for the provider named
<i>SunJCE</i>.</p>
<p>As with all master classes, this class is a subclass of
<code>Provider</code>. It specifies the class names and package
locations of all the cryptographic service implementations supplied
by the <i>SunJCE</i> provider. This information is used by the
<code>getInstance</code> methods of the engine classes to look up
the various algorithms and other services when they are
requested.</p>
<p>This code is supplied as an example of a provider master
class.</p>
<!-- *********** code *************** -->

<pre class="codeblock">
/*
 * @(#)SunJCE.java      1.73 05/12/13
 *
 * Copyright (c) 2006, Oracle and/or its affiliates. All rights reserved.
 * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
 */

package com.sun.crypto.provider;

import java.security.*;
import java.security.cert.*;
import java.net.URL;
import java.io.ByteArrayInputStream;

/**
 * The "SunJCE" Cryptographic Service Provider.
 *
 * @author Jan Luehe
 * @author Sharon Liu
 *
 * @version 1.73, 12/13/05
 */

/**
 * Defines the "SunJCE" provider.
 *
 * Supported algorithms and their names:
 *
 * ...edited for space...
 *
 */

public final class SunJCE extends Provider {

    private static final String info = "SunJCE Provider " +
    "(implements RSA, DES, Triple DES, AES, Blowfish, ARCFOUR, RC2, PBE, "
    + "Diffie-Hellman, HMAC)";

    private static final String OID_PKCS5_MD5_DES = "1.2.840.113549.1.5.3";
    private static final String OID_PKCS3 = "1.2.840.113549.1.3.1";

    public SunJCE() {
        /* We are the "SunJCE" provider */
        super("SunJCE", 1.6d, info);

        final String BLOCK_MODES = "ECB|CBC|PCBC|CTR|CTS|CFB|OFB" +
            "|CFB8|CFB16|CFB24|CFB32|CFB40|CFB48|CFB56|CFB64" +
            "|OFB8|OFB16|OFB24|OFB32|OFB40|OFB48|OFB56|OFB64";
        final String BLOCK_MODES128 = BLOCK_MODES +
            "|CFB72|CFB80|CFB88|CFB96|CFB104|CFB112|CFB120|CFB128" +
            "|OFB72|OFB80|OFB88|OFB96|OFB104|OFB112|OFB120|OFB128";
        final String BLOCK_PADS = "NOPADDING|PKCS5PADDING|ISO10126PADDING";

        AccessController.doPrivileged(new java.security.PrivilegedAction() {
                public Object run() {

                /*
                 * Cipher engines
                 */
                put("Cipher.RSA", "com.sun.crypto.provider.RSACipher");
                put("Cipher.RSA SupportedModes", "ECB");
                put("Cipher.RSA SupportedPaddings",
                        "NOPADDING|PKCS1PADDING|OAEPWITHMD5ANDMGF1PADDING"
                        + "|OAEPWITHSHA1ANDMGF1PADDING"
                        + "|OAEPWITHSHA-1ANDMGF1PADDING"
                        + "|OAEPWITHSHA-256ANDMGF1PADDING"
                        + "|OAEPWITHSHA-384ANDMGF1PADDING"
                        + "|OAEPWITHSHA-512ANDMGF1PADDING");
                put("Cipher.RSA SupportedKeyClasses",
                        "java.security.interfaces.RSAPublicKey" +
                        "|java.security.interfaces.RSAPrivateKey");

                put("Cipher.PBEWithMD5AndDES",
                    "com.sun.crypto.provider.PBEWithMD5AndDESCipher");
                put("Alg.Alias.Cipher.OID."+OID_PKCS5_MD5_DES,
                    "PBEWithMD5AndDES");
                put("Alg.Alias.Cipher."+OID_PKCS5_MD5_DES,
                    "PBEWithMD5AndDES");

                put("Cipher.AES", "com.sun.crypto.provider.AESCipher");
                put("Alg.Alias.Cipher.Rijndael", "AES");
                put("Cipher.AES SupportedModes", BLOCK_MODES128);
                put("Cipher.AES SupportedPaddings", BLOCK_PADS);
                put("Cipher.AES SupportedKeyFormats", "RAW");

                put("Cipher.AESWrap", "com.sun.crypto.provider.AESWrapCipher");
                put("Cipher.AESWrap SupportedModes", "ECB");
                put("Cipher.AESWrap SupportedPaddings", "NOPADDING");
                put("Cipher.AESWrap SupportedKeyFormats", "RAW");

                put("Cipher.ARCFOUR",
                    "com.sun.crypto.provider.ARCFOURCipher");
                put("Alg.Alias.Cipher.RC4", "ARCFOUR");
                put("Cipher.ARCFOUR SupportedModes", "ECB");
                put("Cipher.ARCFOUR SupportedPaddings", "NOPADDING");
                put("Cipher.ARCFOUR SupportedKeyFormats", "RAW");

                /*
                 *  Key(pair) Generator engines
                 */
                put("KeyGenerator.AES",
                    "com.sun.crypto.provider.AESKeyGenerator");
                put("Alg.Alias.KeyGenerator.Rijndael", "AES");

                put("KeyGenerator.ARCFOUR",
                    "com.sun.crypto.provider.KeyGeneratorCore$" +
                    "ARCFOURKeyGenerator");
                put("Alg.Alias.KeyGenerator.RC4", "ARCFOUR");

                put("KeyGenerator.HmacMD5",
                    "com.sun.crypto.provider.HmacMD5KeyGenerator");

                put("KeyGenerator.HmacSHA256",
                    "com.sun.crypto.provider.KeyGeneratorCore$HmacSHA256KG");

                put("KeyPairGenerator.DiffieHellman",
                    "com.sun.crypto.provider.DHKeyPairGenerator");
                put("Alg.Alias.KeyPairGenerator.DH", "DiffieHellman");
                put("Alg.Alias.KeyPairGenerator.OID."+OID_PKCS3,
                    "DiffieHellman");
                put("Alg.Alias.KeyPairGenerator."+OID_PKCS3,
                    "DiffieHellman");

                /*
                 * Algorithm parameter generation engines
                 */
                put("AlgorithmParameterGenerator.DiffieHellman",
                    "com.sun.crypto.provider.DHParameterGenerator");
                put("Alg.Alias.AlgorithmParameterGenerator.DH",
                    "DiffieHellman");
                put("Alg.Alias.AlgorithmParameterGenerator.OID."+OID_PKCS3,
                    "DiffieHellman");
                put("Alg.Alias.AlgorithmParameterGenerator."+OID_PKCS3,
                    "DiffieHellman");

                /*
                 * Key Agreement engines
                 */
                put("KeyAgreement.DiffieHellman",
                    "com.sun.crypto.provider.DHKeyAgreement");
                put("Alg.Alias.KeyAgreement.DH", "DiffieHellman");
                put("Alg.Alias.KeyAgreement.OID."+OID_PKCS3, "DiffieHellman");
                put("Alg.Alias.KeyAgreement."+OID_PKCS3, "DiffieHellman");

                put("KeyAgreement.DiffieHellman SupportedKeyClasses",
                    "javax.crypto.interfaces.DHPublicKey" +
                    "|javax.crypto.interfaces.DHPrivateKey");

                /*
                 * Algorithm Parameter engines
                 */
                put("AlgorithmParameters.DiffieHellman",
                    "com.sun.crypto.provider.DHParameters");
                put("Alg.Alias.AlgorithmParameters.DH", "DiffieHellman");
                put("Alg.Alias.AlgorithmParameters.OID."+OID_PKCS3,
                    "DiffieHellman");
                put("Alg.Alias.AlgorithmParameters."+OID_PKCS3,
                    "DiffieHellman");

                put("AlgorithmParameters.PBEWithMD5AndDES",
                    "com.sun.crypto.provider.PBEParameters");
                put("Alg.Alias.AlgorithmParameters.OID."+OID_PKCS5_MD5_DES,
                    "PBEWithMD5AndDES");
                put("Alg.Alias.AlgorithmParameters."+OID_PKCS5_MD5_DES,
                    "PBEWithMD5AndDES");

                put("AlgorithmParameters.OAEP",
                    "com.sun.crypto.provider.OAEPParameters");

                /*
                 * Key factories
                 */
                put("KeyFactory.DiffieHellman",
                    "com.sun.crypto.provider.DHKeyFactory");
                put("Alg.Alias.KeyFactory.DH", "DiffieHellman");
                put("Alg.Alias.KeyFactory.OID."+OID_PKCS3,
                    "DiffieHellman");
                put("Alg.Alias.KeyFactory."+OID_PKCS3, "DiffieHellman");

                /*
                 * Secret-key factories
                 */
                put("SecretKeyFactory.PBEWithMD5AndDES",
                    "com.sun.crypto.provider.PBEKeyFactory$PBEWithMD5AndDES"
                    );
                put("Alg.Alias.SecretKeyFactory.OID."+OID_PKCS5_MD5_DES,
                    "PBEWithMD5AndDES");
                put("Alg.Alias.SecretKeyFactory."+OID_PKCS5_MD5_DES,
                    "PBEWithMD5AndDES");

                /*
                 * MAC
                 */
                put("Mac.HmacMD5", "com.sun.crypto.provider.HmacMD5");
                put("Mac.HmacSHA256",
                    "com.sun.crypto.provider.HmacCore$HmacSHA256");

                put("Mac.HmacMD5 SupportedKeyFormats", "RAW");
                put("Mac.HmacSHA256 SupportedKeyFormats", "RAW");

                /*
                 * KeyStore
                 */
                put("KeyStore.JCEKS", "com.sun.crypto.provider.JceKeyStore");

                return null;
            }
        });
    }
}
 
</pre>
<!-- ******  Appendix C ***** -->
<h2><a name="AppC" id="AppC">Appendix C: The
<i>java.security.properties</i> File</a></h2>
<p>Below is part of the <code>java.security</code> file that shows
the default list of installed providers. It appears in every JRE
installation. The file also contains other entries, but for
brevity, we show only part of the file here. See the complete file
at:</p>

<ul>
  <li>Solaris, Linux, or Mac OS X: <code><em>&lt;java-home&gt;</em>/lib/security/java.security</code></li>
  <li>Windows:                     <code><em>&lt;java-home&gt;</em>\lib\security\java.security</code></li>
</ul>

<p>Here <tt>&lt;java-home&gt;</tt> refers to the directory where
the JRE was installed.</p>
<p>See <a href="#Step5">Step 5</a> for an example of adding
information about your provider to this file.</p>

<pre class="codeblock">
#
# This is the "master security properties file".
#
# In this file, various security properties are set for use by
# java.security classes. This is where users can statically register
# Cryptography Package Providers ("providers" for short). The term
# "provider" refers to a package or set of packages that supply a
# concrete implementation of a subset of the cryptography aspects of
# the Java Security API. A provider may, for example, implement one or
# more digital signature algorithms or message digest algorithms.
#
# Each provider must implement a subclass of the Provider class.
# To register a provider in this master security properties file,
# specify the Provider subclass name and priority in the format
#
#    security.provider.&lt;n&gt;=&lt;className&gt;
#
# This declares a provider, and specifies its preference
# order n. The preference order is the order in which providers are
# searched for requested algorithms (when no specific provider is
# requested). The order is 1-based; 1 is the most preferred, followed
# by 2, and so on.
#
# &lt;className&gt; must specify the subclass of the Provider class whose
# constructor sets the values of various properties that are required
# for the Java Security API to look up the algorithms or other
# facilities implemented by the provider.
#
# There must be at least one provider specification in java.security.
# There is a default provider that comes standard with the JDK. It
# is called the "SUN" provider, and its Provider subclass
# named Sun appears in the sun.security.provider package. Thus, the
# "SUN" provider is registered via the following:
#
#    security.provider.1=sun.security.provider.Sun
#
# (The number 1 is used for the default provider.)
#
# Note: Providers can be dynamically registered instead by calls to
# either the addProvider or insertProviderAt method in the Security
# class.

#
# List of providers and their preference orders (see above):
#

security.provider.1=sun.security.pkcs11.SunPKCS11 \
    ${java.home}/lib/security/sunpkcs11-solaris.cfg
security.provider.2=sun.security.provider.Sun
security.provider.3=sun.security.rsa.SunRsaSign
security.provider.4=com.sun.net.ssl.internal.ssl.Provider
security.provider.5=com.sun.crypto.provider.SunJCE
security.provider.6=sun.security.jgss.SunProvider
security.provider.7=com.sun.security.sasl.Provider
security.provider.8=org.jcp.xml.dsig.internal.dom.XMLDSigRI
security.provider.9=sun.security.smartcardio.SunPCSC

# Rest of file deleted

</pre>
<!--
#
# Select the source of seed data for SecureRandom. By default an
# attempt is made to use the entropy gathering device specified by
# the securerandom.source property. If an exception occurs when
# accessing the URL then the traditional system/thread activity
# algorithm is used.
#
# On Solaris, Linux, or Mac OS X operating systems,
# if file:/dev/urandom is specified and it
# exists, a special SecureRandom implementation is activated by default.
# This "NativePRNG" reads random bytes directly from /dev/urandom.
#
# On Windows systems, the URLs file:/dev/random and file:/dev/urandom
# enables use of the Microsoft CryptoAPI seed functionality.
#
securerandom.source=file:/dev/urandom
#
# The entropy gathering device is described as a URL and can also
# be specified with the system property "java.security.egd". For example,
#   -Djava.security.egd=file:/dev/urandom
# Specifying this system property will override the securerandom.source
# setting.

#
# Class to instantiate as the javax.security.auth.login.Configuration
# provider.
#
login.configuration.provider=com.sun.security.auth.login.ConfigFile

#
# Default login configuration file
#
#login.config.url.1=file:${user.home}/.java.login.config

#
# Class to instantiate as the system Policy. This is the name of the class
# that will be used as the Policy object.
#
policy.provider=sun.security.provider.PolicyFile

# The default is to have a single system-wide policy file,
# and a policy file in the user's home directory.
policy.url.1=file:${java.home}/lib/security/java.policy
policy.url.2=file:${user.home}/.java.policy

# whether or not we expand properties in the policy file
# if this is set to false, properties (${...}) will not be expanded in policy
# files.
policy.expandProperties=true

# whether or not we allow an extra policy to be passed on the command line
# with -Djava.security.policy=somefile. Comment out this line to disable
# this feature.
policy.allowSystemProperty=true

# whether or not we look into the IdentityScope for trusted Identities
# when encountering a 1.1 signed JAR file. If the identity is found
# and is trusted, we grant it AllPermission.
policy.ignoreIdentityScope=false

#
# Default keystore type.
#
keystore.type=jks

#
# Class to instantiate as the system scope:
#
system.scope=sun.security.provider.IdentityDatabase

#
# List of comma-separated packages that start with or equal this string
# will cause a security exception to be thrown when
# passed to checkPackageAccess unless the
# corresponding RuntimePermission ("accessClassInPackage."+package) has
# been granted.
package.access=sun.

#
# List of comma-separated packages that start with or equal this string
# will cause a security exception to be thrown when
# passed to checkPackageDefinition unless the
# corresponding RuntimePermission ("defineClassInPackage."+package) has
# been granted.
#
# by default, no packages are restricted for definition, and none of
# the class loaders supplied with the JDK call checkPackageDefinition.
#
#package.definition=

#
# Determines whether this properties file can be appended to
# or overridden on the command line via -Djava.security.properties
#
security.overridePropertiesFile=true

#
# Determines the default key and trust manager factory algorithms for
# the javax.net.ssl package.
#
ssl.KeyManagerFactory.algorithm=SunX509
ssl.TrustManagerFactory.algorithm=PKIX

#
# The Java-level namelookup cache policy for successful lookups:
#
# any negative value: caching forever
# any positive value: the number of seconds to cache an address for
# zero: do not cache
#
# default value is forever (FOREVER). For security reasons, this
# caching is made forever when a security manager is set.
#
# NOTE: setting this to anything other than the default value can have
#       serious security implications. Do not set it unless
#       you are sure you are not exposed to DNS spoofing attack.
#
#networkaddress.cache.ttl=-1

# The Java-level namelookup cache policy for failed lookups:
#
# any negative value: cache forever
# any positive value: the number of seconds to cache negative lookup results
# zero: do not cache
#
# In some Microsoft Windows networking environments that employ
# the WINS name service in addition to DNS, name service lookups
# that fail may take a noticeably long time to return (approx. 5 seconds).
# For this reason the default caching policy is to maintain these
# results for 10 seconds.
#
#
networkaddress.cache.negative.ttl=10

#
# Properties to configure OCSP for certificate revocation checking
#

# Enable OCSP
#
# By default, OCSP is not used for certificate revocation checking.
# This property enables the use of OCSP when set to the value "true".
#
# NOTE: SocketPermission is required to connect to an OCSP responder.
#
# Example,
#   ocsp.enable=true

#
# Location of the OCSP responder
#
# By default, the location of the OCSP responder is determined implicitly
# from the certificate being validated. This property explicitly specifies
# the location of the OCSP responder. The property is used when the
# Authority Information Access extension (defined in RFC 3280) is absent
# from the certificate or when it requires overriding.
#
# Example,
#   ocsp.responderURL=http://ocsp.example.net:80

#
# Subject name of the OCSP responder's certificate
#
# By default, the certificate of the OCSP responder is that of the issuer
# of the certificate being validated. This property identifies the certificate
# of the OCSP responder when the default does not apply. Its value is a string
# distinguished name (defined in RFC 2253) which identifies a certificate in
# the set of certificates supplied during cert path validation. In cases where
# the subject name alone is not sufficient to uniquely identify the certificate
# then both the "ocsp.responderCertIssuerName" and
# "ocsp.responderCertSerialNumber" properties must be used instead. When this
# property is set then those two properties are ignored.
#
# Example,
#   ocsp.responderCertSubjectName="CN=OCSP Responder, O=XYZ Corp"

#
# Issuer name of the OCSP responder's certificate
#
# By default, the certificate of the OCSP responder is that of the issuer
# of the certificate being validated. This property identifies the certificate
# of the OCSP responder when the default does not apply. Its value is a string
# distinguished name (defined in RFC 2253) which identifies a certificate in
# the set of certificates supplied during cert path validation. When this
# property is set then the "ocsp.responderCertSerialNumber" property must also
# be set. When the "ocsp.responderCertSubjectName" property is set then this
# property is ignored.
#
# Example,
#   ocsp.responderCertIssuerName="CN=Enterprise CA, O=XYZ Corp"

#
# Serial number of the OCSP responder's certificate
#
# By default, the certificate of the OCSP responder is that of the issuer
# of the certificate being validated. This property identifies the certificate
# of the OCSP responder when the default does not apply. Its value is a string
# of hexadecimal digits (colon or space separators may be present) which
# identifies a certificate in the set of certificates supplied during cert path
# validation. When this property is set then the "ocsp.responderCertIssuerName"
# property must also be set. When the "ocsp.responderCertSubjectName" property
# is set then this property is ignored.
#
# Example,
#   ocsp.responderCertSerialNumber=2A:FF:00

</pre> -->



<!--  footer start -->
<div id="javasefooter">
<div class="hr">
<hr /></div>
<div id="javasecopyright">
<img id="oraclelogofooter" src=
"../../../../images/oraclelogo.gif" alt="Oracle and/or its affiliates"
border="0" width="100" height="29" name=
"oraclelogofooter" />

<a href="../../../../legal/cpyr.html">Copyright
&#169;</a> 1993, 2015, Oracle and/or its affiliates. All rights
reserved.</div>
<div id="javasecontactus">
<a href=
"http://docs.oracle.com/javase/feedback.html">Contact
Us</a>
</div>
</div>
<!-- footer end -->

<!-- STATIC FOOTER -->

</body>
</html>
