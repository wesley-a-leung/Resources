<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en-US" xmlns="http://www.w3.org/1999/xhtml" xml:lang=
"en-US">
<head>
<!-- The .red css class is for writers notes
     so I don't forget to change things.

     New Features section commented out temporarily.

     Forced the paragraph tag to properly define itself

     Forced the code tag font to match the size
     of the paragraph font.
-->
<title>Java Cryptography Architecture (JCA) Reference Guide</title>
<link rel="stylesheet" type="text/css" href=
"../../../css/jdk_index_style.css" />
<link rel="stylesheet" type="text/css" href="../../../../technotes/css/guide.css" />
</head>
<body>
<!-- STATIC HEADER -->

<!-- header start -->
<div id="javaseheader">
<div id="javaseheaderlogo">
<img src="../../../../images/javalogo.gif"
alt="Java logo" />
</div>
<div id="javaseheaderindex">

<a href=
"../../../../index.html">Documentation Contents</a>
</div>
<div class="clear"></div>
</div>

<!-- header end -->


<h1>Java Cryptography Architecture (JCA) Reference Guide</h1>
<div class="a1"><a href="#javasemaincontent" class="skiplink">Skip
Table of Contents</a></div>
<ul>
<li><a href="#Introduction">Introduction</a>
<ul>
<li><a href="#Design">Design Principles</a></li>
<li><a href="#Architecture">Architecture</a></li>
<li><a href="#Concepts">JCA Concepts</a></li>
</ul>
</li>
<li><a href="#CoreClasses">Core Classes and Interfaces</a>
<ul>
<li><a href="#Provider">The <code>Provider</code> Class</a>
<ul>
<li><a href="#ProviderImplReq">How Provider Implementations are
Requested and Supplied</a></li>
<li><a href="#ProviderInstalling">Installing Providers</a></li>
</ul>
</li>
<li><a href="#Security">The <code>Security</code> Class</a></li>
<li><a href="#SecureRandom">The <code>SecureRandom</code>
Class</a></li>
<li><a href="#MessageDigest">The <code>MessageDigest</code>
Class</a></li>
<li><a href="#Signature">The <code>Signature</code> Class</a></li>
<li><a href="#Cipher">The <code>Cipher</code> Class</a></li>
<li><a href="#CipherBased">Other <code>Cipher</code>-based
Classes</a>
<ul>
<li><a href="#CipherStream">The Cipher Stream Classes</a>
<ul>
<li><a href="#CipherInput">The <code>CipherInputStream</code>
Class</a></li>
<li><a href="#CipherOutput">The <code>CipherOutputStream</code>
Class</a></li>
</ul>
</li>
<li><a href="#SealedObject">The <code>SealedObject</code>
Class</a></li>
</ul>
</li>
<li><a href="#Mac">The <code>Mac</code> Class</a></li>
<li><a href="#Key"><code>Key</code> Interfaces</a></li>
<li><a href="#KeyPair">The <code>KeyPair</code> Class</a></li>
<li><a href="#KeySpecs"><code>Key</code> Specification Interfaces
and Classes</a>
<ul>
<li><a href="#KeySpec">The <code>KeySpec</code> Interface</a></li>
<li><a href="#KeySpecSubs">The <code>KeySpec</code>
Subinterfaces</a></li>
<li><a href="#EncodedKeySpec">The <code>EncodedKeySpec</code>
Class</a>
<ul>
<li><a href="#PKCS8EncodedKeySpec">The
<code>PKCS8EncodedKeySpec</code> Class</a></li>
<li><a href="#X509EncodedKeySpec">The
<code>X509EncodedKeySpec</code> Class</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#GeneratorFactory">Of Factories and
Generators</a></li>
<li><a href="#KeyFactory">The <code>KeyFactory</code>
Class</a></li>
<li><a href="#SecretKeyFactory">The <code>SecretKeyFactory</code>
Class</a></li>
<li><a href="#KeyPairGenerator">The <code>KeyPairGenerator</code>
Class</a></li>
<li><a href="#KeyGenerator">The <code>KeyGenerator</code>
Class</a></li>
<li><a href="#KeyAgreement">The <code>KeyAgreement</code>
Class</a></li>
<li><a href="#KeyManagement">Key Management</a>
<ul>
<li><a href="#KeystoreLocation">Keystore Location</a></li>
<li><a href="#KeystoreImplementation">Keystore
Implementation</a></li>
<li><a href="#KeyStore">The <code>KeyStore</code> Class</a></li>
</ul>
</li>
<li><a href="#AlgSpec">Algorithm Parameters Classes</a>
<ul>
<li><a href="#AlgorithmParameterSpec">The
<code>AlgorithmParameterSpec</code> Interface</a></li>
<li><a href="#AlgorithmParameters">The
<code>AlgorithmParameters</code> Class</a></li>
<li><a href="#AlgorithmParameterGenerator">The
<code>AlgorithmParameterGenerator</code> Class</a></li>
</ul>
</li>
<li><a href="#CertificateFactory">The
<code>CertificateFactory</code> Class</a></li>
</ul>
</li>
<li><a href="#SSLTLS">How the JCA Might Be Used in a SSL/TLS
Implementation</a></li>
<li><a href="#ExemptApps">How to Make Applications "Exempt" from
Cryptographic Restrictions</a></li>
<li><a href="#Examples">Code Examples</a>
<ul>
<li><a href="#MDEx">Computing a <code>MessageDigest</code>
Object</a></li>
<li><a href="#KPGEx">Generating a Pair of Keys</a></li>
<li><a href="#SigEx">Generating and Verifying a Signature Using
Generated Keys</a></li>
<li><a href="#KeyFactoryEx">Generating/Verifying Signatures Using
<code>Key</code> Specifications and
<code>KeyFactory</code></a></li>
<li><a href="#Equal">Determining If Two Keys Are Equal</a></li>
<li><a href="#ReadCert">Reading Base64-Encoded
Certificates</a></li>
<li><a href="#ParseCert">Parsing a Certificate Reply</a></li>
<li><a href="#SimpleEncrEx">Using Encryption</a></li>
<li><a href="#PBEEx">Using Password-Based Encryption</a></li>
<li><a href="#KeyAgreeEx">Using Key Agreement</a></li>
</ul>
</li>
<li><a href="#AppA">Appendix A: Standard Names</a></li>
<li><a href="#AppB">Appendix B: Jurisdiction Policy File
Format</a></li>
<li><a href="#AppC">Appendix C: Maximum Key Sizes Allowed by
"Strong" Jurisdiction Policy Files</a></li>
<li><a href="#AppD">Appendix D: Sample Programs</a>
<ul>
<li><a href="#DH2Ex">Diffie-Hellman Key Exchange between 2
Parties</a></li>
<li><a href="#DH3Ex">Diffie-Hellman Key Exchange between 3
Parties</a></li>
<li><a href="#BlowKeyEx">Blowfish Cipher Example</a></li>
<li><a href="#HmacEx">HMAC-MD5 Example</a></li>
<li><a href="#ReadPassword">Reading ASCII Passwords From an
InputStream Example</a></li>
</ul>
</li>
</ul>
<a name="javasemaincontent" id="javasemaincontent"></a>
<h2><a name="Introduction" id="Introduction">Introduction</a></h2>
<p>The Java platform strongly emphasizes security, including
language safety, cryptography, public key infrastructure,
authentication, secure communication, and access control.</p>
<p>The JCA is a major piece of the platform, and contains a
"provider" architecture and a set of APIs for digital signatures,
message digests (hashes), certificates and certificate validation,
encryption (symmetric/asymmetric block/stream ciphers), key
generation and management, and secure random number generation, to
name a few. These APIs allow developers to easily integrate
security into their application code. The architecture was designed
around the following principles:</p>
<ul>
<li>
<p><b>Implementation independence</b>: Applications do not need to
implement security algorithms. Rather, they can request security
services from the Java platform. Security services are implemented
in providers (see below), which are plugged into the Java platform
via a standard interface. An application may rely on multiple
independent providers for security functionality.</p>
</li>
<li>
<p><b>Implementation interoperability</b>: Providers are
interoperable across applications. Specifically, an application is
not bound to a specific provider, and a provider is not bound to a
specific application.</p>
</li>
<li>
<p><b>Algorithm extensibility</b>: The Java platform includes a
number of built-in providers that implement a basic set of security
services that are widely used today. However, some applications may
rely on emerging standards not yet implemented, or on proprietary
services. The Java platform supports the installation of custom
providers that implement such services.</p>
</li>
</ul>
<p>Other cryptographic communication libraries available in the JDK
use the JCA provider architecture, but are described elsewhere. The
<a href="../jsse/JSSERefGuide.html">Java Secure Socket Extension
(JSSE)</a> provides access to Secure Socket Layer (SSL) and
Transport Layer Security (TLS) implementations. The <a href=
"../jgss/tutorials/index.html">Java Generic Security Services
(JGSS)</a> (via Kerberos) APIs, and the <a href=
"../sasl/sasl-refguide.html">Simple Authentication and Security
Layer (SASL)</a> can also be used for securely exchanging messages
between communicating applications.</p>
<p><a name="Terminology" id="Terminology"><strong>Notes on
Terminology</strong></a></p>
<ul>
<li>
<p>Prior to JDK 1.4, the JCE was an unbundled product, and as such,
the JCA and JCE were regularly referred to as separate, distinct
components. As JCE is now bundled in the JDK, the distinction is
becoming less apparent. Since the JCE uses the same architecture as
the JCA, the JCE should be more properly thought of as a part of
the JCA.</p>
</li>
<li>
<p>The JCA within the JDK includes two software components:</p>
<ol>
<li>the framework that defines and supports cryptographic services
for which providers supply implementations. This framework includes
packages such as <code>java.security</code>,
<code>javax.crypto</code>, <code>javax.crypto.spec</code>, and
<code>javax.crypto.interfaces</code>.</li>
<li>the actual providers such as <code>Sun</code>,
<code>SunRsaSign</code>, <code>SunJCE</code>, which contain the
actual cryptographic implementations.</li>
</ol>
<p>Whenever a specific JCA provider is mentioned, it will be
referred to explicitly by the provider's name.</p>
</li>
</ul>
<hr />
<p><b>WARNING: The JCA makes it easy to incorporate security
features into your application. However, this document does not
cover the theory of security/cryptography beyond an elementary
introduction to concepts necessary to discuss the APIs. This
document also does not cover the strengths/weaknesses of specific
algorithms, not does it cover protocol design. Cryptography is an
advanced topic and one should consult a solid, preferably recent,
reference in order to make best use of these tools.</b></p>
<p><b>You should always understand what you are doing and why: DO
NOT simply copy random code and expect it to fully solve your usage
scenario. Many applications have been deployed that contain
significant security or performance problems because the wrong tool
or algorithm was selected.</b></p>
<hr />
<h2><a name="Design" id="Design">Design Principles</a></h2>
<p>The JCA was designed around these principles:</p>
<ul>
<li>implementation independence and interoperability</li>
<li>algorithm independence and extensibility</li>
</ul>
<p>Implementation independence and algorithm independence are
complementary; you can use cryptographic services, such as digital
signatures and message digests, without worrying about the
implementation details or even the algorithms that form the basis
for these concepts. While complete algorithm-independence is not
possible, the JCA provides standardized, algorithm-specific APIs.
When implementation-independence is not desirable, the JCA lets
developers indicate a specific implementation.</p>
<p>Algorithm independence is achieved by defining types of
cryptographic "engines" (services), and defining classes that
provide the functionality of these cryptographic engines. These
classes are called <i>engine classes</i>, and examples are the
<a href="#MessageDigest"><code>MessageDigest</code></a>, <a href=
"#Signature"><code>Signature</code></a>, <a href=
"#KeyFactory"><code>KeyFactory</code></a>, <a href=
"#KeyPairGenerator"><code>KeyPairGenerator</code></a>, and <a href=
"#Cipher"><code>Cipher</code></a> classes.</p>
<p>Implementation independence is achieved using a "provider"-based
architecture. The term <a href="#ProviderArch">Cryptographic
Service Provider (CSP)</a> (used interchangeably with "provider" in
this document) refers to a package or set of packages that
implement one or more cryptographic services, such as digital
signature algorithms, message digest algorithms, and key conversion
services. A program may simply request a particular type of object
(such as a <code>Signature</code> object) implementing a particular
service (such as the DSA signature algorithm) and get an
implementation from one of the installed providers. If desired, a
program may instead request an implementation from a specific
provider. Providers may be updated transparently to the
application, for example when faster or more secure versions are
available.</p>
<p>Implementation interoperability means that various
implementations can work with each other, use each other's keys, or
verify each other's signatures. This would mean, for example, that
for the same algorithms, a key generated by one provider would be
usable by another, and a signature generated by one provider would
be verifiable by another.</p>
<p>Algorithm extensibility means that new algorithms that fit in
one of the supported engine classes can be added easily.</p>
<h2><a name="Architecture" id="Architecture">Architecture</a></h2>
<h3><a name="ProviderArch" id="ProviderArch">Cryptographic Service
Providers</a></h3>
<p><code>java.security.Provider</code> is the base class for all
security providers. Each CSP contains an instance of this class
which contains the provider's name and lists all of the security
services/algorithms it implements. When an instance of a particular
algorithm is needed, the JCA framework consults the provider's
database, and if a suitable match is found, the instance is
created.</p>
<p>Providers contain a package (or a set of packages) that supply
concrete implementations for the advertised cryptographic
algorithms. Each JDK installation has one or more providers
installed and configured by default. Additional providers may be
added statically or dynamically (see the <a href=
"#Provider">Provider</a> and <a href="#Security">Security</a>
classes). Clients may configure their runtime environment to
specify the provider <i>preference order</i>. The preference order
is the order in which providers are searched for requested services
when no specific provider is requested.</p>
<p>To use the JCA, an application simply requests a particular type
of object (such as a <code>MessageDigest</code>) and a particular
algorithm or service (such as the "MD5" algorithm), and gets an
implementation from one of the installed providers. Alternatively,
the program can request the objects from a specific provider. Each
provider has a name used to refer to it.</p>
<pre class="codeblock">
    md = MessageDigest.getInstance("MD5");
    md = MessageDigest.getInstance("MD5", "ProviderC");
</pre>
<p>The following figure illustrates requesting an "MD5" message
digest implementation. The figure show three different providers
that implement various message digest algorithms ("SHA-1", "MD5",
"SHA-256", and "SHA-512"). The providers are ordered by preference
from left to right (1-3). In the first illustration, an application
requests an MD5 algorithm implementation <b>without</b> specifying
a provider name. The providers are searched in preference order and
the implementation from the first provider supplying that
particular algorithm, ProviderB, is returned. In the second figure,
the application requests the MD5 algorithm implementation <b>from a
specific provider</b>, ProviderC. This time the implementation from
ProviderC is returned, even though a provider with a higher
preference order, ProviderB, also supplies an MD5
implementation.</p>
<a name="md5-message-digest-implementation_image" id=
"md5-message-digest-implementation_image"></a> <img src=
"../images/jca/Overview.gif" alt=
"MD5 Message Digest Implementation" />
<p><a href="img_text/Overview.html">Description of Figure MD5
Message Digest Implementation</a></p>
<p>Cryptographic implementations in the JDK are distributed via
several different providers (<code>Sun</code>,
<code>SunJSSE</code>, <code>SunJCE</code>, <code>SunRsaSign</code>)
primarily for historical reasons, but to a lesser extent by the
type of functionality and algorithms they provide. Other Java
runtime environments may not necessarily contain these Sun
providers, so applications should not request an provider-specific
implementation unless it is known that a particular provider will
be available.</p>
<p>The JCA offers a set of APIs that allow users to query which
providers are installed and what services they support.</p>
<p>This architecture also makes it easy for end-users to add
additional providers. Many third party provider implementations are
already available. See <a href="#Provider">The
<code>Provider</code> Class</a> for more information on how
providers are written, installed, and registered.</p>
<h3>How Providers Are Actually Implemented</h3>
<p>As mentioned earlier, <i>algorithm independence</i> is achieved
by defining a generic high-level Application Programming Interface
(API) that all applications use to access a service type.
<i>Implementation independence</i> is achieved by having all
provider implementations conform to well-defined interfaces.
Instances of engine classes are thus "backed" by implementation
classes which have the same method signatures. Application calls
are routed through the engine class and are delivered to the
underlying backing implementation. The implementation handles the
request and return the proper results.</p>
<p>The application API methods in each engine class are routed to
the provider's implementations through classes that implement the
corresponding Service Provider Interface (SPI). That is, for each
engine class, there is a corresponding abstract SPI class which
defines the methods that each cryptographic service provider's
algorithm must implement. The name of each SPI class is the same as
that of the corresponding engine class, followed by
<code>Spi</code>. For example, the <code>Signature</code> engine
class provides access to the functionality of a digital signature
algorithm. The actual provider implementation is supplied in a
subclass of <code>SignatureSpi</code>. Applications call the engine
class' API methods, which in turn call the SPI methods in the
actual implementation.</p>
<p>Each SPI class is abstract. To supply the implementation of a
particular type of service for a specific algorithm, a provider
must subclass the corresponding SPI class and provide
implementations for all the abstract methods.</p>
<p>For each engine class in the API, implementation instances are
requested and instantiated by calling the
<code>getInstance()</code> <i>factory method</i> in the engine
class. A factory method is a static method that returns an instance
of a class. The engine classes use the framework provider selection
mechanism described above to obtain the actual backing
implementation (SPI), and then creates the actual engine object.
Each instance of the engine class encapsulates (as a private field)
the instance of the corresponding SPI class, known as the SPI
object. All API methods of an API object are declared final and
their implementations invoke the corresponding SPI methods of the
encapsulated SPI object.</p>
<p>To make this clearer, review the following code and
illustration:</p>
<pre class="codeblock">
    import javax.crypto.*;

    Cipher c = Cipher.getInstance("AES");
    c.init(ENCRYPT_MODE, key);
</pre>
<a name=
"example-of-how-application-retrieves-aes-cipher-intstance_image"
id=
"example-of-how-application-retrieves-aes-cipher-intstance_image"></a>
<img src="../images/jca/ArchDesignPrincipals.gif" alt=
"Example of How Application Retrieves AES Cipher Intstance" />
<p><a href="img_text/ArchDesignPrincipals.html">Description of
Example of How Application Retrieves "AES" Cipher Instance</a></p>
<p>Here an application wants an "AES"
<code>javax.crypto.Cipher</code> instance, and doesn't care which
provider is used. The application calls the
<code>getInstance()</code> factory methods of the
<code>Cipher</code> engine class, which in turn asks the JCA
framework to find the first provider instance that supports "AES".
The framework consults each installed provider, and obtains the
provider's instance of the <code>Provider</code> class. (Recall
that the <code>Provider</code> class is a database of available
algorithms.) The framework searches each provider, finally finding
a suitable entry in CSP3. This database entry points to the
implementation class <code>com.foo.AESCipher</code> which extends
<code>CipherSpi</code>, and is thus suitable for use by the
<code>Cipher</code> engine class. An instance of
<code>com.foo.AESCipher</code> is created, and is encapsulated in a
newly-created instance of <code>javax.crypto.Cipher</code>, which
is returned to the application. When the application now does the
<code>init()</code> operation on the <code>Cipher</code> instance,
the <code>Cipher</code> engine class routes the request into the
corresponding <code>engineInit()</code> backing method in the
<code>com.foo.AESCipher</code> class.</p>
<p><a href="#AppA">Appendix A</a> lists the Standard Names defined
for the Java environment. Other third-party providers may define
their own implementations of these services, or even additional
services.</p>
<h3>Key Management</h3>
<p>A database called a "keystore" can be used to manage a
repository of keys and certificates. Keystores are available to
applications that need data for authentication, encryption, or
signing purposes.</p>
<p>Applications can access a keystore via an implementation of the
<code>KeyStore</code> class, which is in the
<code>java.security</code> package. A default <code>KeyStore</code>
implementation is provided by Sun Microsystems. It implements the
keystore as a file, using a proprietary keystore type (format)
named "jks". Other keystore formats are available, such as "jceks"
which is an alternate proprietary keystore format with much
stronger encryption than "jks", and "pkcs12", which is based on the
RSA <a href=
"http://www.emc.com/emc-plus/rsa-labs/standards-initiatives/pkcs12-personal-information-exchange-syntax-standard.htm">
PKCS12 Personal Information Exchange Syntax Standard</a>.</p>
<p>Applications can choose different keystore implementations from
different providers, using the same provider mechanism described
above.</p>
<p>See the <a href="#KeyManagement">Key Management</a> section for
more information.</p>
<h2><a name="Concepts" id="Concepts">JCA Concepts</a></h2>
<p>This section introduces the major JCA APIs.</p>
<h3><a name="Engine" id="Engine">Engine Classes and
Algorithms</a></h3>
<p>An engine class provides the interface to a specific type of
cryptographic service, independent of a particular cryptographic
algorithm or provider. The engines either provide:</p>
<ul>
<li>cryptographic operations (encryption, digital signatures,
message digests, etc.),</li>
<li>generators or converters of cryptographic material (keys and
algorithm parameters), or</li>
<li>objects (keystores or certificates) that encapsulate the
cryptographic data and can be used at higher layers of
abstraction.</li>
</ul>
<p>The following engine classes are available:</p>
<ul>
<li><a href="#SecureRandom"><code>SecureRandom</code></a>: used to
generate random or pseudo-random numbers.</li>
<li><a href="#MessageDigest"><code>MessageDigest</code></a>: used
to calculate the message digest (hash) of specified data.</li>
<li><a href="#Signature"><code>Signature</code></a>: initialized
with keys, these are used to sign data and verify digital
signatures.</li>
<li><a href="#Cipher"><code>Cipher</code></a>: initialized with
keys, these used for encrypting/decrypting data. There are various
types of algorithms: symmetric bulk encryption (e.g. AES, DES,
DESede, Blowfish, IDEA), stream encryption (e.g. RC4), asymmetric
encryption (e.g. RSA), and password-based encryption (PBE).</li>
<li><a href="#Mac">Message Authentication Codes (MAC)</a>: like
<code>MessageDigest</code>s, these also generate hash values, but
are first initialized with keys to protect the integrity of
messages.</li>
<li><a href="#KeyFactory"><code>KeyFactory</code></a>: used to
convert existing opaque cryptographic keys of type <a href=
"#Key"><code>Key</code></a> into key specifications (transparent
representations of the underlying key material), and vice
versa.</li>
<li><a href="#SecretKeyFactory"><code>SecretKeyFactory</code></a>:
used to convert existing opaque cryptographic keys of type <a href=
"#Key"><code>SecretKey</code></a> into key specifications
(transparent representations of the underlying key material), and
vice versa. <code>SecretKeyFactory</code>s are specialized
<code>KeyFactory</code>s that create secret (symmetric) keys
only.</li>
<li><a href="#KeyPairGenerator"><code>KeyPairGenerator</code></a>:
used to generate a new pair of public and private keys suitable for
use with a specified algorithm.</li>
<li><a href="#KeyGenerator"><code>KeyGenerator</code></a>: used to
generate new secret keys for use with a specified algorithm.</li>
<li><a href="#KeyAgreement"><code>KeyAgreement</code></a>: used by
two or more parties to agree upon and establish a specific key to
use for a particular cryptographic operation.</li>
<li><a href=
"#AlgorithmParameters"><code>AlgorithmParameters</code></a>: used
to store the parameters for a particular algorithm, including
parameter encoding and decoding.</li>
<li><a href=
"#AlgorithmParameterGenerator"><code>AlgorithmParameterGenerator</code></a>
: used to generate a set of AlgorithmParameters suitable for a
specified algorithm.</li>
<li><a href="#KeyStore"><code>KeyStore</code></a>: used to create
and manage a <i>keystore</i>. A keystore is a database of keys.
Private keys in a keystore have a certificate chain associated with
them, which authenticates the corresponding public key. A keystore
also contains certificates from trusted entities.</li>
<li><a href=
"#CertificateFactory"><code>CertificateFactory</code></a>: used to
create public key certificates and Certificate Revocation Lists
(CRLs).</li>
<li><a href=
"../certpath/CertPathProgGuide.html"><code>CertPathBuilder</code></a>:
used to build certificate chains (also known as certification
paths).</li>
<li><a href=
"../certpath/CertPathProgGuide.html"><code>CertPathValidator</code></a>:
used to validate certificate chains.</li>
<li><a href=
"../certpath/CertPathProgGuide.html"><code>CertStore</code></a>:
used to retrieve <code>Certificate</code>s and <code>CRL</code>s
from a repository.</li>
</ul>
<p><b>NOTE:</b> A <i>generator</i> creates objects with brand-new
contents, whereas a <i>factory</i> creates objects from existing
material (for example, an encoding).</p>
<h2><a name="CoreClasses" id="CoreClasses">Core Classes and
Interfaces</a></h2>
<p>This section discusses the core classes and interfaces provided
in the JCA:</p>
<ul>
<li>the <a href="#Provider"><code>Provider</code></a> and <a href=
"#Security"><code>Security</code></a> classes,</li>
<li>the <a href="#SecureRandom"><code>SecureRandom</code></a>,
<a href="#MessageDigest"><code>MessageDigest</code></a>, <a href=
"#Signature"><code>Signature</code></a>, <a href=
"#Cipher"><code>Cipher</code></a>, <a href=
"#Mac"><code>Mac</code></a>, <a href=
"#KeyFactory"><code>KeyFactory</code></a>, <a href=
"#SecretKeyFactory"><code>SecretKeyFactory</code></a>, <a href=
"#KeyPairGenerator"><code>KeyPairGenerator</code></a>, <a href=
"#KeyGenerator"><code>KeyGenerator</code></a>, <a href=
"#KeyAgreement"><code>KeyAgreement</code></a>, <a href=
"#AlgorithmParameters"><code>AlgorithmParameters</code></a>,
<a href=
"#AlgorithmParameterGenerator"><code>AlgorithmParameterGenerator</code></a>
, <a href="#KeyStore"><code>KeyStore</code></a>, and <a href=
"#CertificateFactory"><code>CertificateFactory</code></a>, engine
classes,</li>
<li>the <a href="#Key"><code>Key</code></a> interfaces and
classes,</li>
<li>the <a href="#AlgSpec">Algorithm Parameter Specification
Interfaces and Classes</a> and the <a href="#KeySpecs">Key
Specification Interfaces and Classes</a>, and</li>
<li>miscellaneous support and convenience interfaces and
classes.</li>
</ul>
<hr />
<p><b>NOTE:</b> For more information on the <a href=
"../../../../api/java/security/cert/CertPathBuilder.html"><code>CertPathBuilder</code></a>,
<a href=
"../../../../api/java/security/cert/CertPathValidator.html"><code>CertPathValidator</code></a>,
and <a href=
"../../../../api/java/security/cert/CertStore.html"><code>CertStore</code></a>
engine classes, please see the <a href=
"../certpath/CertPathProgGuide.html">Java PKI Programmer's
Guide</a>.</p>
<hr />
<p>The guide will cover the most useful high-level classes first
(<code>Provider</code>, <code>Security</code>,
<code>SecureRandom</code>, <code>MessageDigest</code>,
<code>Signature</code>, <code>Cipher</code>, and <code>Mac</code>),
then delve into the various support classes. For now, it is
sufficient to simply say that Keys (public, private, and secret)
are generated and represented by the various JCA classes, and are
used by the high-level classes as part of their operation.</p>
<p>This section shows the signatures of the main methods in each
class and interface. Examples for some of these classes
(<code>MessageDigest</code>, <code>Signature</code>,
<code>KeyPairGenerator</code>, <code>SecureRandom</code>,
<code>KeyFactory</code>, and key specification classes) are
supplied in the corresponding <a href="#Examples">Examples</a>
sections.</p>
<p>The complete reference documentation for the relevant Security
API packages can be found in the package summaries:</p>
<ul>
<li><a href=
"../../../../api/java/security/package-summary.html"><code>java.security</code></a></li>
<li><a href=
"../../../../api/javax/crypto/package-summary.html"><code>javax.crypto</code></a></li>
<li><a href=
"../../../../api/java/security/cert/package-summary.html"><code>java.security.cert</code></a></li>
<li><a href=
"../../../../api/java/security/spec/package-summary.html"><code>java.security.spec</code></a></li>
<li><a href=
"../../../../api/javax/crypto/spec/package-summary.html"><code>javax.crypto.spec</code></a></li>
<li><a href=
"../../../../api/java/security/interfaces/package-summary.html"><code>
java.security.interfaces</code></a></li>
<li><a href=
"../../../../api/javax/crypto/interfaces/package-summary.html"><code>
javax.crypto.interfaces</code></a></li>
</ul>
<h2><a name="Provider" id="Provider">The <code>Provider</code>
Class</a></h2>
<p>The term "Cryptographic Service Provider" (used interchangeably
with "provider" in this document) refers to a package or set of
packages that supply a concrete implementation of a subset of the
JDK Security API cryptography features. The <code>Provider</code>
<em>class</em> is the interface to such a package or set of
packages. It has methods for accessing the provider name, version
number, and other information. Please note that in addition to
registering implementations of cryptographic services, the
<code>Provider</code> class can also be used to register
implementations of other security services that might get defined
as part of the JDK Security API or one of its extensions.</p>
<p>To supply implementations of cryptographic services, an entity
(e.g., a development group) writes the implementation code and
creates a subclass of the <code>Provider</code> class. The
constructor of the <code>Provider</code> subclass sets the values
of various properties; the JDK Security API uses these values to
look up the services that the provider implements. In other words,
the subclass specifies the names of the classes implementing the
services.</p>
<a name="example-of-provider-subclass_image" id=
"example-of-provider-subclass_image"></a> <img src=
"../images/jca/Provider.gif" alt="Example of Provider Subclass" />
<p><a href="img_text/Provider.html">Description of Figure Example
of Provider Subclass</a></p>
<p>There are several types of services that can be implemented by
provider packages; for more information, see <a href=
"#Engine">Engine Classes and Algorithms</a>.</p>
<p>The different implementations may have different
characteristics. Some may be software-based, while others may be
hardware-based. Some may be platform-independent, while others may
be platform-specific. Some provider source code may be available
for review and evaluation, while some may not. The JCA lets both
end-users and developers decide what their needs are.</p>
<p>In this section we explain how end-users install the
cryptography implementations that fit their needs, and how
developers request the implementations that fit theirs.</p>
<p><b>NOTE:</b> For information about implementing a provider, see
the guide <a href="HowToImplAProvider.html">How To Implement a
Provider for the Java Cryptography Architecture</a>.</p>
<h3><a name="ProviderImplReq" id="ProviderImplReq">How Provider
Implementations Are Requested and Supplied</a></h3>
<p>For each <a href="#Engine">engine class</a> in the API, a
implementation instance is requested and instantiated by calling
one of the <code>getInstance</code> methods on the engine class,
specifying the name of the desired algorithm and, optionally, the
name of the provider (or the <code>Provider</code> class) whose
implementation is desired.</p>
<pre class="codeblock">
static <i>EngineClassName</i> getInstance(String algorithm)
    throws NoSuchAlgorithmException

static <i>EngineClassName</i> getInstance(String algorithm, String provider)
    throws NoSuchAlgorithmException, NoSuchProviderException

static <i>EngineClassName</i> getInstance(String algorithm, Provider provider)
    throws NoSuchAlgorithmException
</pre>
where <i>EngineClassName</i> is the desired engine type
(MessageDigest/Cipher/etc). For example:
<pre class="codeblock">
    MessageDigest md = MessageDigest.getInstance("MD5");
    KeyAgreement ka = KeyAgreement.getInstance("DH", "SunJCE");
</pre>
return an instance of the "MD5" MessageDigest and "DH" KeyAgreement
objects, respectively.
<p><a href="#AppA">Appendix A</a> contains the list of names that
have been standardized for use with the Java environment. Some
providers may choose to also include alias names that also refer to
the same algorithm. For example, the "SHA-1" algorithm might be
referred to as "SHA1". Applications should use standard names
instead of an alias, as not all providers may alias algorithm names
in the same way.</p>
<p><b>NOTE:</b> The algorithm name is not case-sensitive. For
example, all the following calls are equivalent:</p>
<pre class="codeblock">
MessageDigest.getInstance("SHA-1")
MessageDigest.getInstance("sha-1")
MessageDigest.getInstance("sHa-1")
</pre>
<p>If no provider is specified, <code>getInstance</code> searches
the registered providers for an implementation of the requested
cryptographic service associated with the named algorithm. In any
given Java Virtual Machine (JVM), providers are <a href=
"#ProviderInstalling">installed</a> in a given <i>preference
order</i>, the order in which the provider list is searched if a
specific provider is not requested. For example, suppose there are
two providers installed in a JVM, <code>PROVIDER_1</code> and
<code>PROVIDER_2</code>. Assume that:</p>
<ul>
<li><code>PROVIDER_1</code> implements SHA1withDSA, SHA-1, MD5,
DES, and DES3.<br />
<code>PROVIDER_1</code> has preference order 1 (the highest
priority).</li>
<li><code>PROVIDER_2</code> implements SHA1withDSA, MD5withRSA,
MD2withRSA, MD2, MD5, RC4, RC5, DES, and RSA.<br />
<code>PROVIDER_2</code> has preference order 2.</li>
</ul>
Now let's look at three scenarios:
<ol>
<li>If we are looking for an MD5 implementation. Both providers
supply such an implementation. The <code>PROVIDER_1</code>
implementation is returned since <code>PROVIDER_1</code> has the
highest priority and is searched first.</li>
<li>If we are looking for an MD5withRSA signature algorithm,
<code>PROVIDER_1</code> is first searched for it. No implementation
is found, so <code>PROVIDER_2</code> is searched. Since an
implementation is found, it is returned.</li>
<li>Suppose we are looking for a SHA1withRSA signature algorithm.
Since no installed provider implements it, a
<code>NoSuchAlgorithmException</code> is thrown.</li>
</ol>
<p>The <code>getInstance</code> methods that include a provider
argument are for developers who want to specify which provider they
want an algorithm from. A federal agency, for example, will want to
use a provider implementation that has received federal
certification. Let's assume that the SHA1withDSA implementation
from <code>PROVIDER_1</code> has not received such certification,
while the DSA implementation of <code>PROVIDER_2</code> has
received it.</p>
<p>A federal agency program would then have the following call,
specifying <code>PROVIDER_2</code> since it has the certified
implementation:</p>
<pre class="codeblock">
Signature dsa = Signature.getInstance("SHA1withDSA", "PROVIDER_2");
</pre>
<p>In this case, if <code>PROVIDER_2</code> was not installed, a
<code>NoSuchProviderException</code> would be thrown, even if
another installed provider implements the algorithm requested.</p>
<p>A program also has the option of getting a list of all the
installed providers (using the <code>getProviders</code> method in
the <a href="#Security"><code>Security</code></a> class) and
choosing one from the list.</p>
<p><b>NOTE:</b> General purpose applications <b>SHOULD NOT</b>
request cryptographic services from specific providers. Otherwise,
applications are tied to specific providers which may not be
available on other Java implementations. They also might not be
able to take advantage of available optimized providers (for
example hardware accelerators via PKCS11 or native OS
implementations such as Microsoft's MSCAPI) that have a higher
preference order than the specific requested provider.</p>
<h3><a name="ProviderInstalling" id="ProviderInstalling">Installing
Providers</a></h3>
<p>In order to be used, a cryptographic provider must first be
installed, then registered either statically or dynamically. There
are a variety of Sun providers shipped with this release
(<code>SUN</code>, <code>SunJCE</code>, <code>SunJSSE</code>,
<code>SunRsaSign</code>, etc.) that are already installed and
registered. The following sections describe how to install and
register additional providers.</p>
<h4>Installing the Provider Classes</h4>
<p>There are two possible ways to install the provider classes:</p>
<ol>
<li><b>On the normal Java classpath</b>
<p>Place a zip or JAR file containing the classes anywhere in your
classpath. Some algorithms types (Ciphers) require the provider be
a signed Jar file.</p>
</li>
<li><b>As an Installed/Bundled Extension</b>
<p>The provider will be considered an <em>installed</em> extension
if it is placed in the standard extension directory. In the JDK,
that would be located in:</p>
<ul>
<li>Solaris, Linux, or Mac OS X:
<code>&lt;java-home&gt;/lib/ext</code></li>
<li>Windows: <code>&lt;java-home&gt;\lib\ext</code></li>
</ul>
<p>Here <tt>&lt;java-home&gt;</tt> refers to the directory where
the runtime software is installed, which is the top-level directory
of the Java Runtime Environment (JRE) or the <tt>jre</tt> directory
in the Java JDK software. For example, if you have JDK 6 installed
on Solaris in a directory named <code>/home/user1/JDK1.6.0</code>,
or on Microsoft Windows in a directory named
<code>C:\Java\JDK1.6.0</code>, then you need to install the JAR
file in the following directory:</p>
<ul>
<li>Solaris, Linux, or Mac OS X:
<code>/home/user1/JDK1.6.0/jre/lib/ext</code></li>
<li>Windows: <code>C:\JDK1.6.0\jre\lib\ext</code></li>
</ul>
<p>Similarly, if you have the JRE 6 installed on Solaris in a
directory named <code>/home/user1/jre1.6.0</code>, or on Microsoft
Windows in a directory named <code>C:\jre1.6.0</code>, you need to
install the JAR file in the following directory:</p>
<ul>
<li>Solaris, Linux, or Mac OS X:
<code>/home/user1/jre1.6.0/lib/ext</code></li>
<li>Windows: <code>C:\jre1.6.0\lib\ext</code></li>
</ul>
For more information on how to deploy an extension, see <a href=
"../../extensions/spec.html#deployment">How is an extension
deployed?</a></li>
</ol>
<h4>Registering the Provider</h4>
<p>The next step is to add the provider to your list of registered
providers. Providers can be registered statically by editing a
security properties configuration file before running a Java
application, or dynamically by calling a method at runtime. To
prevent the installation of rogue providers being added to the
runtime environment, applications attempting to dynamically
register a provider must possess the appropriate runtime
privilege.</p>
<h5>Static Registration</h5>
<p>The configuration file is located in the following location:</p>
<ul>
<li>Solaris, Linux, or Mac OS X:
<code>&lt;java-home&gt;/lib/security/java.security</code></li>
<li>Windows:
<code>&lt;java-home&gt;\lib\security\java.security</code></li>
</ul>
<p>For each registered provider, this file should have a statement
of the following form:</p>
<pre class="codeblock">
    security.provider.<i>n</i>=<i>masterClassName</i>
</pre>
<p>This declares a provider, and specifies its preference order
<i>n</i>. The preference order is the order in which providers are
searched for requested algorithms (when no specific provider is
requested). The order is 1-based: 1 is the most preferred, followed
by 2, and so on.</p>
<p><i><code>masterClassName</code></i> must specify the fully
qualified name of provider's master class. The provider's
documentation will specify its master class. This class is always a
subclass of the <code>Provider</code> class. The subclass
constructor sets the values of various properties that are required
for the Java Cryptography API to look up the algorithms or other
facilities the provider implements.</p>
<p>The JDK comes standard with automatically installed and
configured providers such as "SUN" and "SunJCE". The "SUN"
provider's master class is the <code>SUN</code> class in the
<code>sun.security.provider</code> package, and the corresponding
java.security file entry is as follows:</p>
<pre class="codeblock">
    security.provider.5=sun.security.provider.Sun
</pre>
<p>To utilize another JCA provider, add a line referencing the
alternate provider, specify the preference order ( making
corresponding adjustments to the other providers' orders, if
needed).</p>
<p>Suppose that the master class of CompanyX's provider is
<code>com.companyx.provider.ProviderX</code>, and that you would
like to configure this provider as the eighth most-preferred. To do
so, you would add the following line to the
<code>java.security</code> file:</p>
<pre class="codeblock">
    security.provider.8=com.companyx.provider.ProviderX
</pre>
<h5>Dynamic Registration</h5>
To register providers dynamically, applications call either the
<code>addProvider</code> or <code>insertProviderAt</code> method in
the <code>Security</code> class. This type of registration is not
persistent across VM instances, and can only be done by "trusted"
programs with the appropriate privilege. See <a href=
"#Security">Security</a>.
<h4><a name="SettingPerms" id="SettingPerms">Setting Provider
Permissions</a></h4>
<p>Whenever encryption providers are used (that is, those that
supply implementations of Cipher, KeyAgreement, KeyGenerator, Mac,
or SecretKeyFactory), and the provider is not an installed
extension <a href="../permissions.html">Permissions</a> may need to
be granted for when applets or applications using JCA are run while
a security manager is installed. There is typically a security
manager installed whenever an applet is running, and a security
manager may be installed for an application either via code in the
application itself or via a command-line argument. Permissions do
not need to be granted to installed extensions, since the default
system <a href="../PolicyFiles.html">policy configuration file</a>
grants all permissions to installed extensions (that is, installed
in the <a href="#ProviderInstalling">extensions directory</a>).</p>
<p>The documentation from the vendor of each provider you will be
using should include information as to which permissions it
requires, and how to grant such permissions. For example, the
following permissions may be needed by a provider if it is not an
installed extension and a security manager is installed:</p>
<ul>
<li><code>java.lang.RuntimePermission "getProtectionDomain"</code>
to get class protection domains. The provider may need to get its
own protection domain in the process of doing self-integrity
checking.</li>
<li><code>java.security.SecurityPermission
"putProviderProperty.{name}"</code> to set provider properties,
where <code>{name}</code> is replaced by the actual provider
name.</li>
</ul>
<p>For example, a sample statement granting permissions to a
provider whose name is "MyJCE" and whose code is in
<code>myjce_provider.jar</code> appears below. Such a statement
could appear in a policy file. In this example, the
<code>myjce_provider.jar</code> file is assumed to be in the
<code>/localWork</code> directory.</p>
<pre class="codeblock">
    grant codeBase "file:/localWork/myjce_provider.jar" {
        permission java.lang.RuntimePermission "getProtectionDomain";
        permission java.security.SecurityPermission
            "putProviderProperty.MyJCE";
     };
</pre>
<h3><code>Provider</code> Class Methods</h3>
<p>Each <code>Provider</code> class instance has a (currently
case-sensitive) name, a version number, and a string description of
the provider and its services. You can query the
<code>Provider</code> instance for this information by calling the
following methods:</p>
<pre class="codeblock">
public String getName()
public double getVersion()
public String getInfo()
</pre>
<h2><a name="Security" id="Security">The <code>Security</code>
Class</a></h2>
<p>The <code>Security</code> class manages installed providers and
security-wide properties. It only contains static methods and is
never instantiated. The methods for adding or removing providers,
and for setting <code>Security</code> properties, can only be
executed by a trusted program. Currently, a "trusted program" is
either</p>
<ul>
<li>a local application not running under a security manager,
or</li>
<li>an applet or application with permission to execute the
specified method (see below).</li>
</ul>
The determination that code is considered trusted to perform an
attempted action (such as adding a provider) requires that the
applet is granted the proper permission(s) for that particular
action. The policy configuration file(s) for a JDK installation
specify what permissions (which types of system resource accesses)
are allowed by code from specified code sources. (See below and the
<a href="../PolicyFiles.html">"Default Policy Implementation and
Policy File Syntax"</a> and <a href=
"../spec/security-spec.doc.html">"Java Security Architecture
Specification"</a> files for more information.)
<p>Code being executed is always considered to come from a
particular "code source". The code source includes not only the
location (URL) where the code originated from, but also a reference
to any public key(s) corresponding to the private key(s) that may
have been used to sign the code. Public keys in a code source are
referenced by (symbolic) alias names from the user's <a href=
"#KeyManagement">keystore</a>.</p>
<p>In a policy configuration file, a code source is represented by
two components: a code base (URL), and an alias name (preceded by
<code>signedBy</code>), where the alias name identifies the
keystore entry containing the public key that must be used to
verify the code's signature.</p>
<p>Each "grant" statement in such a file grants a specified code
source a set of permissions, specifying which actions are
allowed.</p>
<p>Here is a sample policy configuration file:</p>
<pre class="codeblock">
grant codeBase "file:/home/sysadmin/", signedBy "sysadmin" {
    permission java.security.SecurityPermission "insertProvider.*";
    permission java.security.SecurityPermission "removeProvider.*";
    permission java.security.SecurityPermission "putProviderProperty.*";
};
</pre>
This configuration file specifies that code loaded from a signed
JAR file from beneath the <code>/home/sysadmin/</code> directory on
the local file system can add or remove providers or set provider
properties. (Note that the signature of the JAR file can be
verified using the public key referenced by the alias name
<code>sysadmin</code> in the user's keystore.)
<p>Either component of the code source (or both) may be missing.
Here's an example of a configuration file where the
<code>codeBase</code> is omitted:</p>
<pre class="codeblock">
grant signedBy "sysadmin" {
    permission java.security.SecurityPermission "insertProvider.*";
    permission java.security.SecurityPermission "removeProvider.*";
};
</pre>
If this policy is in effect, code that comes in a JAR File signed
by <code>sysadmin</code> can add/remove providers--regardless of
where the JAR File originated.
<p>Here's an example without a signer:</p>
<pre class="codeblock">
grant codeBase "file:/home/sysadmin/" {
    permission java.security.SecurityPermission "insertProvider.*";
    permission java.security.SecurityPermission "removeProvider.*";
};
</pre>
In this case, code that comes from anywhere within the
<code>/home/sysadmin/</code> directory on the local filesystem can
add/remove providers. The code does not need to be signed.
<p>An example where neither <code>codeBase</code> nor
<code>signedBy</code> is included is:</p>
<pre class="codeblock">
grant {
    permission java.security.SecurityPermission "insertProvider.*";
    permission java.security.SecurityPermission "removeProvider.*";
};
</pre>
Here, with both code source components missing, any code
(regardless of where it originates, or whether or not it is signed,
or who signed it) can add/remove providers. Obviously, this is
definitely <b>NOT</b> recommended, as this grant could open a
security hole. Untrusted code could install a Provider, thus
affecting later code that is depending on a properly functioning
implementation. (For example, a rogue <code>Cipher</code> object
might capture and store the sensitive information it receives.)
<h3>Managing Providers</h3>
<p>The following tables summarize the methods in the
<code>Security</code> class you can use to query which
<code>Provider</code>s are installed, as well as to install or
remove providers at runtime.</p>
<strong>Querying Providers</strong>
<table summary="querying providers" width="700" border="1"
cellspacing="2" cellpadding="0">
<tr>
<th id="h1" scope="col">Method</th>
<th id="h2" scope="col">Description</th>
</tr>
<tr>
<td headers="h1"><code>static Provider[] getProviders()</code></td>
<td headers="h2">Returns an array containing all the installed providers
(technically, the <code>Provider</code> subclass for each package
provider). The order of the <code>Provider</code>s in the array is
their preference order.</td>
</tr>
<tr>
<td headers="h1"><code>static Provider getProvider<br />
(String providerName)</code></td>
<td headers="h2">Returns the <code>Provider</code> named
<code>providerName</code>. It returns <code>null</code> if the
<code>Provider</code> is not found.</td>
</tr>
</table>
<br />
<strong>Adding Providers</strong>
<table width="700" summary="adding providers" border="1"
cellspacing="2" cellpadding="0">
<tr>
<th id="h101" scope="col">Method</th>
<th id="h102" scope="col">Description</th>
</tr>
<tr>
<td headers="h101"><code>static int addProvider(Provider provider)</code></td>
<td headers="h102">Adds a <code>Provider</code> to the end of the list of
installed <code>Provider</code>s. It returns the preference
position in which the <code>Provider</code> was added, or
<code>-1</code> if the <code>Provider</code> was not added because
it was already installed.</td>
</tr>
<tr>
<td headers="h101"><code>static int insertProviderAt (Provider provider, int
position)</code></td>
<td headers="h102">Adds a new <code>Provider</code> at a specified position. If
the given provider is installed at the requested position, the
provider formerly at that position and all providers with a
position greater than <code>position</code> are shifted up one
position (towards the end of the list). This method returns the
preference position in which the <code>Provider</code> was added,
or <code>-1</code> if the <code>Provider</code> was not added
because it was already installed.</td>
</tr>
</table>
<br />
<strong>Removing Providers</strong>
<table width="700" summary="removing providers" border="1"
cellspacing="2" cellpadding="0">
<tr>
<th id="h201" scope="col">Method</th>
<th id="h202" scope="col">Description</th>
</tr>
<tr>
<td headers="h201"><code>static void removeProvider(String name)</code></td>
<td headers="h202">Removes the <code>Provider</code> with the specified name. It
returns silently if the provider is not installed. When the
specified provider is removed, all providers located at a position
greater than where the specified provider was are shifted down one
position (towards the head of the list of installed
providers).</td>
</tr>
</table>
<p><b>NOTE:</b> If you want to change the preference position of a
provider, you must first remove it, and then insert it back in at
the new preference position.</p>
<h3>Security Properties</h3>
<p>The <code>Security</code> class maintains a list of system-wide
security properties. These properties are similar to the
<code>System</code> properties, but are security-related. These
properties can be set statically or dynamically. We have already
seen an example of static security properties (that is, registering
a provider statically via the <code>"security.provider.i"</code>
security property). If you want to set properties dynamically,
trusted programs can use the following methods:</p>
<pre class="codeblock">
static String getProperty(String key)
static void setProperty(String key, String datum)
</pre>
Note: the list of security providers is established during VM
startup, therefore the methods described above must be used to
alter the provider list.
<p>As a reminder, the configuration file is located in the
following location:</p>
<ul>
<li>Solaris, Linux, or Mac OS X:
<code>&lt;java-home&gt;/lib/security/java.security</code></li>
<li>Windows:
<code>&lt;java-home&gt;\lib\security\java.security</code></li>
</ul>
<h2><a name="SecureRandom" id="SecureRandom">The
<code>SecureRandom</code> Class</a></h2>
<p>The <code>SecureRandom</code> class is an <a href=
"#Engine">engine class</a> that provides the functionality of a
Random Number Generator (RNG). It differs from the
<code>java.lang.Random</code> class in that it produces
cryptographically strong random numbers. If there is insufficient
randomness in a generator, it makes it much easier to compromise
your protection mechanisms. Random numbers are used throughout
cryptography, such as generating cryptographic keys, algorithmic
parameters, and so on.</p>
<p>All Java SE implementations must indicate the strongest (most
random) implementation of <code>SecureRandom</code> that they
provide in the <code>securerandom.strongAlgorithms</code> property
of the <code>java.security.Security</code> class. This
implementation can be used when a particularly strong random value
is required.</p>
<a name="securerandom_image" id="securerandom_image"></a> <img src=
"../images/jca/SecureRandom.gif" alt="The SecureRandom Class" />
<p><a href="img_text/SecureRandom.html">Description of The
SecureRandom Class</a></p>
<h3>Creating a <code>SecureRandom</code> Object</h3>
<p>There are several ways to obtain an instance of
<code>SecureRandom</code>:</p>
<ul>
<li>
<p>All Java SE implementations provide a default
<code>SecureRandom</code> using the no-argument constructor:
<code>new SecureRandom()</code>.</p>
</li>
<li>
<p>To get a specific implementation of <code>SecureRandom</code>,
use one of the <a href=
"#ProviderImplReq"><code>getInstance()</code> static factory
methods</a>.</p>
</li>
<li>
<p>Use the <code>getInstanceStrong()</code> method to obtain a
strong <code>SecureRandom</code> implementation as defined by the
<code>securerandom.strongAlgorithms</code> property of the
<code>java.security.Security</code> class. This property lists
platform implementations that are suitable for generating important
values.</p>
</li>
</ul>
<h3>Seeding or Re-Seeding the <code>SecureRandom</code> Object</h3>
<p>The <code>SecureRandom</code> implementation attempts to
completely randomize the internal state of the generator itself
unless the caller follows the call to a <code>getInstance</code>
method with a call to one of the <code>setSeed</code> methods:</p>
<pre class="codeblock">
synchronized public void setSeed(byte[] seed)
public void setSeed(long seed)
</pre>
<p>Once the <code>SecureRandom</code> object has been seeded, it
will produce bits as random as the original seeds.</p>
<p>At any time a <code>SecureRandom</code> object may be re-seeded
using one of the <code>setSeed</code> methods. The given seed
supplements, rather than replaces, the existing seed; therefore,
repeated calls are guaranteed never to reduce randomness.</p>
<h3>Using a <code>SecureRandom</code> Object</h3>
<p>To get random bytes, a caller simply passes an array of any
length, which is then filled with random bytes:</p>
<pre class="codeblock">
synchronized public void nextBytes(byte[] bytes)
</pre>
<h3>Generating Seed Bytes</h3>
<p>If desired, it is possible to invoke the
<code>generateSeed</code> method to generate a given number of seed
bytes (to seed other random number generators, for example):</p>
<pre class="codeblock">
byte[] generateSeed(int numBytes)
</pre>
<h2><a name="MessageDigest" id="MessageDigest">The
<code>MessageDigest</code> Class</a></h2>
<p>The <code>MessageDigest</code> class is an <a href=
"#Engine">engine class</a> designed to provide the functionality of
cryptographically secure message digests such as SHA-1 or MD5. A
cryptographically secure message digest takes arbitrary-sized input
(a byte array), and generates a fixed-size output, called a
<i>digest</i> or hash.</p>
<a name="messageDigest_image" id="messageDigest_image"></a>
<img src="../images/jca/MessageDigest.gif" alt=
"The MessageDigest Class" />
<p><a href="img_text/MessageDigest.html">Description of Figure The
MessageDigest Class</a></p>
<p>For example, the MD5 algorithm produces a 16 byte digest, and
SHA1's is 20 bytes.</p>
<p>A digest has two properties:</p>
<ul>
<li>It should be computationally infeasible to find two messages
that hash to the same value.</li>
<li>The digest should not reveal anything about the input that was
used to generate it.</li>
</ul>
<p>Message digests are used to produce unique and reliable
identifiers of data. They are sometimes called "checksums" or the
"digital fingerprints" of the data. Changes to just one bit of the
message should produce a different digest value.</p>
<p>Message digests have many uses and can determine when data has
been modified, intentionally or not. Recently, there has been
considerable effort to determine if there are any weaknesses in
popular algorithms, with mixed results. When selecting a digest
algorithm, one should always consult a recent reference to
determine its status and appropriateness for the task at hand.</p>
<h3>Creating a <code>MessageDigest</code> Object</h3>
<p>The first step for computing a digest is to create a message
digest instance. <code>MessageDigest</code> objects are obtained by
using one of the <a href=
"#ProviderImplReq"><code>getInstance()</code> static factory
methods</a> in the <code>MessageDigest</code> class. The factory
method returns an initialized message digest object. It thus does
not need further initialization.</p>
<h3>Updating a Message Digest Object</h3>
<p>The next step for calculating the digest of some data is to
supply the data to the initialized message digest object. It can be
provided all at once, or in chunks. Pieces can be fed to the
message digest by calling one of the <code>update</code>
methods:</p>
<pre class="codeblock">
void update(byte input)
void update(byte[] input)
void update(byte[] input, int offset, int len)
</pre>
<h3>Computing the Digest</h3>
<p>After the data chunks have been supplied by calls to
<code>update</code>, the digest is computed using a call to one of
the <code>digest</code> methods:</p>
<pre class="codeblock">
byte[] digest()
byte[] digest(byte[] input)
int digest(byte[] buf, int offset, int len)
</pre>
<p>The first method return the computed digest. The second method
does a final <code>update(input)</code> with the input byte array
before calling <code>digest()</code>, which returns the digest byte
array. The last method stores the computed digest in the provided
buffer <code>buf</code>, starting at <code>offset</code>.
<code>len</code> is the number of bytes in <code>buf</code>
allotted for the digest, the method returns the number of bytes
actually stored in <code>buf</code>. If there is not enough room in
the buffer, the method will throw an exception.</p>
<p>Please see the <a href="#MDEx">Computing a
<code>MessageDigest</code></a> example in the <a href=
"#Examples">Code Examples</a> section for more details.</p>
<h2><a name="Signature" id="Signature">The <code>Signature</code>
Class</a></h2>
<p>The <code>Signature</code> class is an <a href="#Engine">engine
class</a> designed to provide the functionality of a cryptographic
digital signature algorithm such as DSA or RSAwithMD5. A
cryptographically secure signature algorithm takes arbitrary-sized
input and a private key and generates a relatively short (often
fixed-size) string of bytes, called the <i>signature</i>, with the
following properties:</p>
<ul>
<li>Only the owner of a private/public key pair is able to create a
signature. It should be computationally infeasible for anyone
having a public key to recover the private key.</li>
<li>Given the public key corresponding to the private key used to
generate the signature, it should be possible to verify the
authenticity and integrity of the input.</li>
<li>The signature and the public key do not reveal anything about
the private key.</li>
</ul>
<p>It can also be used to verify whether or not an alleged
signature is in fact the authentic signature of the data associated
with it.</p>
<a name="signature_image" id="signature_image"></a> <img src=
"../images/jca/Signature.gif" alt="The Signature Class" />
<p><a href="img_text/Signature.html">Description of Figure The
Signature Class</a></p>
<p>A <code>Signature</code> object is initialized for signing with
a Private Key and is given the data to be signed. The resulting
signature bytes are typically kept with the signed data. When
verification is needed, another <code>Signature</code> object is
created and initialized for verification and given the
corresponding Public Key. The data and the signature bytes are fed
to the signature object, and if the data and signature match, the
<code>Signature</code> object reports success.</p>
<p>Even though a signature seems similar to a message digest, they
have very different purposes in the type of protection they
provide. In fact, algorithms such as "SHA1WithRSA" use the message
digest "SHA1" to initially "compress" the large data sets into a
more manageable form, then sign the resulting 20 byte message
digest with the "RSA" algorithm.</p>
<p>Please see the <a href="#SigEx">Examples</a> section for an
example of signing and verifying data.</p>
<h3><code>Signature</code> Object States</h3>
<p><code>Signature</code> objects are modal objects. This means
that a <code>Signature</code> object is always in a given state,
where it may only do one type of operation. States are represented
as final integer constants defined in their respective classes.</p>
<p>The three states a <code>Signature</code> object may have
are:</p>
<ul>
<li><code>UNINITIALIZED</code></li>
<li><code>SIGN</code></li>
<li><code>VERIFY</code></li>
</ul>
When it is first created, a <code>Signature</code> object is in the
<code>UNINITIALIZED</code> state. The <code>Signature</code> class
defines two initialization methods, <code>initSign</code> and
<code>initVerify</code>, which change the state to
<code>SIGN</code> and <code>VERIFY</code>, respectively.
<h3>Creating a <code>Signature</code> Object</h3>
<p>The first step for signing or verifying a signature is to create
a <code>Signature</code> instance. <code>Signature</code> objects
are obtained by using one of the <code>Signature</code> <a href=
"#ProviderImplReq"><code>getInstance()</code> static factory
methods</a>.</p>
<h3>Initializing a <code>Signature</code> Object</h3>
<p>A <code>Signature</code> object must be initialized before it is
used. The initialization method depends on whether the object is
going to be used for signing or for verification.</p>
<p>If it is going to be used for signing, the object must first be
initialized with the private key of the entity whose signature is
going to be generated. This initialization is done by calling the
method:</p>
<pre class="codeblock">
final void initSign(PrivateKey privateKey)
</pre>
This method puts the <code>Signature</code> object in the
<code>SIGN</code> state.
<p>If instead the <code>Signature</code> object is going to be used
for verification, it must first be initialized with the public key
of the entity whose signature is going to be verified. This
initialization is done by calling either of these methods:</p>
<pre class="codeblock">
    final void initVerify(PublicKey publicKey)

    final void initVerify(Certificate certificate)
</pre>
<p>This method puts the <code>Signature</code> object in the
<code>VERIFY</code> state.</p>
<h3>Signing</h3>
<p>If the <code>Signature</code> object has been initialized for
signing (if it is in the <code>SIGN</code> state), the data to be
signed can then be supplied to the object. This is done by making
one or more calls to one of the <code>update</code> methods:</p>
<pre class="codeblock">
final void update(byte b)
final void update(byte[] data)
final void update(byte[] data, int off, int len)
</pre>
<p>Calls to the <code>update</code> method(s) should be made until
all the data to be signed has been supplied to the
<code>Signature</code> object.</p>
<p>To generate the signature, simply call one of the
<code>sign</code> methods:</p>
<pre class="codeblock">
final byte[] sign()
final int sign(byte[] outbuf, int offset, int len)
</pre>
<p>The first method returns the signature result in a byte array.
The second stores the signature result in the provided buffer
<i>outbuf</i>, starting at <i>offset</i>. <i>len</i> is the number
of bytes in <i>outbuf</i> allotted for the signature. The method
returns the number of bytes actually stored.</p>
<p>Signature encoding is algorithm specific. See the <a href=
"../StandardNames.html">Standard Names</a> document for more
information about the use of ASN.1 encoding in the Java
Cryptography Architecture.</p>
<p>A call to a <code>sign</code> method resets the signature object
to the state it was in when previously initialized for signing via
a call to <code>initSign</code>. That is, the object is reset and
available to generate another signature with the same private key,
if desired, via new calls to <code>update</code> and
<code>sign</code>.</p>
<p>Alternatively, a new call can be made to <code>initSign</code>
specifying a different private key, or to <code>initVerify</code>
(to initialize the <code>Signature</code> object to verify a
signature).</p>
<h3>Verifying</h3>
<p>If the <code>Signature</code> object has been initialized for
verification (if it is in the <code>VERIFY</code> state), it can
then verify if an alleged signature is in fact the authentic
signature of the data associated with it. To start the process, the
data to be verified (as opposed to the signature itself) is
supplied to the object. The data is passed to the object by calling
one of the <code>update</code> methods:</p>
<pre class="codeblock">
final void update(byte b)
final void update(byte[] data)
final void update(byte[] data, int off, int len)
</pre>
<p>Calls to the <code>update</code> method(s) should be made until
all the data to be verified has been supplied to the
<code>Signature</code> object. The signature can now be verified by
calling one of the <code>verify</code> methods:</p>
<pre class="codeblock">
final boolean verify(byte[] signature)

final boolean verify(byte[] signature, int offset, int length)
</pre>
<p>The argument must be a byte array containing the signature. This
byte array would hold the signature bytes which were returned by a
previous call to one of the <code>sign</code> methods.</p>
<p>The <code>verify</code> method returns a <code>boolean</code>
indicating whether or not the encoded signature is the authentic
signature of the data supplied to the <code>update</code>
method(s).</p>
<p>A call to the <code>verify</code> method resets the signature
object to its state when it was initialized for verification via a
call to <code>initVerify</code>. That is, the object is reset and
available to verify another signature from the identity whose
public key was specified in the call to
<code>initVerify</code>.</p>
<p>Alternatively, a new call can be made to <code>initVerify</code>
specifying a different public key (to initialize the
<code>Signature</code> object for verifying a signature from a
different entity), or to <code>initSign</code> (to initialize the
<code>Signature</code> object for generating a signature).</p>
<h2><a name="Cipher" id="Cipher">The Cipher Class</a></h2>
<p>The <code>Cipher</code> class provides the functionality of a
cryptographic cipher used for encryption and decryption. Encryption
is the process of taking data (called <i>cleartext</i>) and a
<i>key</i>, and producing data (<i>ciphertext</i>) meaningless to a
third-party who does not know the key. Decryption is the inverse
process: that of taking ciphertext and a key and producing
cleartext.</p>
<a name="cipher_image" id="cipher_image"></a> <img src=
"../images/jca/Cipher.gif" alt="The Cipher Class" />
<p><a href="img_text/Cipher.html">Description of Figure The Cipher
Class</a></p>
<h3>Symmetric vs. Asymmetric Cryptography</h3>
<p>There are two major types of encryption: <i>symmetric</i> (also
known as <i>secret key</i>), and <i>asymmetric</i> (or <i>public
key cryptography</i>). In symmetric cryptography, the same secret
key to both encrypt and decrypt the data. Keeping the key private
is critical to keeping the data confidential. On the other hand,
asymmetric cryptography uses a public/private key pair to encrypt
data. Data encrypted with one key is decrypted with the other. A
user first generates a public/private key pair, and then publishes
the public key in a trusted database that anyone can access. A user
who wishes to communicate securely with that user encrypts the data
using the retrieved public key. Only the holder of the private key
will be able to decrypt. Keeping the private key confidential is
critical to this scheme.</p>
<p>Asymmetric algorithms (such as RSA) are generally much slower
than symmetric ones. These algorithms are not designed for
efficiently protecting large amounts of data. In practice,
asymmetric algorithms are used to exchange smaller secret keys
which are used to initialize symmetric algorithms.</p>
<h3>Stream vs. Block Ciphers</h3>
<p>There are two major types of ciphers: <i>block</i> and
<i>stream</i>. Block ciphers process entire blocks at a time,
usually many bytes in length. If there is not enough data to make a
complete input block, the data must be <i>padded</i>: that is,
before encryption, dummy bytes must be added to make a multiple of
the cipher's block size. These bytes are then stripped off during
the decryption phase. The padding can either be done by the
application, or by initializing a cipher to use a padding type such
as "PKCS5PADDING". In contrast, stream ciphers process incoming
data one small unit (typically a byte or even a bit) at a time.
This allows for ciphers to process an arbitrary amount of data
without padding.</p>
<h3>Modes Of Operation</h3>
<p>When encrypting using a simple block cipher, two identical
blocks of plaintext will always produce an identical block of
cipher text. Cryptanalysts trying to break the ciphertext will have
an easier job if they note blocks of repeating text. In order to
add more complexity to the text, feedback modes use the previous
block of output to alter the input blocks before applying the
encryption algorithm. The first block will need an initial value,
and this value is called the <i>initialization vector (IV)</i>.
Since the IV simply alters the data before any encryption, the IV
should be random but does not necessarily need to be kept secret.
There are a variety of modes, such as CBC (Cipher Block Chaining),
CFB (Cipher Feedback Mode), and OFB (Output Feedback Mode). ECB
(Electronic Cookbook Mode) is a mode with no feedback.</p>
<p>Some algorithms such as AES and RSA allow for keys of different
lengths, but others are fixed, such as DES and 3DES. Encryption
using a longer key generally implies a stronger resistance to
message recovery. As usual, there is a trade off between security
and time, so choose the key length appropriately.</p>
<p>Most algorithms use binary keys. Most humans do not have the
ability to remember long sequences of binary numbers, even when
represented in hexadecimal. Character passwords are much easier to
recall. Because character passwords are generally chosen from a
small number of characters (for example, [a-zA-Z0-9]), protocols
such as "Password-Based Encryption" (PBE) have been defined which
take character passwords and generate strong binary keys. In order
to make the task of getting from password to key very
time-consuming for an attacker (via so-called "dictionary attacks"
where common dictionary word-&gt;value mappings are precomputed),
most PBE implementations will mix in a random number, known as a
<i>salt</i>, to increase the key randomness.</p>
<p>Newer cipher modes such as Authenticated Encryption with
Associated Data (AEAD) (for example, <a href=
"http://csrc.nist.gov/publications/nistpubs/800-38D/SP-800-38D.pdf">
Galois/Counter Mode (GCM)</a>) encrypt data and authenticate the
resulting message simultaneously. Additional Associated Data (AAD)
can be used during the calculation of the resulting AEAD tag (Mac),
but this AAD data is not output as ciphertext. (For example, some
data might not need to be kept confidential, but should figure into
the tag calculation to detect modifications.) The
Cipher.updateAAD() methods can be used to include AAD in the tag
calculations.</p>
<h4>Using an AES Cipher with GCM Mode</h4>
<p>AES Cipher with GCM is an AEAD Cipher which has different usage patterns
than the non-AEAD ciphers. Apart from the regular data, it also takes AAD which is optional for encryption/decryption
but AAD must be supplied before data for encryption/decryption. In addition, in order to use GCM securely,
callers should not re-use key and IV combinations for encryption. This means that the cipher object should be explicitly
re-initialized with a different set of parameters every time for each encryption operation.</p>
<pre class="codeblock">
	SecretKey myKey = ...
	byte[] myAAD = ...
	byte[] plainText = ...
        int myTLen = ... 
        byte[] myIv = ...

	GCMParameterSpec myParams = new GCMParameterSpec(myTLen, myIv);
	Cipher c = Cipher.getInstance("AES/GCM/NoPadding");
	c.init(Cipher.ENCRYPT_MODE, myKey, myParams);

	// AAD is optional, if present, it must be supplied before any update/doFinal calls.
	c.updateAAD(myAAD);  // if AAD is non-null
	byte[] cipherText = new byte[c.getOutputSize(plainText.length)];
	c.doFinal(plainText, 0, plainText.length, cipherText);    // conclusion of encryption operation

	// To decrypt, same AAD and GCM parameters must be supplied
	c.init(Cipher.DECRYPT_MODE, myKey, myParams);
	c.updateAAD(myAAD);
	byte[] recoveredText = c.doFinal(cipherText);

	// MUST CHANGE IV VALUE if the same key were to be used again for encryption
     	byte[] newIv = ...;
	myParams = new GCMParameterSpec(myTLen, newIv);
</pre>

<h4>Creating a Cipher Object</h4>
<p><code>Cipher</code> objects are obtained by using one of the
<code>Cipher</code> <a href=
"#ProviderImplReq"><code>getInstance()</code> static factory
methods</a>. Here, the algorithm name is slightly different than
with other engine classes, in that it specifies not just an
algorithm name, but a "transformation". <a name="transformation"
id="transformation">A transformation is a string that describes the
operation (or set of operations) to be performed on the given input
to produce some output. A transformation always includes the name
of a cryptographic algorithm (e.g., <code>DES</code>), and may be
followed by a mode and padding scheme.</a></p>
<p>A transformation is of the form:</p>
<ul>
<li>"<i>algorithm/mode/padding</i>" or</li>
<li>"<i>algorithm</i>"</li>
</ul>
<p>For example, the following are valid transformations:</p>
<pre class="codeblock">
    "<i>DES/CBC/PKCS5Padding</i>"

    "<i>DES</i>"
</pre>
<p>If just a transformation name is specified, the system will
determine if there is an implementation of the requested
transformation available in the environment, and if there is more
than one, returns there is a preferred one.</p>
<p>If both a transformation name and a package provider are
specified, the system will determine if there is an implementation
of the requested transformation in the package requested, and throw
an exception if there is not.</p>

<p>It is recommended to use a transformation that fully specifies the algorithm, mode, and padding. By not doing so, the provider will use a default. For example, the SunJCE and SunPKCS11 providers use ECB as the default mode, and PKCS5Padding as the default padding for many symmetric ciphers.</p>

<p>This means that in the case of the
<code>SunJCE</code> provider:</p>
<pre class="codeblock">
    Cipher c1 = Cipher.getInstance("<i>DES/ECB/PKCS5Padding</i>");
</pre>
and
<pre class="codeblock">
    Cipher c1 = Cipher.getInstance("<i>DES</i>");
</pre>
<p><a name="trans" id="trans">are</a> equivalent statements.</p>

<!-- new -->
<hr />
<p><strong>Note:</strong> ECB mode is the easiest block cipher mode to use and is the default in the JDK/JRE. ECB works well for single blocks of data, but absolutely should not be used for multiple data blocks.</p>
<hr />
<p>Using modes such as CFB and OFB, block ciphers can encrypt data
in units smaller than the cipher's actual block size. When
requesting such a mode, you may optionally specify the number of
bits to be processed at a time by appending this number to the mode
name as shown in the "<i>DES/CFB8/NoPadding</i>" and
"<i>DES/OFB32/PKCS5Padding</i>" transformations. If no such number
is specified, a provider-specific default is used. (For example,
the <code>SunJCE</code> provider uses a default of 64 bits for
DES.) Thus, block ciphers can be turned into byte-oriented stream
ciphers by using an 8 bit mode such as CFB8 or OFB8.</p>
<p><a href="#AppA">Appendix A</a> of this document contains a list
of standard names that can be used to specify the algorithm name,
mode, and padding scheme components of a transformation.</p>
<p>The objects returned by factory methods are uninitialized, and
must be initialized before they become usable.</p>
<h4><a name="InitaCipher" id="InitaCipher">Initializing a Cipher
Object</a></h4>
<p>A Cipher object obtained via <code>getInstance</code> must be
initialized for one of four modes, which are defined as final
integer constants in the <code>Cipher</code> class. The modes can
be referenced by their symbolic names, which are shown below along
with a description of the purpose of each mode:</p>
<dl>
<dt>ENCRYPT_MODE</dt>
<dd>Encryption of data.</dd>
<dt>DECRYPT_MODE</dt>
<dd>Decryption of data.</dd>
<dt>WRAP_MODE</dt>
<dd>Wrapping a <code>java.security.Key</code> into bytes so that
the key can be securely transported.</dd>
<dt>UNWRAP_MODE</dt>
<dd>Unwrapping of a previously wrapped key into a
<code>java.security.Key</code> object.</dd>
</dl>
<p>Each of the Cipher initialization methods takes an operational
mode parameter (<code>opmode</code>), and initializes the Cipher
object for that mode. Other parameters include the key
(<code>key</code>) or certificate containing the key
(<code>certificate</code>), algorithm parameters
(<code>params</code>), and a source of randomness
(<code>random</code>).</p>
<p>To initialize a Cipher object, call one of the following
<code>init</code> methods:</p>
<pre class="codeblock">
    public void init(int opmode, Key key);

    public void init(int opmode, Certificate certificate);

    public void init(int opmode, Key key, SecureRandom random);

    public void init(int opmode, Certificate certificate,
                     SecureRandom random);

    public void init(int opmode, Key key,
                     AlgorithmParameterSpec params);

    public void init(int opmode, Key key,
                     AlgorithmParameterSpec params, SecureRandom random);

    public void init(int opmode, Key key,
                     AlgorithmParameters params);

    public void init(int opmode, Key key,
                     AlgorithmParameters params, SecureRandom random);
</pre>
<p>If a Cipher object that requires parameters (e.g., an
initialization vector) is initialized for encryption, and no
parameters are supplied to the <code>init</code> method, the
underlying cipher implementation is supposed to supply the required
parameters itself, either by generating random parameters or by
using a default, provider-specific set of parameters.</p>
<p>However, if a Cipher object that requires parameters is
initialized for decryption, and no parameters are supplied to the
<code>init</code> method, an <code>InvalidKeyException</code> or
<code>InvalidAlgorithmParameterException</code> exception will be
raised, depending on the <code>init</code> method that has been
used.</p>
<p>See the section about <a href="#ManagingParameters">Managing
Algorithm Parameters</a> for more details.</p>
<p>The same parameters that were used for encryption must be used
for decryption.</p>
<p>Note that when a Cipher object is initialized, it loses all
previously-acquired state. In other words, initializing a Cipher is
equivalent to creating a new instance of that Cipher, and
initializing it. For example, if a Cipher is first initialized for
decryption with a given key, and then initialized for encryption,
it will lose any state acquired while in decryption mode.</p>
<h4><a name="EncrDecr" id="EncrDecr">Encrypting and Decrypting
Data</a></h4>
<p>Data can be encrypted or decrypted in one step (<i>single-part
operation</i>) or in multiple steps (<i>multiple-part
operation</i>). A multiple-part operation is useful if you do not
know in advance how long the data is going to be, or if the data is
too long to be stored in memory all at once.</p>
<p>To encrypt or decrypt data in a single step, call one of the
<code>doFinal</code> methods:</p>
<pre class="codeblock">
    public byte[] doFinal(byte[] input);

    public byte[] doFinal(byte[] input, int inputOffset, int inputLen);

    public int doFinal(byte[] input, int inputOffset,
                       int inputLen, byte[] output);

    public int doFinal(byte[] input, int inputOffset,
                       int inputLen, byte[] output, int outputOffset)
</pre>
<p>To encrypt or decrypt data in multiple steps, call one of the
<code>update</code> methods:</p>
<pre class="codeblock">
    public byte[] update(byte[] input);

    public byte[] update(byte[] input, int inputOffset, int inputLen);

    public int update(byte[] input, int inputOffset, int inputLen,
                      byte[] output);

    public int update(byte[] input, int inputOffset, int inputLen,
                      byte[] output, int outputOffset)
</pre>
<p>A multiple-part operation must be terminated by one of the above
<code>doFinal</code> methods (if there is still some input data
left for the last step), or by one of the following
<code>doFinal</code> methods (if there is no input data left for
the last step):</p>
<pre class="codeblock">
    public byte[] doFinal();

    public int doFinal(byte[] output, int outputOffset);
</pre>
<p>All the <code>doFinal</code> methods take care of any necessary
padding (or unpadding), if padding (or unpadding) has been
requested as part of the specified transformation.</p>
<p>A call to <code>doFinal</code> resets the Cipher object to the
state it was in when initialized via a call to <code>init</code>.
That is, the Cipher object is reset and available to encrypt or
decrypt (depending on the operation mode that was specified in the
call to <code>init</code>) more data.</p>
<h4><a name="WrapUnwrap" id="WrapUnwrap">Wrapping and Unwrapping
Keys</a></h4>
<p>Wrapping a key enables secure transfer of the key from one place
to another.</p>
<p>The <code>wrap/unwrap</code> API makes it more convenient to
write code since it works with key objects directly. These methods
also enable the possibility of secure transfer of hardware-based
keys.</p>
<p>To <b>wrap</b> a Key, first initialize the Cipher object for
WRAP_MODE, and then call the following:</p>
<pre class="codeblock">
    public final byte[] wrap(Key key);<br />
</pre>
<p>If you are supplying the wrapped key bytes (the result of
calling <code>wrap</code>) to someone else who will unwrap them, be
sure to also send additional information the recipient will need in
order to do the <code>unwrap</code>:</p>
<ol>
<li>the name of the key algorithm, and</li>
<li>the type of the wrapped key (one of
<code>Cipher.SECRET_KEY</code>, <code>Cipher.PRIVATE_KEY</code>, or
<code>Cipher.PUBLIC_KEY</code>).</li>
</ol>
<p>The key algorithm name can be determined by calling the
<code>getAlgorithm</code> method from the Key interface:</p>
<pre class="codeblock">
    public String getAlgorithm();
</pre>
<p>To <b>unwrap</b> the bytes returned by a previous call to
<code>wrap</code>, first initialize a Cipher object for
UNWRAP_MODE, then call the following:</p>
<pre class="codeblock">
    public final Key unwrap(byte[] wrappedKey,
                            String wrappedKeyAlgorithm,
                            int wrappedKeyType));
</pre>
<p>Here, <code>wrappedKey</code> is the bytes returned from the
previous call to wrap, <code>wrappedKeyAlgorithm</code> is the
algorithm associated with the wrapped key, and
<code>wrappedKeyType</code> is the type of the wrapped key. This
must be one of <code>Cipher.SECRET_KEY</code>,
<code>Cipher.PRIVATE_KEY</code>, or
<code>Cipher.PUBLIC_KEY</code>.</p>
<h4><a name="ManagingParameters" id="ManagingParameters">Managing
Algorithm Parameters</a></h4>
<p>The parameters being used by the underlying Cipher
implementation, which were either explicitly passed to the
<code>init</code> method by the application or generated by the
underlying implementation itself, can be retrieved from the Cipher
object by calling its <code>getParameters</code> method, which
returns the parameters as a
<code>java.security.AlgorithmParameters</code> object (or
<code>null</code> if no parameters are being used). If the
parameter is an initialization vector (IV), it can also be
retrieved by calling the <code>getIV</code> method.</p>
<p>In the following example, a Cipher object implementing
password-based encryption (PBE) is initialized with just a key and
no parameters. However, the selected algorithm for password-based
encryption requires two parameters - a <i>salt</i> and an
<i>iteration count</i>. Those will be generated by the underlying
algorithm implementation itself. The application can retrieve the
generated parameters from the Cipher object as follows:</p>
<pre class="codeblock">
    import javax.crypto.*;
    import java.security.AlgorithmParameters;

    // get cipher object for password-based encryption
    Cipher c = Cipher.getInstance("PBEWithHmacSHA256AndAES_256");

    // initialize cipher for encryption, without supplying
    // any parameters. Here, "myKey" is assumed to refer
    // to an already-generated key.
    c.init(Cipher.ENCRYPT_MODE, myKey);

    // encrypt some data and store away ciphertext
    // for later decryption
    byte[] cipherText = c.doFinal("This is just an example".getBytes());

    // retrieve parameters generated by underlying cipher
    // implementation
    AlgorithmParameters algParams = c.getParameters();

    // get parameter encoding and store it away
    byte[] encodedAlgParams = algParams.getEncoded();
</pre>
<p>The same parameters that were used for encryption must be used
for decryption. They can be instantiated from their encoding and
used to initialize the corresponding Cipher object for decryption,
as follows:</p>
<pre class="codeblock">
    import javax.crypto.*;
    import java.security.AlgorithmParameters;

    // get parameter object for password-based encryption
    AlgorithmParameters algParams;
    algParams = AlgorithmParameters.getInstance("PBEWithHmacSHA256AndAES_256");

    // initialize with parameter encoding from above
    algParams.init(encodedAlgParams);

    // get cipher object for password-based encryption
    Cipher c = Cipher.getInstance("PBEWithHmacSHA256AndAES_256");

    // initialize cipher for decryption, using one of the
    // init() methods that takes an AlgorithmParameters
    // object, and pass it the algParams object from above
    c.init(Cipher.DECRYPT_MODE, myKey, algParams);
</pre>
<p>If you did not specify any parameters when you initialized a
Cipher object, and you are not sure whether or not the underlying
implementation uses any parameters, you can find out by simply
calling the <code>getParameters</code> method of your Cipher object
and checking the value returned. A return value of
<code>null</code> indicates that no parameters were used.</p>
<p>The following cipher algorithms implemented by the
<code>SunJCE</code> provider use parameters:</p>
<ul>
<li>DES, DES-EDE, and Blowfish, when used in feedback (i.e., CBC,
CFB, OFB, or PCBC) mode, use an initialization vector (IV). The
<code>javax.crypto.spec.IvParameterSpec</code> class can be used to
initialize a Cipher object with a given IV.</li>
<li>PBE Cipher algorithms use a set of parameters, comprising of a salt
and an iteration count. The
<code>javax.crypto.spec.PBEParameterSpec</code> class can be used
to initialize a Cipher object implementing a PBE algorithm (for example: PBEWithHmacSHA256AndAES_256) with a
given salt and iteration count.</li>
</ul>
<p>Note that you do not have to worry about storing or transferring
any algorithm parameters for use by the decryption operation if you
use the <a href="#SealedObject"><code>SealedObject</code></a>
class. This class attaches the parameters used for sealing
(encryption) to the encrypted object contents, and uses the same
parameters for unsealing (decryption).</p>
<h4>Cipher Output Considerations</h4>
<p>Some of the <code>update</code> and <code>doFinal</code> methods
of Cipher allow the caller to specify the output buffer into which
to encrypt or decrypt the data. In these cases, it is important to
pass a buffer that is large enough to hold the result of the
encryption or decryption operation.</p>
<p>The following method in Cipher can be used to determine how big
the output buffer should be:</p>
<pre class="codeblock">
    public int getOutputSize(int inputLen)<br />
</pre>
<h2><a name="CipherBased" id="CipherBased">Other
<code>Cipher</code>-based Classes</a></h2>
<p>There are some helper classes which internally use
<code>Cipher</code>s to provide easy access to common cipher
uses.</p>
<h3><a name="CipherStream" id="CipherStream">The Cipher Stream
Classes</a></h3>
<h4><a name="CipherInput" id="CipherInput">The CipherInputStream
Class</a></h4>
<p>This class is a <code>FilterInputStream</code> that encrypts or
decrypts the data passing through it. It is composed of an
<code>InputStream</code>, or one of its subclasses, and a
<code>Cipher</code>. CipherInputStream represents a secure input
stream into which a Cipher object has been interposed. The
<code>read</code> methods of CipherInputStream return data that are
read from the underlying InputStream but have additionally been
processed by the embedded Cipher object. The Cipher object must be
fully initialized before being used by a CipherInputStream.</p>
<p>For example, if the embedded Cipher has been initialized for
decryption, the CipherInputStream will attempt to decrypt the data
it reads from the underlying InputStream before returning them to
the application.</p>
<p>This class adheres strictly to the semantics, especially the
failure semantics, of its ancestor classes
<code>java.io.FilterInputStream</code> and
<code>java.io.InputStream</code>. This class has exactly those
methods specified in its ancestor classes, and overrides them all,
so that the data are additionally processed by the embedded cipher.
Moreover, this class catches all exceptions that are not thrown by
its ancestor classes. In particular, the <code>skip(long)</code>
method skips only data that has been processed by the Cipher.</p>
<p>It is crucial for a programmer using this class not to use
methods that are not defined or overridden in this class (such as a
new method or constructor that is later added to one of the super
classes), because the design and implementation of those methods
are unlikely to have considered security impact with regard to
CipherInputStream.</p>
<p>As an example of its usage, suppose <code>cipher1</code> has
been initialized for encryption. The code below demonstrates how to
use a CipherInputStream containing that cipher and a
FileInputStream in order to encrypt input stream data:</p>
<pre class="codeblock">
    FileInputStream fis;
    FileOutputStream fos;
    CipherInputStream cis;

    fis = new FileInputStream("/tmp/a.txt");
    cis = new CipherInputStream(fis, cipher1);
    fos = new FileOutputStream("/tmp/b.txt");
    byte[] b = new byte[8];
    int i = cis.read(b);
    while (i != -1) {
        fos.write(b, 0, i);
        i = cis.read(b);
    }
    fos.close();
</pre>
<p>The above program reads and encrypts the content from the file
<code>/tmp/a.txt</code> and then stores the result (the encrypted
bytes) in <code>/tmp/b.txt</code>.</p>
<p>The following example demonstrates how to easily connect several
instances of CipherInputStream and FileInputStream. In this
example, assume that <code>cipher1</code> and <code>cipher2</code>
have been initialized for encryption and decryption (with
corresponding keys), respectively.</p>
<pre class="codeblock">
    FileInputStream fis;
    FileOutputStream fos;
    CipherInputStream cis1, cis2;

    fis = new FileInputStream("/tmp/a.txt");
    cis1 = new CipherInputStream(fis, cipher1);
    cis2 = new CipherInputStream(cis1, cipher2);
    fos = new FileOutputStream("/tmp/b.txt");
    byte[] b = new byte[8];
    int i = cis2.read(b);
    while (i != -1) {
        fos.write(b, 0, i);
        i = cis2.read(b);
    }
    fos.close();

</pre>
<p>The above program copies the content from file
<code>/tmp/a.txt</code> to <code>/tmp/b.txt</code>, except that the
content is first encrypted and then decrypted back when it is read
from <code>/tmp/a.txt</code>. Of course since this program simply
encrypts text and decrypts it back right away, it's actually not
very useful except as a simple way of illustrating chaining of
CipherInputStreams.</p>
<p>Note that the read methods of the <code>CipherInputStream</code>
will block until data is returned from the underlying cipher. If a
block cipher is used, a full block of cipher text will have to be
obtained from the underlying InputStream.</p>
<h4><a name="CipherOutput" id="CipherOutput">The CipherOutputStream
Class</a></h4>
<p>This class is a <code>FilterOutputStream</code> that encrypts or
decrypts the data passing through it. It is composed of an
<code>OutputStream</code>, or one of its subclasses, and a
<code>Cipher</code>. CipherOutputStream represents a secure output
stream into which a Cipher object has been interposed. The
<code>write</code> methods of CipherOutputStream first process the
data with the embedded Cipher object before writing them out to the
underlying OutputStream. The Cipher object must be fully
initialized before being used by a CipherOutputStream.</p>
<p>For example, if the embedded Cipher has been initialized for
encryption, the CipherOutputStream will encrypt its data, before
writing them out to the underlying output stream.</p>
<p>This class adheres strictly to the semantics, especially the
failure semantics, of its ancestor classes
<code>java.io.OutputStream</code> and
<code>java.io.FilterOutputStream</code>. This class has exactly
those methods specified in its ancestor classes, and overrides them
all, so that all data are additionally processed by the embedded
cipher. Moreover, this class catches all exceptions that are not
thrown by its ancestor classes.</p>
<p>It is crucial for a programmer using this class not to use
methods that are not defined or overridden in this class (such as a
new method or constructor that is later added to one of the super
classes), because the design and implementation of those methods
are unlikely to have considered security impact with regard to
CipherOutputStream.</p>
<p>As an example of its usage, suppose <code>cipher1</code> has
been initialized for encryption. The code below demonstrates how to
use a CipherOutputStream containing that cipher and a
FileOutputStream in order to encrypt data to be written to an
output stream:</p>
<pre class="codeblock">
    FileInputStream fis;
    FileOutputStream fos;
    CipherOutputStream cos;

    fis = new FileInputStream("/tmp/a.txt");
    fos = new FileOutputStream("/tmp/b.txt");
    cos = new CipherOutputStream(fos, cipher1);
    byte[] b = new byte[8];
    int i = fis.read(b);
    while (i != -1) {
        cos.write(b, 0, i);
        i = fis.read(b);
    }
    cos.flush();
</pre>
<p>The above program reads the content from the file
<code>/tmp/a.txt</code>, then encrypts and stores the result (the
encrypted bytes) in <code>/tmp/b.txt</code>.</p>
<p>The following example demonstrates how to easily connect several
instances of CipherOutputStream and FileOutputStream. In this
example, assume that <code>cipher1</code> and <code>cipher2</code>
have been initialized for decryption and encryption (with
corresponding keys), respectively:</p>
<pre class="codeblock">
    FileInputStream fis;
    FileOutputStream fos;
    CipherOutputStream cos1, cos2;

    fis = new FileInputStream("/tmp/a.txt");
    fos = new FileOutputStream("/tmp/b.txt");
    cos1 = new CipherOutputStream(fos, cipher1);
    cos2 = new CipherOutputStream(cos1, cipher2);
    byte[] b = new byte[8];
    int i = fis.read(b);
    while (i != -1) {
        cos2.write(b, 0, i);
        i = fis.read(b);
    }
    cos2.flush();
</pre>
<p>The above program copies the content from file
<code>/tmp/a.txt</code> to <code>/tmp/b.txt</code>, except that the
content is first encrypted and then decrypted back before it is
written to <code>/tmp/b.txt</code>.</p>
<p>One thing to keep in mind when using <i><b>block</b></i> cipher
algorithms is that a full block of plaintext data must be given to
the <code>CipherOutputStream</code> before the data will be
encrypted and sent to the underlying output stream.</p>
<p>There is one other important difference between the
<code>flush</code> and <code>close</code> methods of this class,
which becomes even more relevant if the encapsulated Cipher object
implements a block cipher algorithm with padding turned on:</p>
<ul>
<li><code>flush</code> flushes the underlying OutputStream by
forcing any buffered output bytes that have already been processed
by the encapsulated Cipher object to be written out. Any bytes
buffered by the encapsulated Cipher object and waiting to be
processed by it will <b>not</b> be written out.</li>
<li><code>close</code> closes the underlying OutputStream and
releases any system resources associated with it. It invokes the
<code>doFinal</code> method of the encapsulated Cipher object,
causing any bytes buffered by it to be processed and written out to
the underlying stream by calling its <code>flush</code>
method.</li>
</ul>
<h3><a name="SealedObject" id="SealedObject">The SealedObject
Class</a></h3>
<p>This class enables a programmer to create an object and protect
its confidentiality with a cryptographic algorithm.</p>
<p>Given any object that implements the
<code>java.io.Serializable</code> interface, one can create a
<code>SealedObject</code> that encapsulates the original object, in
serialized format (i.e., a "deep copy"), and seals (encrypts) its
serialized contents, using a cryptographic algorithm such as DES,
to protect its confidentiality. The encrypted content can later be
decrypted (with the corresponding algorithm using the correct
decryption key) and de-serialized, yielding the original
object.</p>
<p>A typical usage is illustrated in the following code segment: In
order to seal an object, you create a <code>SealedObject</code>
from the object to be sealed and a fully initialized
<code>Cipher</code> object that will encrypt the serialized object
contents. In this example, the String "This is a secret" is sealed
using the DES algorithm. Note that any algorithm parameters that
may be used in the sealing operation are stored inside of
<code>SealedObject</code>:</p>
<pre class="codeblock">
    // create Cipher object
    // NOTE: sKey is assumed to refer to an already-generated
    // secret DES key.
    Cipher c = Cipher.getInstance("DES");
    c.init(Cipher.ENCRYPT_MODE, sKey);

    // do the sealing
    SealedObject so = new SealedObject("This is a secret", c);
</pre>
<p>The original object that was sealed can be recovered in two
different ways:</p>
<ul>
<li>by using a <code>Cipher</code> object that has been initialized
with the exact same algorithm, key, padding scheme, etc., that were
used to seal the object:
<pre class="codeblock">
    c.init(Cipher.DECRYPT_MODE, sKey);
    try {
        String s = (String)so.getObject(c);
    } catch (Exception e) {
        // do something
    };
</pre>
<p>This approach has the advantage that the party who unseals the
sealed object does not require knowledge of the decryption key. For
example, after one party has initialized the cipher object with the
required decryption key, it could hand over the cipher object to
another party who then unseals the sealed object.</p>
</li>
<li>by using the appropriate decryption key (since DES is a
symmetric encryption algorithm, we use the same key for sealing and
unsealing):
<pre class="codeblock">
    try {
        String s = (String)so.getObject(sKey);
    } catch (Exception e) {
        // do something
    };
</pre>
<p>In this approach, the <code>getObject</code> method creates a
cipher object for the appropriate decryption algorithm and
initializes it with the given decryption key and the algorithm
parameters (if any) that were stored in the sealed object. This
approach has the advantage that the party who unseals the object
does not need to keep track of the parameters (e.g., the IV) that
were used to seal the object.</p>
</li>
</ul>
<h2><a name="Mac" id="Mac">The Mac Class</a></h2>
<p>Similar to a <code>MessageDigest</code>, a Message
Authentication Code (MAC) provides a way to check the integrity of
information transmitted over or stored in an unreliable medium, but
includes a secret key in the calculation. Only someone with the
proper key will be able to verify the received message. Typically,
message authentication codes are used between two parties that
share a secret key in order to validate information transmitted
between these parties.</p>
<a name="mac_image" id="mac_image"></a> <img src=
"../images/jca/Mac.gif" alt="The Mac Class" />
<p><a href="img_text/Mac.html">Description of Figure 8: The Mac
Class</a></p>
<p>A MAC mechanism that is based on cryptographic hash functions is
referred to as HMAC. HMAC can be used with any cryptographic hash
function, e.g., MD5 or SHA-1, in combination with a secret shared
key.</p>
<p>The <code>Mac</code> class provides the functionality of a
Message Authentication Code (MAC). Please refer to the <a href=
"#HmacEx">code example</a>.</p>
<h3>Creating a <code>Mac</code> Object</h3>
<p><code>Mac</code> objects are obtained by using one of the
<code>Mac</code> <a href=
"#ProviderImplReq"><code>getInstance()</code> static factory
methods</a>.</p>
<h3>Initializing a Mac Object</h3>
<p>A Mac object is always initialized with a (secret) key and may
optionally be initialized with a set of parameters, depending on
the underlying MAC algorithm.</p>
<p>To initialize a Mac object, call one of its <code>init</code>
methods:</p>
<pre class="codeblock">
    public void init(Key key);

    public void init(Key key, AlgorithmParameterSpec params);
</pre>
<p>You can initialize your Mac object with any (secret-)key object
that implements the <code>javax.crypto.SecretKey</code> interface.
This could be an object returned by
<code>javax.crypto.KeyGenerator.generateKey()</code>, or one that
is the result of a key agreement protocol, as returned by
<code>javax.crypto.KeyAgreement.generateSecret()</code>, or an
instance of <code>javax.crypto.spec.SecretKeySpec</code>.</p>
<p>With some MAC algorithms, the (secret-)key algorithm associated
with the (secret-)key object used to initialize the Mac object does
not matter (this is the case with the HMAC-MD5 and HMAC-SHA1
implementations of the <code>SunJCE</code> provider). With others,
however, the (secret-)key algorithm does matter, and an
<code>InvalidKeyException</code> is thrown if a (secret-)key object
with an inappropriate (secret-)key algorithm is used.</p>
<h3>Computing a MAC</h3>
<p>A MAC can be computed in one step (<i>single-part operation</i>)
or in multiple steps (<i>multiple-part operation</i>). A
multiple-part operation is useful if you do not know in advance how
long the data is going to be, or if the data is too long to be
stored in memory all at once.</p>
<p>To compute the MAC of some data in a single step, call the
following <code>doFinal</code> method:</p>
<pre class="codeblock">
    public byte[] doFinal(byte[] input);
</pre>
<p>To compute the MAC of some data in multiple steps, call one of
the <code>update</code> methods:</p>
<pre class="codeblock">
    public void update(byte input);

    public void update(byte[] input);

    public void update(byte[] input, int inputOffset, int inputLen);
</pre>
<p>A multiple-part operation must be terminated by the above
<code>doFinal</code> method (if there is still some input data left
for the last step), or by one of the following <code>doFinal</code>
methods (if there is no input data left for the last step):</p>
<pre class="codeblock">
    public byte[] doFinal();

    public void doFinal(byte[] output, int outOffset);
</pre>
<h2><a name="Key" id="Key"><code>Key</code> Interfaces</a></h2>
<p>To this point, we have focused the high-level uses of the JCA
without getting lost in the details of what keys are and how they
are generated/represented. It is now time to turn our attention to
keys.</p>
<p>The <code>java.security.Key</code> interface is the top-level
interface for all opaque keys. It defines the functionality shared
by all opaque key objects.</p>
<p>An <i>opaque</i> key representation is one in which you have no
direct access to the key material that constitutes a key. In other
words: "opaque" gives you limited access to the key--just the three
methods defined by the <code>Key</code> interface (see below):
<code>getAlgorithm</code>, <code>getFormat</code>, and
<code>getEncoded</code>.</p>
<p>This is in contrast to a <i>transparent</i> representation, in
which you can access each key material value individually, through
one of the <code>get</code> methods defined in the corresponding
<a href="#KeySpec">specification class</a>.</p>
<p>All opaque keys have three characteristics:</p>
<dl>
<dt><b>An Algorithm</b></dt>
<dd>The key algorithm for that key. The key algorithm is usually an
encryption or asymmetric operation algorithm (such as
<code>AES</code>, <code>DSA</code> or <code>RSA</code>), which will
work with those algorithms and with related algorithms (such as
<code>MD5withRSA</code>, <code>SHA1withRSA</code>, etc.) The name
of the algorithm of a key is obtained using this method:
<pre class="codeblock">
String getAlgorithm()
</pre></dd>
<dt><b>An Encoded Form</b></dt>
<dd>The external encoded form for the key used when a standard
representation of the key is needed outside the Java Virtual
Machine, as when transmitting the key to some other party. The key
is encoded according to a standard format (such as X.509 or PKCS8),
and is returned using the method:
<pre class="codeblock">
byte[] getEncoded()
</pre></dd>
<dt><b>A Format</b></dt>
<dd>The name of the format of the encoded key. It is returned by
the method:
<pre class="codeblock">
String getFormat()
</pre></dd>
</dl>
Keys are generally obtained through key generators such as <a href=
"#KeyGenerator"><code>KeyGenerator</code></a> and <a href=
"#KeyPairGenerator"><code>KeyPairGenerator</code></a>,
certificates, <a href="#KeySpec">key specifications</a> (using a
<a href="#KeyFactory"><code>KeyFactory</code></a>), or a <a href=
"#KeyStore"><code>KeyStore</code></a> implementation accessing a
keystore database used to manage keys. It is possible to parse
encoded keys, in an algorithm-dependent manner, using a <a href=
"#KeyFactory"><code>KeyFactory</code></a>.
<p>It is also possible to parse certificates, using a <a href=
"#CertificateFactory"><code>CertificateFactory</code></a>.</p>
<p>Here is a list of interfaces which extend the <code>Key</code>
interface in the <code>java.security.interfaces</code> and
<code>javax.crypto.interfaces</code> packages:</p>
<ul>
<li><a href=
"../../../../api/javax/crypto/SecretKey.html">SecretKey</a>
<ul>
<li><a href=
"../../../../api/javax/crypto/interfaces/PBEKey.html">PBEKey</a></li>
</ul>
</li>
<li><a href=
"../../../../api/java/security/PrivateKey.html">PrivateKey</a>
<ul>
<li><a href=
"../../../../api/javax/crypto/interfaces/DHPrivateKey.html">DHPrivateKey</a></li>
<li><a href=
"../../../../api/java/security/interfaces/DSAPrivateKey.html">DSAPrivateKey</a></li>
<li><a href=
"../../../../api/java/security/interfaces/ECPrivateKey.html">ECPrivateKey</a></li>
<li><a href=
"../../../../api/java/security/interfaces/RSAMultiPrimePrivateCrtKey.html">
RSAMultiPrimePrivateCrtKey</a></li>
<li><a href=
"../../../../api/java/security/interfaces/RSAPrivateCrtKey.html">RSAPrivateCrtKey</a></li>
<li><a href=
"../../../../api/java/security/interfaces/RSAPrivateKey.html">RSAPrivateKey</a></li>
</ul>
</li>
<li><a href=
"../../../../api/java/security/PublicKey.html">PublicKey</a>
<ul>
<li><a href=
"../../../../api/javax/crypto/interfaces/DHPublicKey.html">DHPublicKey</a></li>
<li><a href=
"../../../../api/java/security/interfaces/DSAPublicKey.html">DSAPublicKey</a></li>
<li><a href=
"../../../../api/java/security/interfaces/ECPublicKey.html">ECPublicKey</a></li>
<li><a href=
"../../../../api/java/security/interfaces/RSAPublicKey.html">RSAPublicKey</a></li>
</ul>
</li>
</ul>
<h3>The <code>PublicKey</code> and <code>PrivateKey</code>
Interfaces</h3>
<p>The <code>PublicKey</code> and <code>PrivateKey</code>
interfaces (which both extend the <code>Key</code> interface) are
methodless interfaces, used for type-safety and
type-identification.</p>
<h2><a name="KeyPair" id="KeyPair">The <code>KeyPair</code>
Class</a></h2>
<p>The <code>KeyPair</code> class is a simple holder for a key pair
(a public key and a private key). It has two public methods, one
for returning the private key, and the other for returning the
public key:</p>
<pre class="codeblock">
PrivateKey getPrivate()
PublicKey getPublic()
</pre>
<h2><a name="KeySpecs" id="KeySpecs">Key Specification Interfaces
and Classes</a></h2>
<p><code>Key</code> objects and key specifications
(<code>KeySpec</code>s) are two different representations of key
data. <code>Cipher</code>s use <code>Key</code> objects to
initialize their encryption algorithms, but keys may need to be
converted into a more portable format for transmission or
storage.</p>
<p>A <i>transparent</i> representation of keys means that you can
access each key material value individually, through one of the
<code>get</code> methods defined in the corresponding specification
class. For example, <code>DSAPrivateKeySpec</code> defines
<code>getX</code>, <code>getP</code>, <code>getQ</code>, and
<code>getG</code> methods, to access the private key
<code>x</code>, and the DSA algorithm parameters used to calculate
the key: the prime <code>p</code>, the sub-prime <code>q</code>,
and the base <code>g</code>. If the key is stored on a hardware
device, its specification may contain information that helps
identify the key on the device.</p>
<p>This representation is contrasted with an <i>opaque</i>
representation, as defined by the <a href=
"#Key"><code>Key</code></a> interface, in which you have no direct
access to the key material fields. In other words, an "opaque"
representation gives you limited access to the key--just the three
methods defined by the <code>Key</code> interface:
<code>getAlgorithm</code>, <code>getFormat</code>, and
<code>getEncoded</code>.</p>
<p>A key may be specified in an algorithm-specific way, or in an
algorithm-independent encoding format (such as ASN.1). For example,
a DSA private key may be specified by its components
<code>x</code>, <code>p</code>, <code>q</code>, and <code>g</code>
(see <a href=
"../../../../api/java/security/spec/DSAPrivateKeySpec.html"><code>DSAPrivateKeySpec</code></a>),
or it may be specified using its DER encoding (see <a href=
"../../../../api/java/security/spec/PKCS8EncodedKeySpec.html"><code>
PKCS8EncodedKeySpec</code></a>).</p>
<p>The <a href="#KeyFactory"><code>KeyFactory</code></a> and
<a href="#SecretKeyFactory"><code>SecretKeyFactory</code></a>
classes can be used to convert between opaque and transparent key
representations (that is, between <code>Key</code>s and
<code>KeySpec</code>s, assuming that the operation is possible.
(For example, private keys on smart cards might not be able leave
the card. Such <code>Key</code>s are not convertible.)</p>
<p>In the following sections, we discuss the key specification
interfaces and classes in the <code>java.security.spec</code>
package.</p>
<h3><a name="KeySpec" id="KeySpec">The <code>KeySpec</code>
Interface</a></h3>
<p>This interface contains no methods or constants. Its only
purpose is to group and provide type safety for all key
specifications. All key specifications must implement this
interface.</p>
<h3><a name="KeySpecSubs" id="KeySpecSubs">The <code>KeySpec</code>
Subinterfaces</a></h3>
<p>Like the <code>Key</code> interface, there are a similar set of
<code>KeySpec</code> interfaces.</p>
<ul>
<li><a href=
"../../../../api/javax/crypto/spec/SecretKeySpec.html">SecretKeySpec</a></li>
<li><a href=
"../../../../api/java/security/spec/EncodedKeySpec.html">EncodedKeySpec</a>
<ul>
<li><a href=
"../../../../api/java/security/spec/PKCS8EncodedKeySpec.html">PKCS8EncodedKeySpec</a></li>
<li><a href=
"../../../../api/java/security/spec/X509EncodedKeySpec.html">X509EncodedKeySpec</a></li>
</ul>
</li>
<li><a href=
"../../../../api/javax/crypto/spec/DESKeySpec.html">DESKeySpec</a></li>
<li><a href=
"../../../../api/javax/crypto/spec/DESedeKeySpec.html">DESedeKeySpec</a></li>
<li><a href=
"../../../../api/javax/crypto/spec/PBEKeySpec.html">PBEKeySpec</a></li>
<li><a href=
"../../../../api/javax/crypto/spec/DHPrivateKeySpec.html">DHPrivateKeySpec</a></li>
<li><a href=
"../../../../api/java/security/spec/DSAPrivateKeySpec.html">DSAPrivateKeySpec</a></li>
<li><a href=
"../../../../api/java/security/spec/ECPrivateKeySpec.html">ECPrivateKeySpec</a></li>
<li><a href=
"../../../../api/java/security/spec/RSAPrivateKeySpec.html">RSAPrivateKeySpec</a>
<ul>
<li><a href=
"../../../../api/java/security/spec/RSAMultiPrimePrivateCrtKeySpec.html">
RSAMultiPrimePrivateCrtKeySpec</a></li>
<li><a href=
"../../../../api/java/security/spec/RSAPrivateCrtKeySpec.html">RSAPrivateCrtKeySpec</a></li>
</ul>
</li>
<li><a href=
"../../../../api/javax/crypto/spec/DHPublicKeySpec.html">DHPublicKeySpec</a></li>
<li><a href=
"../../../../api/java/security/spec/DSAPublicKeySpec.html">DSAPublicKeySpec</a></li>
<li><a href=
"../../../../api/java/security/spec/ECPublicKeySpec.html">ECPublicKeySpec</a></li>
<li><a href=
"../../../../api/java/security/spec/RSAPublicKeySpec.html">RSAPublicKeySpec</a></li>
</ul>
<h3><a name="EncodedKeySpec" id="EncodedKeySpec">The
<code>EncodedKeySpec</code> Class</a></h3>
<p>This abstract class (which implements the <a href=
"#KeySpec"><code>KeySpec</code></a> interface) represents a public
or private key in encoded format. Its <code>getEncoded</code>
method returns the encoded key:</p>
<pre class="codeblock">
abstract byte[] getEncoded();
</pre>
and its <code>getFormat</code> method returns the name of the
encoding format:
<pre class="codeblock">
abstract String getFormat();
</pre>
<p>See the next sections for the concrete implementations
<code>PKCS8EncodedKeySpec</code> and
<code>X509EncodedKeySpec</code>.</p>
<h4><a name="PKCS8EncodedKeySpec" id="PKCS8EncodedKeySpec">The
<code>PKCS8EncodedKeySpec</code> Class</a></h4>
<p>This class, which is a subclass of <code>EncodedKeySpec</code>,
represents the DER encoding of a private key, according to the
format specified in the PKCS8 standard. Its <code>getEncoded</code>
method returns the key bytes, encoded according to the PKCS8
standard. Its <code>getFormat</code> method returns the string
"PKCS#8".</p>
<h4><a name="X509EncodedKeySpec" id="X509EncodedKeySpec">The
<code>X509EncodedKeySpec</code> Class</a></h4>
<p>This class, which is a subclass of <code>EncodedKeySpec</code>,
represents the DER encoding of a public key, according to the
format specified in the X.509 standard. Its <code>getEncoded</code>
method returns the key bytes, encoded according to the X.509
standard. Its <code>getFormat</code> method returns the string
"X.509".</p>
<h2><a name="GeneratorFactory" id="GeneratorFactory">Of Generators
and Factories</a></h2>
<p>Newcomers to Java and the JCA APIs in particular sometimes do
not grasp the distinction between generators and factories.</p>
<a name="differences-between-generators-and-factories_image" id=
"differences-between-generators-and-factories_image"></a> <img src=
"../images/jca/GeneratorFactory.gif" alt=
"Differences Between Generators and Factories" />
<p><a href="img_text/GeneratorFactory.html">Description of Figure
Differences Between Generators and Factories</a></p>
<p>Generators are used to <b>generate brand new objects</b>.
Generators can be initialized in either an algorithm-dependent or
algorithm-independent way. For example, to create a Diffie-Hellman
(DH) keypair, an application could specify the necessary P and G
values, or the generator could simply be initialized with the
appropriate key length, and the generator will select appropriate P
and G values. In both cases, the generator will produce brand new
keys based on the parameters.</p>
<p>On the other hand, factories are used to <b>convert data from
one existing object type to another</b>. For example, an
application might have available the components of a DH private key
and can package them as a <a href=
"#KeySpec"><code>KeySpec</code></a>, but needs to convert them into
a <a href="#Key"><code>PrivateKey</code></a> object that can be
used by a <code>KeyAgreement</code> object, or vice-versa. Or they
might have the byte array of a certificate, but need to use a
<code>CertificateFactory</code> to convert it into a
<code>X509Certificate</code> object. Applications use factory
objects to do the conversion.</p>
<h2><a name="KeyFactory" id="KeyFactory">The
<code>KeyFactory</code> Class</a></h2>
<p>The <code>KeyFactory</code> class is an <a href="#Engine">engine
class</a> designed to perform conversions between opaque
cryptographic <a href="#Key"><code>Key</code>s</a> and <a href=
"#KeySpecs">key specifications</a> (transparent representations of
the underlying key material).</p>
<a name="keyfactory_image" id="keyfactory_image"></a> <img src=
"../images/jca/KeyFactory.gif" alt="The KeyFactory Class&lt;" />
<p><a href="img_text/KeyFactory.html">Description of Figure The
KeyFactory Class</a></p>
<p>Key factories are bi-directional. They allow you to build an
opaque key object from a given key specification (key material), or
to retrieve the underlying key material of a key object in a
suitable format.</p>
<p>Multiple compatible key specifications can exist for the same
key. For example, a DSA public key may be specified by its
components <code>y</code>, <code>p</code>, <code>q</code>, and
<code>g</code> (see
<code>java.security.spec.DSAPublicKeySpec</code>), or it may be
specified using its DER encoding according to the X.509 standard
(see <a href=
"#X509EncodedKeySpec"><code>X509EncodedKeySpec</code></a>).</p>
<p>A key factory can be used to translate between compatible key
specifications. Key parsing can be achieved through translation
between compatible key specifications, e.g., when you translate
from <code>X509EncodedKeySpec</code> to
<code>DSAPublicKeySpec</code>, you basically parse the encoded key
into its components. For an example, see the end of the <a href=
"#KeyFactoryEx">Generating/Verifying Signatures Using Key
Specifications and <code>KeyFactory</code></a> section.</p>
<h3>Creating a <code>KeyFactory</code> Object</h3>
<p><code>KeyFactory</code> objects are obtained by using one of the
<code>KeyFactory</code> <a href=
"#ProviderImplReq"><code>getInstance()</code> static factory
methods</a>.</p>
<h3>Converting Between a Key Specification and a Key Object</h3>
<p>If you have a key specification for a public key, you can obtain
an opaque <code>PublicKey</code> object from the specification by
using the <code>generatePublic</code> method:</p>
<pre class="codeblock">
PublicKey generatePublic(KeySpec keySpec)
</pre>
<p>Similarly, if you have a key specification for a private key,
you can obtain an opaque <code>PrivateKey</code> object from the
specification by using the <code>generatePrivate</code> method:</p>
<pre class="codeblock">
PrivateKey generatePrivate(KeySpec keySpec)
</pre>
<h3>Converting Between a Key Object and a Key Specification</h3>
<p>If you have a <code>Key</code> object, you can get a
corresponding key specification object by calling the
<code>getKeySpec</code> method:</p>
<pre class="codeblock">
KeySpec getKeySpec(Key key, Class keySpec)
</pre>
<code>keySpec</code> identifies the specification class in which
the key material should be returned. It could, for example, be
<code>DSAPublicKeySpec.class</code>, to indicate that the key
material should be returned in an instance of the
<code>DSAPublicKeySpec</code> class.
<p>Please see the <a href="#KeyFactoryEx">Examples</a> section for
more details.</p>
<h2><a name="SecretKeyFactory" id="SecretKeyFactory">The
SecretKeyFactory Class</a></h2>
<p>This class represents a factory for secret keys. Unlike <a href=
"#KeyFactory"><code>KeyFactory</code></a>, a
<code>javax.crypto.SecretKeyFactory</code> object operates only on
secret (symmetric) keys, whereas a
<code>java.security.KeyFactory</code> object processes the public
and private key components of a key pair.</p>
<a name="secretkeyfactory_image" id="secretkeyfactory_image"></a>
<img src="../images/jca/SecretKeyFactory.gif" alt=
"The SecretKeyFactory Class" />
<p><a href="img_text/SecretKeyFactory.html">Description of The
SecretKeyFactory Class</a></p>
<p>Key factories are used to convert <a href=
"#Key"><code>Key</code>s</a> (opaque cryptographic keys of type
<code>java.security.Key</code>) into <a href="#KeySpecs">key
specifications</a> (transparent representations of the underlying
key material in a suitable format), and vice versa.</p>
<p>Objects of type <code>java.security.Key</code>, of which
<code>java.security.PublicKey</code>,
<code>java.security.PrivateKey</code>, and
<code>javax.crypto.SecretKey</code> are subclasses, are opaque key
objects, because you cannot tell how they are implemented. The
underlying implementation is provider-dependent, and may be
software or hardware based. Key factories allow providers to supply
their own implementations of cryptographic keys.</p>
<p>For example, if you have a key specification for a Diffie
Hellman public key, consisting of the public value <code>y</code>,
the prime modulus <code>p</code>, and the base <code>g</code>, and
you feed the same specification to Diffie-Hellman key factories
from different providers, the resulting <code>PublicKey</code>
objects will most likely have different underlying
implementations.</p>
<p>A provider should document the key specifications supported by
its secret key factory. For example, the
<code>SecretKeyFactory</code> for DES keys supplied by the
<code>SunJCE</code> provider supports <code>DESKeySpec</code> as a
transparent representation of DES keys, the
<code>SecretKeyFactory</code> for DES-EDE keys supports
<code>DESedeKeySpec</code> as a transparent representation of
DES-EDE keys, and the <code>SecretKeyFactory</code> for PBE
supports <code>PBEKeySpec</code> as a transparent representation of
the underlying password.</p>
<p>The following is an example of how to use a
<code>SecretKeyFactory</code> to convert secret key data into a
<code>SecretKey</code> object, which can be used for a subsequent
<code>Cipher</code> operation:</p>
<pre class="codeblock">
    // Note the following bytes are not realistic secret key data
    // bytes but are simply supplied as an illustration of using data
    // bytes (key material) you already have to build a DESKeySpec.
    byte[] desKeyData = { (byte)0x01, (byte)0x02, (byte)0x03,
    (byte)0x04, (byte)0x05, (byte)0x06, (byte)0x07, (byte)0x08 };
    DESKeySpec desKeySpec = new DESKeySpec(desKeyData);
    SecretKeyFactory keyFactory = SecretKeyFactory.getInstance("DES");
    SecretKey secretKey = keyFactory.generateSecret(desKeySpec);
</pre>
<p>In this case, the underlying implementation of
<code>SecretKey</code> is based on the provider of
<code>KeyFactory</code>.</p>
<p>An alternative, provider-independent way of creating a
functionally equivalent <code>SecretKey</code> object from the same
key material is to use the
<code>javax.crypto.spec.SecretKeySpec</code> class, which
implements the <code>javax.crypto.SecretKey</code> interface:</p>
<pre class="codeblock">
    byte[] desKeyData = { (byte)0x01, (byte)0x02, ...};
    SecretKeySpec secretKey = new SecretKeySpec(desKeyData, "DES");
</pre>
<h3>Creating a <code>SecretKeyFactory</code> Object</h3>
<p><code>SecretKeyFactory</code> objects are obtained by using one
of the <code>SecretKeyFactory</code> <a href=
"#ProviderImplReq"><code>getInstance()</code> static factory
methods</a>.</p>
<h3>Converting Between a Key Specification and a Secret Key
Object</h3>
<p>If you have a key specification for a secret key, you can obtain
an opaque <code>SecretKey</code> object from the specification by
using the <code>generateSecret</code> method:</p>
<pre class="codeblock">
SecretKey generateSecret(KeySpec keySpec)
</pre>
<h3>Converting Between a Secret Key Object and a Key
Specification</h3>
<p>If you have a <code>Secret Key</code> object, you can get a
corresponding key specification object by calling the
<code>getKeySpec</code> method:</p>
<pre class="codeblock">
KeySpec getKeySpec(Key key, Class keySpec)
</pre>
<code>keySpec</code> identifies the specification class in which
the key material should be returned. It could, for example, be
<code>DESKeySpec.class</code>, to indicate that the key material
should be returned in an instance of the <code>DESKeySpec</code>
class.
<h2><a name="KeyPairGenerator" id="KeyPairGenerator">The
<code>KeyPairGenerator</code> Class</a></h2>
<p>The <code>KeyPairGenerator</code> class is an <a href=
"#Engine">engine class</a> used to generate pairs of public and
private keys.</p>
<a name="keypairgenerator_image" id="keypairgenerator_image"></a>
<img src="../images/jca/KeyPairGenerator.gif" alt=
"The KeyPairGenerator Class" />
<p><a href="img_text/KeyPairGenerator.html">Description of The
KeyPairGenerator Class</a></p>
<p>There are two ways to generate a key pair: in an
algorithm-independent manner, and in an algorithm-specific manner.
The only difference between the two is the initialization of the
object.</p>
<p>Please see the <a href="#KPGEx">Examples</a> section for
examples of calls to the methods documented below.</p>
<h3>Creating a <code>KeyPairGenerator</code></h3>
<p>All key pair generation starts with a
<code>KeyPairGenerator</code>. <code>KeyPairGenerator</code>
objects are obtained by using one of the
<code>KeyPairGenerator</code> <a href=
"#ProviderImplReq"><code>getInstance()</code> static factory
methods</a>.</p>
<h3>Initializing a <code>KeyPairGenerator</code></h3>
<p>A key pair generator for a particular algorithm creates a
public/private key pair that can be used with this algorithm. It
also associates algorithm-specific parameters with each of the
generated keys.</p>
<p>A key pair generator needs to be initialized before it can
generate keys. In most cases, algorithm-independent initialization
is sufficient. But in other cases, algorithm-specific
initialization can be used.</p>
<h4>Algorithm-Independent Initialization</h4>
<p>All key pair generators share the concepts of a keysize and a
source of randomness. The keysize is interpreted differently for
different algorithms. For example, in the case of the DSA
algorithm, the keysize corresponds to the length of the modulus.
(See the <a href="../StandardNames.html">Standard Names</a>
document for information about the keysizes for specific
algorithms.)</p>
<p>An <code>initialize</code> method takes two universally shared
types of arguments:</p>
<pre class="codeblock">
void initialize(int keysize, SecureRandom random)
</pre>
Another <code>initialize</code> method takes only a
<code>keysize</code> argument; it uses a system-provided source of
randomness:
<pre class="codeblock">
void initialize(int keysize)
</pre>
<p>Since no other parameters are specified when you call the above
algorithm-independent <code>initialize</code> methods, it is up to
the provider what to do about the algorithm-specific parameters (if
any) to be associated with each of the keys.</p>
<p>If the algorithm is a "DSA" algorithm, and the modulus size
(keysize) is 512, 768, or 1024, then the <code>SUN</code> provider
uses a set of precomputed values for the <code>p</code>,
<code>q</code>, and <code>g</code> parameters. If the modulus size
is not one of the above values, the <code>SUN</code> provider
creates a new set of parameters. Other providers might have
precomputed parameter sets for more than just the three modulus
sizes mentioned above. Still others might not have a list of
precomputed parameters at all and instead always create new
parameter sets.</p>
<h4>Algorithm-Specific Initialization</h4>
<p>For situations where a set of algorithm-specific parameters
already exists (such as "community parameters" in DSA), there are
two <code>initialize</code> methods that have an <a href=
"#AlgorithmParameterSpec"><code>AlgorithmParameterSpec</code></a>
argument. One also has a <code>SecureRandom</code> argument, while
the source of randomness is system-provided for the other:</p>
<pre class="codeblock">
void initialize(AlgorithmParameterSpec params,
                SecureRandom random)

void initialize(AlgorithmParameterSpec params)
</pre>
See the <a href="#KPGEx">Examples</a> section for more details.
<h3>Generating a Key Pair</h3>
<p>The procedure for generating a key pair is always the same,
regardless of initialization (and of the algorithm). You always
call the following method from <code>KeyPairGenerator</code>:</p>
<pre class="codeblock">
KeyPair generateKeyPair()
</pre>
Multiple calls to <code>generateKeyPair</code> will yield different
key pairs.
<h2><a name="KeyGenerator" id="KeyGenerator">The KeyGenerator
Class</a></h2>
<p>A key generator is used to generate secret keys for symmetric
algorithms.</p>
<a name="keygenerator_image" id="keygenerator_image"></a> <img src=
"../images/jca/KeyGenerator.gif" alt="The KeyGenerator Class" />
<p><a href="img_text/KeyGenerator.html">Description of Figure The
KeyGenerator Class</a></p>
<h3>Creating a <code>KeyGenerator</code></h3>
<code>KeyGenerator</code> objects are obtained by using one of the
<code>KeyGenerator</code> <a href=
"#ProviderImplReq"><code>getInstance()</code> static factory
methods</a>.
<h3>Initializing a KeyGenerator Object</h3>
<p>A key generator for a particular symmetric-key algorithm creates
a symmetric key that can be used with that algorithm. It also
associates algorithm-specific parameters (if any) with the
generated key.</p>
<p>There are two ways to generate a key: in an
algorithm-independent manner, and in an algorithm-specific manner.
The only difference between the two is the initialization of the
object:</p>
<ul>
<li><b>Algorithm-Independent Initialization</b>
<p>All key generators share the concepts of a <i>keysize</i> and a
<i>source of randomness</i>. There is an <code>init</code> method
that takes these two universally shared types of arguments. There
is also one that takes just a <code>keysize</code> argument, and
uses a system-provided source of randomness, and one that takes
just a source of randomness:</p>
<pre class="codeblock">

    public void init(SecureRandom random);

    public void init(int keysize);

    public void init(int keysize, SecureRandom random);
</pre>
<p>Since no other parameters are specified when you call the above
algorithm-independent <code>init</code> methods, it is up to the
provider what to do about the algorithm-specific parameters (if
any) to be associated with the generated key.</p>
</li>
<li><b>Algorithm-Specific Initialization</b>
<p>For situations where a set of algorithm-specific parameters
already exists, there are two <code>init</code> methods that have
an <code>AlgorithmParameterSpec</code> argument. One also has a
<code>SecureRandom</code> argument, while the source of randomness
is system-provided for the other:</p>
<pre class="codeblock">
    public void init(AlgorithmParameterSpec params);

    public void init(AlgorithmParameterSpec params, SecureRandom random);
</pre></li>
</ul>
<p>In case the client does not explicitly initialize the
KeyGenerator (via a call to an <code>init</code> method), each
provider must supply (and document) a default initialization.</p>
<h3>Creating a Key</h3>
<p>The following method generates a secret key:</p>
<pre class="codeblock">
    public SecretKey generateKey();
</pre>
<h2><a name="KeyAgreement" id="KeyAgreement">The KeyAgreement
Class</a></h2>
<p>Key agreement is a protocol by which 2 or more parties can
establish the same cryptographic keys, without having to exchange
any secret information.</p>
<a name="keyagreement_image" id="keyagreement_image"></a> <img src=
"../images/jca/KeyAgreement.gif" alt="The KeyAgreement Class" />
<p><a href="img_text/KeyAgreement.html">Description of Figure The
KeyAgreement Class</a></p>
<p>Each party initializes their key agreement object with their
private key, and then enters the public keys for each party that
will participate in the communication. In most cases, there are
just two parties, but algorithms such as Diffie-Hellman allow for
multiple parties (3 or more) to participate. When all the public
keys have been entered, each <code>KeyAgreement</code> object will
generate (agree upon) the same key.</p>
<p>The KeyAgreement class provides the functionality of a key
agreement protocol. The keys involved in establishing a shared
secret are created by one of the key generators
(<code>KeyPairGenerator</code> or <code>KeyGenerator</code>), a
<code>KeyFactory</code>, or as a result from an intermediate phase
of the key agreement protocol.</p>
<h3>Creating a KeyAgreement Object</h3>
<p>Each party involved in the key agreement has to create a
KeyAgreement object. <code>KeyAgreement</code> objects are obtained
by using one of the <code>KeyAgreement</code> <a href=
"#ProviderImplReq"><code>getInstance()</code> static factory
methods</a>.</p>
<h3>Initializing a KeyAgreement Object</h3>
<p>You initialize a KeyAgreement object with your private
information. In the case of Diffie-Hellman, you initialize it with
your Diffie-Hellman private key. Additional initialization
information may contain a source of randomness and/or a set of
algorithm parameters. Note that if the requested key agreement
algorithm requires the specification of algorithm parameters, and
only a key, but no parameters are provided to initialize the
KeyAgreement object, the key must contain the required algorithm
parameters. (For example, the Diffie-Hellman algorithm uses a prime
modulus <code>p</code> and a base generator <code>g</code> as its
parameters.)</p>
<p>To initialize a KeyAgreement object, call one of its
<code>init</code> methods:</p>
<pre class="codeblock">
    public void init(Key key);

    public void init(Key key, SecureRandom random);

    public void init(Key key, AlgorithmParameterSpec params);

    public void init(Key key, AlgorithmParameterSpec params,
                     SecureRandom random);
</pre>
<h3>Executing a KeyAgreement Phase</h3>
<p>Every key agreement protocol consists of a number of phases that
need to be executed by each party involved in the key
agreement.</p>
<p>To execute the next phase in the key agreement, call the
<code>doPhase</code> method:</p>
<pre class="codeblock">
    public Key doPhase(Key key, boolean lastPhase);
</pre>
<p>The <code>key</code> parameter contains the key to be processed
by that phase. In most cases, this is the public key of one of the
other parties involved in the key agreement, or an intermediate key
that was generated by a previous phase. <code>doPhase</code> may
return an intermediate key that you may have to send to the other
parties of this key agreement, so they can process it in a
subsequent phase.</p>
<p>The <code>lastPhase</code> parameter specifies whether or not
the phase to be executed is the last one in the key agreement: A
value of <code>FALSE</code> indicates that this is not the last
phase of the key agreement (there are more phases to follow), and a
value of <code>TRUE</code> indicates that this is the last phase of
the key agreement and the key agreement is completed, i.e.,
<code>generateSecret</code> can be called next.</p>
<p>In the example of <a href="#AppD">Diffie-Hellman between two
parties</a> , you call <code>doPhase</code> once, with
<code>lastPhase</code> set to <code>TRUE</code>. In the example of
Diffie-Hellman between three parties, you call <code>doPhase</code>
twice: the first time with <code>lastPhase</code> set to
<code>FALSE</code>, the 2nd time with <code>lastPhase</code> set to
<code>TRUE</code>.</p>
<h3>Generating the Shared Secret</h3>
<p>After each party has executed all the required key agreement
phases, it can compute the shared secret by calling one of the
<code>generateSecret</code> methods:</p>
<pre class="codeblock">
    public byte[] generateSecret();

    public int generateSecret(byte[] sharedSecret, int offset);

    public SecretKey generateSecret(String algorithm);
</pre>
<h2><a name="KeyManagement" id="KeyManagement">Key
Management</a></h2>
<p>A database called a "keystore" can be used to manage a
repository of keys and certificates. (A <i>certificate</i> is a
digitally signed statement from one entity, saying that the public
key of some other entity has a particular value.)</p>
<h3><a name="KeystoreLocation" id="KeystoreLocation">Keystore
Location</a></h3>
<p>The user keystore is by default stored in a file named
<code>.keystore</code> in the user's home directory, as determined
by the &quot;user.home&quot; system property. On Solaris systems
&quot;user.home&quot; defaults to the user's home directory. On
Win32 systems, given user name <i>uName</i>, &quot;user.home&quot;
defaults to:</p>
<ul>
<li><tt>C:\Winnt\Profiles\uName</tt> on multi-user Windows NT
systems</li>
<li><tt>C:\Windows\Profiles\uName</tt> on multi-user Windows
95/98/2000 systems</li>
<li><tt>C:\Windows on single-user</tt> Windows 95/98/2000
systems</li>
</ul>
<p>Of course, keystore files can be located as desired. In some
environments, it may make sense for multiple keystores to exist.
For example, in <a href="../jsse/JSSERefGuide.html">JSSE
(SSL/TLS)</a>, one keystore might hold a user's private keys, and
another might hold certificates used to establish trust
relationships.</p>
<p>In addition to the user's keystore, the JDK also maintains a
system-wide keystore which is used to store trusted certificates
from a variety of Certificate Authorities (CA's). These CA
certificates can be used to help make trust decisions. For example,
in SSL/TLS when the <code>SunJSSE</code> provider is presented with
certificates from a remote peer, the default trustmanager will
consult the:</p>
<ul>
<li>Solaris, Linux, or Mac OS X:
<code>&lt;java-home&gt;/lib/ext/cacerts</code></li>
<li>Windows: <code>&lt;java-home&gt;\lib\ext\cacerts</code></li>
</ul>
<p>file to determine if the connection is to be trusted. Instead of
using the system-wide <code>cacerts</code> keystore, applications
can set up and use their own keystores, or even use the user
keystore described above.</p>
<h3><a name="KeystoreImplementation" id=
"KeystoreImplementation">Keystore Implementation</a></h3>
<p>The <a href="#KeyStore"><code>KeyStore</code></a> class supplies
well-defined interfaces to access and modify the information in a
keystore. It is possible for there to be multiple different
concrete implementations, where each implementation is that for a
particular <i>type</i> of keystore.</p>
<p>Currently, there are two command-line tools that make use of
<code>KeyStore</code>: <b><code>keytool</code></b> and
<b><code>jarsigner</code></b>, and also a GUI-based tool named
<b><code>policytool</code></b>. It is also used by the
<code>Policy</code> reference implementation when it processes
policy files specifying the permissions (allowed accesses to system
resources) to be granted to code from various sources. Since
<code>KeyStore</code> is publicly available, JDK users can write
additional security applications that use it.</p>
<p>Applications can choose different <i>types</i> of keystore
implementations from different providers, using the
<code>getInstance</code> factory method in the
<code>KeyStore</code> class. A keystore type defines the storage
and data format of the keystore information, and the algorithms
used to protect private keys in the keystore and the integrity of
the keystore itself. Keystore implementations of different types
are not compatible. <a name="JksKeystore" id="JksKeystore"></a></p>
<p>There is a built-in default keystore implementation type known
as "<code>jks</code>" that is provided by Sun Microsystems. It
implements the keystore as a file, utilizing a proprietary keystore
type (format). It protects each private key with its own individual
password, and also protects the integrity of the entire keystore
with a (possibly different) password. The default is specified by
the following line in the security properties file:</p>
<pre class="codeblock">
    keystore.type=jks
</pre>
<p>To have tools and other applications use a different default
keystore implementation, you can change that line to specify a
default type. If you have a provider package that supplies a
keystore implementation for a keystore type called "jceks", change
the line to:</p>
<pre class="codeblock">
    keystore.type=jceks
</pre>
<p>Some applications, such as <code>keytool</code>, also let you
override the default keystore type (via the <code>-storetype</code>
command-line parameter).</p>
<dl>
<dd><b>NOTE:</b> Keystore type designations are case-insensitive.
For example, "jks" would be considered the same as "JKS".</dd>
</dl>
<p>There are three other types of keystores that come with the JDK
implementation.</p>
<ol>
<li><a name="JceKeystore" id="JceKeystore"><b>"jceks"</b></a> is an
alternate proprietary keystore format to "jks" that uses much
stronger encryption in the form of Password-Based Encryption with
Triple-DES.
<p>The Sun "jceks" implementation can parse and convert a "jks"
keystore file to the "jceks" format. You may upgrade your keystore
of type "jks" to a keystore of type "jceks" by changing the
password of a private-key entry in your keystore and specifying
<code>"-storetype jceks"</code> as the keystore type. To apply the
cryptographically strong(er) key protection supplied to a private
key named "signkey" in your default keystore, use the following
command, which will prompt you for the old and new key
passwords:</p>
<pre class="codeblock">
    keytool -keypasswd -alias signkey -storetype jceks
</pre>
See <a href="../../../tools/index.html#security">Security Tools</a>
for more information about <code>keytool</code> and about keystores
and how they are managed.
<dl>
<dd><b>NOTE:</b> Keystore type designations are case-insensitive.
For example, "jceks" would be considered the same as "JCEKS".</dd>
</dl>
</li>
<li><b>"pkcs12"</b> is another option. This is a cross platform
keystore based on the RSA <a href=
"http://www.emc.com/emc-plus/rsa-labs/standards-initiatives/pkcs12-personal-information-exchange-syntax-standard.htm">
PKCS12 Personal Information Exchange Syntax Standard</a>. This
standard is primarily meant for storing or transporting a user's
private keys, certificates, and miscellaneous secrets. As of
<strong>JDK 8</strong>, arbitrary attributes can be associated with
individual entries in a PKCS12 keystore.</li>
<li><b>"dks"</b> is a domain keystore. It is a collection of
keystores presented as a single logical keystore. The keystores
that comprise a given domain are specified by configuration data
whose syntax is described in <a href=
"../../../../api/java/security/DomainLoadStoreParameter.html">DomainLoadStoreParameter</a>.</li>
</ol>
<p>Keystore implementations are provider-based. Developers
interested in writing their own KeyStore implementations should
consult <a href="HowToImplAProvider.html">How to Implement a
Provider for the Java Cryptography Architecture</a> for more
information on this topic.</p>
<h3><a name="KeyStore" id="KeyStore">The <code>KeyStore</code>
Class</a></h3>
<p>The <code>KeyStore</code> class is an <a href="#Engine">engine
class</a> that supplies well-defined interfaces to access and
modify the information in a keystore.</p>
<a name="keystore_image" id="keystore_image"></a> <img src=
"../images/jca/KeyStore.gif" alt="The KeyStore Class" />
<p><a href="img_text/KeyStore.html">Description of Figure The
KeyStore Class</a></p>
<p>This class represents an in-memory collection of keys and
certificates. <code>KeyStore</code> manages two types of
entries:</p>
<dl>
<dt><b>Key Entry</b></dt>
<dd>
<p>This type of keystore entry holds very sensitive cryptographic
key information, which is stored in a protected format to prevent
unauthorized access. Typically, a key stored in this type of entry
is a secret key, or a private key accompanied by the certificate
chain authenticating the corresponding public key.</p>
<p>Private keys and certificate chains are used by a given entity
for self-authentication using digital signatures. For example,
software distribution organizations digitally sign JAR files as
part of releasing and/or licensing software.</p>
</dd>
<dt><b>Trusted Certificate Entry</b></dt>
<dd>
<p>This type of entry contains a single public key certificate
belonging to another party. It is called a <i>trusted
certificate</i> because the keystore owner trusts that the public
key in the certificate indeed belongs to the identity identified by
the <i>subject</i> (owner) of the certificate.</p>
<p>This type of entry can be used to authenticate other
parties.</p>
</dd>
</dl>
<p>Each entry in a keystore is identified by an "alias" string. In
the case of private keys and their associated certificate chains,
these strings distinguish among the different ways in which the
entity may authenticate itself. For example, the entity may
authenticate itself using different certificate authorities, or
using different public key algorithms.</p>
<p>Whether keystores are persistent, and the mechanisms used by the
keystore if it is persistent, are not specified here. This
convention allows use of a variety of techniques for protecting
sensitive (e.g., private or secret) keys. Smart cards or other
integrated cryptographic engines (SafeKeyper) are one option, and
simpler mechanisms such as files may also be used (in a variety of
formats).</p>
<p>The main <code>KeyStore</code> methods are described below.</p>
<h3>Creating a <code>KeyStore</code> Object</h3>
<p><code>KeyStore</code> objects are obtained by using one of the
<code>KeyStore</code> <a href=
"#ProviderImplReq"><code>getInstance()</code> static factory
methods</a>.</p>
<h3>Loading a Particular Keystore into Memory</h3>
<p>Before a <code>KeyStore</code> object can be used, the actual
keystore data must be loaded into memory via the <code>load</code>
method:</p>
<pre class="codeblock">
final void load(InputStream stream, char[] password)
</pre>
<p>The optional password is used to check the integrity of the
keystore data. If no password is supplied, no integrity check is
performed.</p>
<p>To create an empty keystore, you pass <code>null</code> as the
<code>InputStream</code> argument to the <code>load</code>
method.</p>
<p>A DKS keystore is loaded by passing a <a href=
"../../../../api/java/security/DomainLoadStoreParameter.html">DomainLoadStoreParameter</a>
to the alternative load method:</p>
<pre class="codeblock">
final void load(KeyStore.LoadStoreParameter param)
</pre>
<h3>Getting a List of the Keystore Aliases</h3>
<p>All keystore entries are accessed via unique <i>aliases</i>. The
<code>aliases</code> method returns an enumeration of the alias
names in the keystore:</p>
<pre class="codeblock">
final Enumeration aliases()
</pre>
<h3>Determining Keystore Entry Types</h3>
<p>As stated in <a href="#KeyStore">The <code>KeyStore</code>
Class</a>, there are two different types of entries in a keystore.
The following methods determine whether the entry specified by the
given alias is a key/certificate or a trusted certificate entry,
respectively:</p>
<pre class="codeblock">
final boolean isKeyEntry(String alias)
final boolean isCertificateEntry(String alias)
</pre>
<h3>Adding/Setting/Deleting Keystore Entries</h3>
<p>The <code>setCertificateEntry</code> method assigns a
certificate to a specified alias:</p>
<pre class="codeblock">
final void setCertificateEntry(String alias, Certificate cert)
</pre>
<p>If <code>alias</code> doesn't exist, a trusted certificate entry
with that alias is created. If <code>alias</code> exists and
identifies a trusted certificate entry, the certificate associated
with it is replaced by <code>cert</code>.</p>
<p>The <code>setKeyEntry</code> methods add (if <code>alias</code>
doesn't yet exist) or set key entries:</p>
<pre class="codeblock">
final void setKeyEntry(String alias,
                       Key key,
                       char[] password,
                       Certificate[] chain)

final void setKeyEntry(String alias,
                       byte[] key,
                       Certificate[] chain)
</pre>
<p>In the method with <code>key</code> as a byte array, it is the
bytes for a key in protected format. For example, in the keystore
implementation supplied by the <code>SUN</code> provider, the
<code>key</code> byte array is expected to contain a protected
private key, encoded as an <code>EncryptedPrivateKeyInfo</code> as
defined in the PKCS8 standard. In the other method, the
<code>password</code> is the password used to protect the key.</p>
<p>The <code>deleteEntry</code> method deletes an entry:</p>
<pre class="codeblock">
final void deleteEntry(String alias)
</pre>
<p>PKCS #12 keystores support entries containing arbitrary
attributes. Use the <a href=
"../../../../api/java/security/PKCS12Attribute.html">java.security.PKCS12Attribute</a>
class to create the attributes. When creating the new keystore
entry use a constructor method that accepts attributes. Finally,
use the following method to add the entry to the keystore:</p>
<pre class="codeblock">
final void setEntry(String alias, Entry entry, 
                    ProtectionParameter protParam)
</pre>
<h3>Getting Information from the Keystore</h3>
<p>The <code>getKey</code> method returns the key associated with
the given alias. The key is recovered using the given password:</p>
<pre class="codeblock">
final Key getKey(String alias, char[] password)
</pre>
<p>The following methods return the certificate, or certificate
chain, respectively, associated with the given alias:</p>
<pre class="codeblock">
final Certificate getCertificate(String alias)
final Certificate[] getCertificateChain(String alias)
</pre>
<p>You can determine the name (<code>alias</code>) of the first
entry whose certificate matches a given certificate via the
following:</p>
<pre class="codeblock">
final String getCertificateAlias(Certificate cert)
</pre>
<p>PKCS #12 keystores support entries containing arbitrary
attributes. Use the following method to retrieve an entry that may
contain attributes:</p>
<pre class="codeblock">
final Entry getEntry(String alias, ProtectionParameter protParam)
</pre>
<p>and then use the <a href=
"../../../../api/java/security/KeyStore.Entry.html#getAttributes--">
KeyStore.Entry.getAttributes</a> method to extract such attributes
and use the methods of the <a href=
"../../../../api/java/security/KeyStore.Entry.Attribute.html">KeyStore.Entry.Attribute</a>
interface to examine them.</p>
<h3>Saving the KeyStore</h3>
<p>The in-memory keystore can be saved via the <code>store</code>
method:</p>
<pre class="codeblock">
final void store(OutputStream stream, char[] password)
</pre>
<p>The password is used to calculate an integrity checksum of the
keystore data, which is appended to the keystore data.</p>
<p>A DKS keystore is stored by passing a <a href=
"../../../../api/java/security/DomainLoadStoreParameter.html">DomainLoadStoreParameter</a>
to the alternative store method:</p>
<pre class="codeblock">
final void store(KeyStore.LoadStoreParameter param)
</pre>
<h2><a name="AlgSpec" id="AlgSpec">Algorithm Parameters
Classes</a></h2>
<p>Like <code>Key</code>s and <code>Keyspec</code>s, an algorithm's
initialization parameters are represented by either
<code>AlgorithmParameter</code>s or
<code>AlgorithmParameterSpec</code>s. Depending on the use
situation, algorithms can use the parameters directly, or the
parameters might need to be converted into a more portable format
for transmission or storage.</p>
<p>A <i>transparent</i> representation of a set of parameters (via
<code>AlgorithmParameterSpec</code>) means that you can access each
parameter value in the set individually. You can access these
values through one of the <code>get</code> methods defined in the
corresponding specification class (e.g.,
<code>DSAParameterSpec</code> defines <code>getP</code>,
<code>getQ</code>, and <code>getG</code> methods, to access
<code>p</code>, <code>q</code>, and <code>g</code>,
respectively).</p>
<p>In contrast, the <a href=
"#AlgorithmParameters"><code>AlgorithmParameters</code></a> class
supplies an <i>opaque</i> representation, in which you have no
direct access to the parameter fields. You can only get the name of
the algorithm associated with the parameter set (via
<code>getAlgorithm</code>) and some kind of encoding for the
parameter set (via <code>getEncoded</code>).</p>
<h3><a name="AlgorithmParameterSpec" id=
"AlgorithmParameterSpec">The <code>AlgorithmParameterSpec</code>
Interface</a></h3>
<p><code>AlgorithmParameterSpec</code> is an interface to a
transparent specification of cryptographic parameters. This
interface contains no methods or constants. Its only purpose is to
group (and provide type safety for) all parameter specifications.
All parameter specifications must implement this interface.</p>
<p>The algorithm parameter specification interfaces and classes in
the <code>java.security.spec</code> and
<code>javax.crypto.spec</code> packages are described in the JDK
javadocs:</p>
<ul>
<li><a href=
"../../../../api/javax/crypto/spec/DHParameterSpec.html">DHParameterSpec</a></li>
<li><a href=
"../../../../api/javax/crypto/spec/DHGenParameterSpec.html">DHGenParameterSpec</a></li>
<li><a href=
"../../../../api/java/security/spec/DSAParameterSpec.html">DSAParameterSpec</a></li>
<li><a href=
"../../../../api/java/security/spec/ECGenParameterSpec.html">ECGenParameterSpec</a></li>
<li><a href=
"../../../../api/java/security/spec/ECParameterSpec.html">ECParameterSpec</a></li>
<li><a href=
"../../../../api/javax/crypto/spec/GCMParameterSpec.html">GCMParameterSpec</a></li>
<li><a href=
"../../../../api/javax/crypto/spec/IvParameterSpec.html">IvParameterSpec</a></li>
<li><a href=
"../../../../api/java/security/spec/MGF1ParameterSpec.html">MGF1ParameterSpec</a></li>
<li><a href=
"../../../../api/javax/crypto/spec/OAEPParameterSpec.html">OAEPParameterSpec</a></li>
<li><a href=
"../../../../api/javax/crypto/spec/PBEParameterSpec.html">PBEParameterSpec</a></li>
<li><a href=
"../../../../api/java/security/spec/PSSParameterSpec.html">PSSParameterSpec</a></li>
<li><a href=
"../../../../api/javax/crypto/spec/RC2ParameterSpec.html">RC2ParameterSpec</a></li>
<li><a href=
"../../../../api/javax/crypto/spec/RC5ParameterSpec.html">RC5ParameterSpec</a></li>
<li><a href=
"../../../../api/java/security/spec/RSAKeyGenParameterSpec.html">RSAKeyGenParameterSpec</a></li>
</ul>
<p>The following algorithm parameter specs are used specifically
for digital signatures, as part of <a href=
"http://www.jcp.org/en/jsr/detail?id=105">JSR 105</a>.</p>
<ul>
<li><a href=
"../../../../api/javax/xml/crypto/dsig/spec/C14NMethodParameterSpec.html">
C14NMethodParameterSpec</a></li>
<li><a href=
"../../../../api/javax/xml/crypto/dsig/spec/DigestMethodParameterSpec.html">
DigestMethodParameterSpec</a></li>
<li><a href=
"../../../../api/javax/xml/crypto/dsig/spec/SignatureMethodParameterSpec.html">
SignatureMethodParameterSpec</a></li>
<li><a href=
"../../../../api/javax/xml/crypto/dsig/spec/TransformParameterSpec.html">
TransformParameterSpec</a></li>
<li><a href=
"../../../../api/javax/xml/crypto/dsig/spec/ExcC14NParameterSpec.html">
ExcC14NParameterSpec</a></li>
<li><a href=
"../../../../api/javax/xml/crypto/dsig/spec/HMACParameterSpec.html">
HMACParameterSpec</a></li>
<li><a href=
"../../../../api/javax/xml/crypto/dsig/spec/XPathFilter2ParameterSpec.html">
XPathFilter2ParameterSpec</a></li>
<li><a href=
"../../../../api/javax/xml/crypto/dsig/spec/XPathFilterParameterSpec.html">
XPathFilterParameterSpec</a></li>
<li><a href=
"../../../../api/javax/xml/crypto/dsig/spec/XSLTTransformParameterSpec.html">
XSLTTransformParameterSpec</a></li>
</ul>
<h3><a name="AlgorithmParameters" id="AlgorithmParameters">The
<code>AlgorithmParameters</code> Class</a></h3>
<p>The <code>AlgorithmParameters</code> class is an <a href=
"#Engine">engine class</a> that provides an opaque representation
of cryptographic parameters. You can initialize the
<code>AlgorithmParameters</code> class using a specific
<code>AlgorithmParameterSpec</code> object, or by encoding the
parameters in a recognized format. You can retrieve the resulting
specification with the <code>getParameterSpec</code> method (see
the following section).</p>
<h3>Creating an <code>AlgorithmParameters</code> Object</h3>
<p><code>AlgorithmParameters</code> objects are obtained by using
one of the <code>AlgorithmParameters</code> <a href=
"#ProviderImplReq"><code>getInstance()</code> static factory
methods</a>.</p>
<h3>Initializing an <code>AlgorithmParameters</code> Object</h3>
<p>Once an <code>AlgorithmParameters</code> object is instantiated,
it must be initialized via a call to <code>init</code>, using an
appropriate parameter specification or parameter encoding:</p>
<pre class="codeblock">
void init(AlgorithmParameterSpec paramSpec)
void init(byte[] params)
void init(byte[] params, String format)
</pre>
<p>In these <code>init</code> methods, <code>params</code> is an
array containing the encoded parameters, and <code>format</code> is
the name of the decoding format. In the <code>init</code> method
with a <code>params</code> argument but no <code>format</code>
argument, the primary decoding format for parameters is used. The
primary decoding format is ASN.1, if an ASN.1 specification for the
parameters exists.</p>
<dl>
<dd><b>NOTE:</b> <code>AlgorithmParameters</code> objects can be
initialized only once. They are not reusable.</dd>
</dl>
<h3>Obtaining the Encoded Parameters</h3>
<p>A byte encoding of the parameters represented in an
<code>AlgorithmParameters</code> object may be obtained via a call
to <code>getEncoded</code>:</p>
<pre class="codeblock">
byte[] getEncoded()
</pre>
<p>This method returns the parameters in their primary encoding
format. The primary encoding format for parameters is ASN.1, if an
ASN.1 specification for this type of parameters exists.</p>
<p>If you want the parameters returned in a specified encoding
format, use</p>
<pre class="codeblock">
byte[] getEncoded(String format)
</pre>
If <code>format</code> is null, the primary encoding format for
parameters is used, as in the other <code>getEncoded</code> method.
<dl>
<dd><b>NOTE:</b> In the default <code>AlgorithmParameters</code>
implementation, supplied by the <code>SUN</code> provider, the
<code>format</code> argument is currently ignored.</dd>
</dl>
<h3>Converting an <code>AlgorithmParameters</code> Object to a
Transparent Specification</h3>
<p>A transparent parameter specification for the algorithm
parameters may be obtained from an <code>AlgorithmParameters</code>
object via a call to <code>getParameterSpec</code>:</p>
<pre class="codeblock">
AlgorithmParameterSpec getParameterSpec(Class paramSpec)
</pre>
<p><code>paramSpec</code> identifies the specification class in
which the parameters should be returned. The specification class
could be, for example, <code>DSAParameterSpec.class</code> to
indicate that the parameters should be returned in an instance of
the <code>DSAParameterSpec</code> class. (This class is in the
<code>java.security.spec</code> package.)</p>
<h3><a name="AlgorithmParameterGenerator" id=
"AlgorithmParameterGenerator">The
<code>AlgorithmParameterGenerator</code> Class</a></h3>
<p>The <code>AlgorithmParameterGenerator</code> class is an
<a href="#Engine">engine class</a> used to generate a set of
<b>brand-new</b> parameters suitable for a certain algorithm (the
algorithm is specified when an
<code>AlgorithmParameterGenerator</code> instance is created). This
object is used when you do not have an existing set of algorithm
parameters, and want to generate one from scratch.</p>
<h3>Creating an <code>AlgorithmParameterGenerator</code>
Object</h3>
<p><code>AlgorithmParameterGenerator</code> objects are obtained by
using one of the <code>AlgorithmParameterGenerator</code> <a href=
"#ProviderImplReq"><code>getInstance()</code> static factory
methods</a>.</p>
<h3>Initializing an <code>AlgorithmParameterGenerator</code>
Object</h3>
<p>The <code>AlgorithmParameterGenerator</code> object can be
initialized in two different ways: an algorithm-independent manner
or an algorithm-specific manner.</p>
<p>The algorithm-independent approach uses the fact that all
parameter generators share the concept of a "size" and a source of
randomness. The measure of size is universally shared by all
algorithm parameters, though it is interpreted differently for
different algorithms. For example, in the case of parameters for
the DSA algorithm, "size" corresponds to the size of the prime
modulus, in bits. (See the <a href="../StandardNames.html">Standard
Names</a> document for information about the sizes for specific
algorithms.) When using this approach, algorithm-specific parameter
generation values--if any--default to some standard values. One
<code>init</code> method that takes these two universally shared
types of arguments:</p>
<pre class="codeblock">
void init(int size, SecureRandom random);
</pre>
<p>Another <code>init</code> method takes only a <code>size</code>
argument and uses a system-provided source of randomness:</p>
<pre class="codeblock">
void init(int size)
</pre>
<p>A third approach initializes a parameter generator object using
algorithm-specific semantics, which are represented by a set of
algorithm-specific parameter generation values supplied in an
<code>AlgorithmParameterSpec</code> object:</p>
<pre class="codeblock">
void init(AlgorithmParameterSpec genParamSpec,
                          SecureRandom random)

void init(AlgorithmParameterSpec genParamSpec)
</pre>
<p>To generate Diffie-Hellman system parameters, for example, the
parameter generation values usually consist of the size of the
prime modulus and the size of the random exponent, both specified
in number of bits.</p>
<h3>Generating Algorithm Parameters</h3>
<p>Once you have created and initialized an
<code>AlgorithmParameterGenerator</code> object, you can use the
<code>generateParameters</code> method to generate the algorithm
parameters:</p>
<pre class="codeblock">
AlgorithmParameters generateParameters()
</pre>
<h2><a name="CertificateFactory" id="CertificateFactory">The
<code>CertificateFactory</code> Class</a></h2>
<p>The <code>CertificateFactory</code> class is an <a href=
"#Engine">engine class</a> that defines the functionality of a
certificate factory, which is used to generate certificate and
certificate revocation list (CRL) objects from their encodings.</p>
<p>A certificate factory for X.509 must return certificates that
are an instance of <code>java.security.cert.X509Certificate</code>,
and CRLs that are an instance of
<code>java.security.cert.X509CRL</code>.</p>
<h3>Creating a <code>CertificateFactory</code> Object</h3>
<p><code>CertificateFactory</code> objects are obtained by using
one of the <a href="#ProviderImplReq"><code>getInstance()</code>
static factory methods</a>.</p>
<h3>Generating Certificate Objects</h3>
<p>To generate a certificate object and initialize it with the data
read from an input stream, use the <code>generateCertificate</code>
method:</p>
<pre class="codeblock">
final Certificate generateCertificate(InputStream inStream)
</pre>
<p>To return a (possibly empty) collection view of the certificates
read from a given input stream, use the
<code>generateCertificates</code> method:</p>
<pre class="codeblock">
final Collection generateCertificates(InputStream inStream)
</pre>
<h3>Generating CRL Objects</h3>
<p>To generate a certificate revocation list (CRL) object and
initialize it with the data read from an input stream, use the
<code>generateCRL</code> method:</p>
<pre class="codeblock">
final CRL generateCRL(InputStream inStream)
</pre>
To return a (possibly empty) collection view of the CRLs read from
a given input stream, use the <code>generateCRLs</code> method:
<pre class="codeblock">
final Collection generateCRLs(InputStream inStream)
</pre>
<h3>Generating <code>CertPath</code> Objects</h3>
<p>The certificate path builder and validator for PKIX is defined
by the Internet X.509 Public Key Infrastructure Certificate and CRL
Profile, <a href="http://www.ietf.org/rfc/rfc3280.txt">RFC
3280</a>.</p>
<p>A certificate store implementation for retrieving certificates
and CRLs from Collection and LDAP directories, using the PKIX LDAP
V2 Schema is also available from the IETF as <a href=
"http://www.ietf.org/rfc/rfc2587.txt">RFC 2587</a>.</p>
<p>To generate a <code>CertPath</code> object and initialize it
with data read from an input stream, use one of the following
<code>generateCertPath</code> methods (with or without specifying
the encoding to be used for the data):</p>
<pre class="codeblock">
final CertPath generateCertPath(InputStream inStream)

final CertPath generateCertPath(InputStream inStream,
                                String encoding)
</pre>
<p>To generate a <code>CertPath</code> object and initialize it
with a list of certificates, use the following method:</p>
<pre class="codeblock">
final CertPath generateCertPath(List certificates)
</pre>
<p>To retrieve a list of the <code>CertPath</code> encodings
supported by this certificate factory, you can call the
<code>getCertPathEncodings</code> method:</p>
<pre class="codeblock">
final Iterator getCertPathEncodings()
</pre>
The default encoding will be listed first.
<h2><a name="SSLTLS" id="SSLTLS">How the JCA Might Be Used in a
SSL/TLS Implementation</a></h2>
<p>With an understanding of the JCA classes, consider how these
classes might be combined to implement an advanced network protocol
like SSL/TLS. The <a href=
"../jsse/JSSERefGuide.html#SSLOverview">SSL/TLS Overview</a>
section in the <a href="../jsse/JSSERefGuide.html">JSSE Reference
Guide</a> describes at a high level how the protocols work. As
asymmetric (public key) cipher operations are much slower than
symmetric operations (secret key), public key cryptography is used
to establish secret keys which are then used to protect the actual
application data. Vastly simplified, the SSL/TLS handshake involves
exchanging initialization data, performing some public key
operations to arrive at a secret key, and then using that key to
encrypt further traffic.</p>
<dl>
<dd><b>NOTE:</b> The details presented here simply show how some of
the above classes might be employed. This section will not present
sufficient information for building a SSL/TLS implementation. For
more details, please see the <a href=
"../jsse/JSSERefGuide.html">JSSE Reference Guide</a> and <a href=
"http://www.ietf.org/rfc/rfc2246.txt">RFC 2246: The TLS
Protocol</a>.</dd>
</dl>
<p>Assume that this SSL/TLS implementation will be made available
as a JSSE provider. A concrete implementation of the
<code>Provider</code> class is first written that will eventually
be registered in the <code>Security</code> class' list of
providers. This provider mainly provides a mapping from algorithm
names to actual implementation classes. (that is:
"SSLContext.TLS"-&gt;"com.foo.TLSImpl") When an application
requests an "TLS" instance (via
<code>SSLContext.getInstance("TLS")</code>, the provider's list is
consulted for the requested algorithm, and an appropriate instance
is created.</p>
<p>Before discussing details of the actual handshake, a quick
review of some of the JSSE's architecture is needed. The heart of
the JSSE architecture is the <code>SSLContext</code>. The context
eventually creates end objects (<code>SSLSocket</code> and
<code>SSLEngine</code>) which actually implement the SSL/TLS
protocol. <code>SSLContext</code>s are initialized with two
callback classes, <code>KeyManager</code> and
<code>TrustManager</code>, which allow applications to first select
authentication material to send and second to verify credentials
sent by a peer.</p>
<p>A JSSE <code>KeyManager</code> is responsible for choosing which
credentials to present to a peer. Many algorithms are possible, but
a common strategy is to maintain a RSA or DSA public/private key
pair along with a <code>X509Certificate</code> in a
<code>KeyStore</code> backed by a disk file. When a
<code>KeyStore</code> object is initialized and loaded from the
file, the file's raw bytes are converted into
<code>PublicKey</code> and <code>PrivateKey</code> objects using a
<code>KeyFactory</code>, and a certificate chain's bytes are
converted using a <code>CertificateFactory</code>. When a
credential is needed, the <code>KeyManager</code> simply consults
this <code>KeyStore</code> object and determines which credentials
to present.</p>
<p>A <code>KeyStore</code>'s contents might have originally been
created using a utility such as <code>keytool</code>.
<code>keytool</code> creates a RSA or DSA
<code>KeyPairGenerator</code> and initializes it with an
appropriate keysize. This generator is then used to create a
<code>KeyPair</code> which <code>keytool</code> would store along
with the newly-created certificate in the <code>KeyStore</code>,
which is eventually written to disk.</p>
<p>A JSSE <code>TrustManager</code> is responsible for verifying
the credentials received from a peer. There are many ways to verify
credentials: one of them is to create a <code>CertPath</code>
object, and let the JDK's built-in Public Key Infrastructure (PKI)
framework handle the validation. Internally, the CertPath
implementation might create a <code>Signature</code> object, and
use that to verify that the each of the signatures in the
certificate chain.</p>
<p>With this basic understanding of the architecture, we can look
at some of the steps in the SSL/TLS handshake. The client begins by
sending a ClientHello message to the server. The server selects a
ciphersuite to use, and sends that back in a ServerHello message,
and begins creating JCA objects based on the suite selection. We'll
use server-only authentication in the following examples.</p>
<a name="ssl-messages_image" id="ssl-messages_image"></a> <img src=
"../jsse/sslmessages.gif" alt="SSL Messages" />
<p><a href="img_text/sslmessages.html">Description of Figure SSL
Messages</a></p>
<p>In the first example, the server tries to use a RSA-based
ciphersuite such as TLS_RSA_WITH_AES_128_CBC_SHA. The server's
<code>KeyManager</code> is queried, and returns an appropriate RSA
entry. The server's credentials (that is: certificate/public key)
are sent in the server's Certificate message. The client's
<code>TrustManager</code> verifies the server's certificate, and if
accepted, the client generates some random bytes using a
<code>SecureRandom</code> object. This is then encrypted using an
encrypting asymmetric RSA <code>Cipher</code> object that has been
initialized with the <code>PublicKey</code> found in the server's
certificate. This encrypted data is sent in a Client Key Exchange
message. The server would use its corresponding
<code>PrivateKey</code> to recover the bytes using a similar
<code>Cipher</code> in decrypt mode. These bytes are then used to
establish the actual encryption keys.</p>
<p>In a different example, an ephemeral Diffie-Hellman key
agreement algorithm along with the DSA signature algorithm is
chosen, such as TLS_DHE_DSS_WITH_AES_128_CBC_SHA. The two sides
must each establish a new temporary DH public/private keypair using
a <code>KeyPairGenerator</code>. Each generator creates DH keys
which can then be further converted into pieces using the
<code>KeyFactory</code> and <code>DHPublicKeySpec</code> classes.
Each side then creates a <code>KeyAgreement</code> object and
initializes it with their respective DH <code>PrivateKey</code>s.
The server sends its public key pieces in a ServerKeyExchange
message (protected by the DSA signature algorithm, and the client
sends its public key in a ClientKeyExchange message. When the
public keys are reassembled using another <code>KeyFactory</code>,
they are fed into the agreement objects. The
<code>KeyAgreement</code> objects then generate agreed-upon bytes
that are then used to establish the actual encryption keys.</p>
<p>Once the actual encryption keys have been established, the
secret key is used to initialize a symmetric <code>Cipher</code>
object, and this cipher is used to protect all data in transit. To
help determine if the data has been modified, a
<code>MessageDigest</code> is created and receives a copy of the
data destined for the network. When the packet is complete, the
digest (hash) is appended to data, and the entire packet is
encrypted by the <code>Cipher</code>. If a block cipher such as AES
is used, the data must be padded to make a complete block. On the
remote side, the steps are simply reversed.</p>
<!--
<table border="5" frame="border" align="center" width="90%"
cellpadding="5" summary= "table shows the steps are reversed on the remote side">
<thead>
<tr>
<th width="10%" bgcolor="#DEDEEF">Header</th>
<th bgcolor="#DEDEEF">Data</th>
<th width="10%" bgcolor="#DEDEEF">Digest</th>
<th width="10%" bgcolor="#DEDEEF">Padding (if any)</th>
</tr>
</thead>
</table>
-->
<p>Again, this is vastly simplified, but gives one an idea of how
these classes might be combined to create a higher level
protocol.</p>
<h2><a name="ExemptApps" id="ExemptApps">How to Make Applications
"Exempt" from Cryptographic Restrictions</a></h2>
<dl>
<dd><b>Note 1:</b> This section should be ignored by most
application developers. It is only for people whose applications
may be exported to those few countries whose governments mandate
cryptographic restrictions, if it is desired that such applications
have fewer cryptographic restrictions than those mandated. <b>Note
2:</b> Throughout this section, the term "application" is meant to
encompass both applications and applets.]</dd>
</dl>
<p>The JCA framework includes an ability to enforce restrictions
regarding the cryptographic algorithms and maximum cryptographic
strengths available to applets/applications in different
jurisdiction contexts (locations). Any such restrictions are
specified in "jurisdiction policy files".</p>
<p>Due to import control restrictions by the governments of a few
countries, the jurisdiction policy files shipped with the Java SE
Development Kit 6 specify that "strong" but limited cryptography
may be used. An "unlimited strength" version of these files
indicating no restrictions on cryptographic strengths is available
for those living in eligible countries (which is most countries).
But only the "strong" version can be imported into those countries
whose governments mandate restrictions. The JCA framework will
enforce the restrictions specified in the installed jurisdiction
policy files.</p>
<p>It is possible that the governments of some or all such
countries may allow certain applications to become exempt from some
or all cryptographic restrictions. For example, they may consider
certain types of applications as "special" and thus exempt. Or they
may exempt any application that utilizes an "exemption mechanism,"
such as key recovery. Applications deemed to be exempt could get
access to stronger cryptography than that allowed for non-exempt
applications in such countries.</p>
<p>In order for an application to be recognized as "exempt" at
runtime, it must meet the following conditions:</p>
<ul>
<li>It must have a permission policy file bundled with it in a JAR
file. The permission policy file specifies what
cryptography-related permissions the application has, and under
what conditions (if any).</li>
<li>The JAR file containing the application and the permission
policy file must have been signed using a code-signing certificate
issued after the application was accepted as exempt.</li>
</ul>
<p>Below are sample steps required in order to make an application
exempt from some or all cryptographic restrictions. This is a basic
outline that includes information about what is required by JCA in
order to recognize and treat applications as being exempt. You will
need to know the exemption requirements of the particular country
or countries in which you would like your application to be able to
be run but whose governments require cryptographic restrictions.
You will also need to know the requirements of a JCA framework
vendor that has a process in place for handling exempt
applications. Consult such a vendor for further information. (NOTE:
The <code>SunJCE</code> provider does not supply an implementation
of the ExemptionMechanismSpi class.)</p>
<ul>
<li>Step 1: Write and Compile Your Application Code</li>
<li>Step 2: Create a Permission Policy File Granting Appropriate
Cryptographic Permissions</li>
<li>Step 3: Prepare for Testing
<ul>
<li>Step 3a: Apply for Government Approval From the Government
Mandating Restrictions.</li>
<li>Step 3b: Get a Code-Signing Certificate</li>
<li>Step 3c: Bundle the Application and Permission Policy File into
a JAR file</li>
<li>Step 3d: <a href="HowToImplAProvider.html#Step61">Sign the JAR
file</a></li>
<li>Step 3e: Set Up Your Environment Like That of a User in a
Restricted Country</li>
<li>Step 3f: (only for applications using exemption mechanisms)
Install a Provider Implementing the Exemption Mechanism Specified
by the entry in the Permission Policy File</li>
</ul>
</li>
<li>Step 4: Test Your Application</li>
<li>Step 5: Apply for U.S. Government Export Approval If
Required</li>
<li>Step 6: Deploy Your Application</li>
</ul>
<br />
<h2>Special Code Requirements for Applications that Use Exemption
Mechanisms</h2>
<p>When an application has a permission policy file associated with
it (in the same JAR file) and that permission policy file specifies
an exemption mechanism, then when the Cipher
<code>getInstance</code> method is called to instantiate a Cipher,
the JCA code searches the installed providers for one that
implements the specified exemption mechanism. If it finds such a
provider, JCA instantiates an ExemptionMechanism API object
associated with the provider's implementation, and then associates
the ExemptionMechanism object with the Cipher returned by
<code>getInstance</code>.</p>
<p>After instantiating a Cipher, and prior to initializing it (via
a call to the Cipher <code>init</code> method), your code must call
the following Cipher method:</p>
<pre class="codeblock">
    public ExemptionMechanism getExemptionMechanism()
</pre>
<p>This call returns the ExemptionMechanism object associated with
the Cipher. You must then initialize the exemption mechanism
implementation by calling the following method on the returned
ExemptionMechanism:</p>
<pre class="codeblock">
    public final void init(Key key)
</pre>
<p>The argument you supply should be the same as the argument of
the same types that you will subsequently supply to a Cipher
<code>init</code> method.</p>
<p>Once you have initialized the ExemptionMechanism, you can
proceed as usual to initialize and use the Cipher.</p>
<h2>Permission Policy Files</h2>
<p>In order for an application to be recognized at runtime as being
"exempt" from some or all cryptographic restrictions, it must have
a permission policy file bundled with it in a JAR file. The
permission policy file specifies what cryptography-related
permissions the application has, and under what conditions (if
any).</p>
<dl>
<dd><b>NOTE:</b> The permission policy file bundled with an
application must be named <b><code>cryptoPerms</code></b>.</dd>
</dl>
<p>The format of a permission entry in a permission policy file
that accompanies an exempt application is the same as the format
for a jurisdiction policy file downloaded with the JDK, which
is:</p>
<pre class="codeblock">
    permission &lt;crypto permission class name&gt;[ &lt;alg_name&gt;
        [[, &lt;exemption mechanism name&gt;][, &lt;maxKeySize&gt;
        [, &lt;AlgorithmParameterSpec class name&gt;,
        &lt;parameters for constructing an AlgorithmParameterSpec object&gt;
        ]]]];
</pre>
<p>See <a href="#AppB">Appendix B</a> for more information about
the jurisdiction policy file format.</p>
<h3>Permission Policy Files for Exempt Applications</h3>
<p>Some applications may be allowed to be completely unrestricted.
Thus, the permission policy file that accompanies such an
application usually just needs to contain the following:</p>
<pre class="codeblock">
    grant {
        // There are no restrictions to any algorithms.
        permission javax.crypto.CryptoAllPermission;
    };
</pre>
<p>If an application just uses a single algorithm (or several
specific algorithms), then the permission policy file could simply
mention that algorithm (or algorithms) explicitly, rather than
granting CryptoAllPermission. For example, if an application just
uses the Blowfish algorithm, the permission policy file doesn't
have to grant CryptoAllPermission to all algorithms. It could just
specify that there is no cryptographic restriction if the Blowfish
algorithm is used. In order to do this, the permission policy file
would look like the following:</p>
<pre class="codeblock">
    grant {
        permission javax.crypto.CryptoPermission "Blowfish";
    };
</pre>
<h3>Permission Policy Files for Applications Exempt Due to
Exemption Mechanisms</h3>
<p>If an application is considered "exempt" if an exemption
mechanism is enforced, then the permission policy file that
accompanies the application must specify one or more exemption
mechanisms. At runtime, the application will be considered exempt
if any of those exemption mechanisms is enforced. Each exemption
mechanism must be specified in a permission entry that looks like
the following:</p>
<pre class="codeblock">
    // No algorithm restrictions if specified
    // exemption mechanism is enforced.
    permission javax.crypto.CryptoPermission *,
        "&lt;ExemptionMechanismName&gt;";
</pre>
<p>where <code>&lt;ExemptionMechanismName&gt;</code> specifies the
name of an exemption mechanism. The list of possible exemption
mechanism names includes:</p>
<ul>
<li>KeyRecovery</li>
<li>KeyEscrow</li>
<li>KeyWeakening</li>
</ul>
As an example, suppose your application is exempt if either key
recovery or key escrow is enforced. Then your permission policy
file should contain the following:
<pre class="codeblock">
    grant {
        // No algorithm restrictions if KeyRecovery is enforced.
        permission javax.crypto.CryptoPermission *,
            "KeyRecovery";
        // No algorithm restrictions if KeyEscrow is enforced.
        permission javax.crypto.CryptoPermission *,
            "KeyEscrow";
    };
</pre>
<p>NOTE: Permission entries that specify exemption mechanisms
should <i>not</i> also specify maximum key sizes. The allowed key
sizes are actually determined from the installed exempt
jurisdiction policy files, as described in the next section.</p>
<h3>How Bundled Permission Policy Files Affect Cryptographic
Permissions</h3>
<p>At runtime, when an application instantiates a Cipher (via a
call to its <code>getInstance</code> method) and that application
has an associated permission policy file, JCA checks to see whether
the permission policy file has an entry that applies to the
algorithm specified in the <code>getInstance</code> call. If it
does, and the entry grants CryptoAllPermission or does not specify
that an exemption mechanism must be enforced, it means there is no
cryptographic restriction for this particular algorithm.</p>
<p>If the permission policy file has an entry that applies to the
algorithm specified in the <code>getInstance</code> call and the
entry <i>does</i> specify that an exemption mechanism must be
enforced, then the exempt jurisdiction policy file(s) are examined.
If the exempt permissions include an entry for the relevant
algorithm and exemption mechanism, and that entry is implied by the
permissions in the permission policy file bundled with the
application, and if there is an implementation of the specified
exemption mechanism available from one of the registered providers,
then the maximum key size and algorithm parameter values for the
Cipher are determined from the exempt permission entry.</p>
<p>If there is no exempt permission entry implied by the relevant
entry in the permission policy file bundled with the application,
or if there is no implementation of the specified exemption
mechanism available from any of the registered providers, then the
application is only allowed the standard default cryptographic
permissions.</p>
<h2><a name="Examples" id="Examples">Code Examples</a></h2>
<p>Here are some short examples which illustrate use of several of
the JCA mechanisms. In addition, complete working examples can be
found in <a href="#AppD">Appendix D</a>.</p>
<h2><a name="MDEx" id="MDEx">Computing a <code>MessageDigest</code>
Object</a></h2>
<p>First create the <a href="#MessageDigest">message digest</a>
object, as in the following example:</p>
<pre class="codeblock">
MessageDigest sha = MessageDigest.getInstance("SHA-1");
</pre>
This call assigns a properly initialized message digest object to
the <code>sha</code> variable. The implementation implements the
Secure Hash Algorithm (SHA-1), as defined in the National Institute
for Standards and Technology's (NIST) <a href=
"http://csrc.nist.gov/publications/fips/index.html">FIPS 180-2
document</a>. See <a href="#AppA">Appendix A</a> for a complete
discussion of standard names and algorithms.
<p>Next, suppose we have three byte arrays, <code>i1</code>,
<code>i2</code> and <code>i3</code>, which form the total input
whose message digest we want to compute. This digest (or "hash")
could be calculated via the following calls:</p>
<pre class="codeblock">
sha.update(i1);
sha.update(i2);
sha.update(i3);
byte[] hash = sha.digest();
</pre>
<p>An equivalent alternative series of calls would be:</p>
<pre class="codeblock">
sha.update(i1);
sha.update(i2);
byte[] hash = sha.digest(i3);
</pre>
After the message digest has been calculated, the message digest
object is automatically reset and ready to receive new data and
calculate its digest. All former state (i.e., the data supplied to
<code>update</code> calls) is lost.
<p>Some hash implementations may support intermediate hashes
through cloning. Suppose we want to calculate separate hashes
for:</p>
<ul>
<li><code>i1</code></li>
<li><code>i1 and i2</code></li>
<li><code>i1, i2, and i3</code></li>
</ul>
<p>A way to do it is:</p>
<pre class="codeblock">
/* compute the hash for i1 */
sha.update(i1);
byte[] i1Hash = sha.clone().digest();

/* compute the hash for i1 and i2 */
sha.update(i2);
byte[] i12Hash = sha.clone().digest();

/* compute the hash for i1, i2 and i3 */
sha.update(i3);
byte[] i123hash = sha.digest();
</pre>
This code works only if the SHA-1 implementation is cloneable.
While some implementations of message digests are cloneable, others
are not. To determine whether or not cloning is possible, attempt
to clone the <code>MessageDigest</code> object and catch the
potential exception as follows:
<pre class="codeblock">
try {
    // try and clone it
    /* compute the hash for i1 */
    sha.update(i1);
    byte[] i1Hash = sha.clone().digest();
    // ...
    byte[] i123hash = sha.digest();
} catch (CloneNotSupportedException cnse) {
    // do something else, such as the code shown below
}
</pre>
If a message digest is not cloneable, the other, less elegant way
to compute intermediate digests is to create several digests. In
this case, the number of intermediate digests to be computed must
be known in advance:
<pre class="codeblock">
<code>MessageDigest</code> sha1 = MessageDigest.getInstance("SHA-1");
<code>MessageDigest</code> sha12 = MessageDigest.getInstance("SHA-1");
<code>MessageDigest</code> sha123 = MessageDigest.getInstance("SHA-1");

byte[] i1Hash = sha1.digest(i1);

sha12.update(i1);
byte[] i12Hash = sha12.digest(i2);

sha123.update(i1);
sha123.update(i2);
byte[] i123Hash = sha123.digest(i3);
</pre>
<h2><a name="KPGEx" id="KPGEx">Generating a Pair of Keys</a></h2>
<p>In this example we will generate a public-private key pair for
the algorithm named "DSA" (Digital Signature Algorithm), and use
this keypair in future examples. We will generate keys with a
1024-bit modulus. We don't care which provider supplies the
algorithm implementation.</p>
<h3>Creating the <a href="#KeyPairGenerator">Key Pair
Generator</a></h3>
<p>The first step is to get a key pair generator object for
generating keys for the DSA algorithm:</p>
<pre class="codeblock">
KeyPairGenerator keyGen = KeyPairGenerator.getInstance("DSA");
</pre>
<h3>Initializing the Key Pair Generator</h3>
<p>The next step is to initialize the key pair generator. In most
cases, algorithm-independent initialization is sufficient, but in
some cases, algorithm-specific initialization is used.</p>
<h4>Algorithm-Independent Initialization</h4>
<p>All key pair generators share the concepts of a keysize and a
source of randomness. The <code>KeyPairGenerator</code> class
initialization methods at a minimum needs a keysize. If the source
of randomness is not explicitly provided, a
<code>SecureRandom</code> implementation of the highest-priority
installed provider will be used. Thus to generate keys with a
keysize of 1024, simply call:</p>
<pre class="codeblock">
SecureRandom random = SecureRandom.getInstance("SHA1PRNG", "SUN");
keyGen.initialize(1024, random);
</pre>
The following code illustrates how to use a specific, additionally
seeded <a href="#SecureRandom"><code>SecureRandom</code></a>
object:
<pre class="codeblock">
SecureRandom random = SecureRandom.getInstance("SHA1PRNG", "SUN");
random.setSeed(userSeed);
keyGen.initialize(1024, random);
</pre>
Since no other parameters are specified when you call the above
algorithm-independent <code>initialize</code> method, it is up to
the provider what to do about the algorithm-specific parameters (if
any) to be associated with each of the keys. The provider may use
precomputed parameter values or may generate new values.
<h4>Algorithm-Specific Initialization</h4>
<p>For situations where a set of algorithm-specific parameters
already exists (such as "community parameters" in DSA), there are
two <code>initialize</code> methods that have an <a href=
"#AlgorithmParameterSpec"><code>AlgorithmParameterSpec</code></a>
argument. Suppose your key pair generator is for the "DSA"
algorithm, and you have a set of DSA-specific parameters,
<code>p</code>, <code>q</code>, and <code>g</code>, that you would
like to use to generate your key pair. You could execute the
following code to initialize your key pair generator (recall that
<code>DSAParameterSpec</code> is an AlgorithmParameterSpec):</p>
<pre class="codeblock">
DSAParameterSpec dsaSpec = new DSAParameterSpec(p, q, g);
SecureRandom random = SecureRandom.getInstance("SHA1PRNG", "SUN");
random.setSeed(userSeed);
keyGen.initialize(dsaSpec, random);
</pre>
<dl>
<dd><b>NOTE:</b> The parameter named <code>p</code> is a prime
number whose length is the modulus length ("size"). Therefore, you
don't need to call any other method to specify the modulus
length.</dd>
</dl>
<h3>Generating the Pair of Keys</h3>
<p>The final step is actually generating the key pair. No matter
which type of initialization was used (algorithm-independent or
algorithm-specific), the same code is used to generate the <a href=
"#KeyPair">key pair</a>:</p>
<pre class="codeblock">
KeyPair pair = keyGen.generateKeyPair();
</pre>
<h3><a name="SigEx" id="SigEx">Generating and Verifying a Signature
Using Generated Keys</a></h3>
<p>The following signature generation and verification examples use
the <code>KeyPair</code> generated in the <a href="#KPGEx">key pair
example</a> above.</p>
<h4>Generating a Signature</h4>
<p>We first create a <a href="#Signature">signature</a> object:</p>
<pre class="codeblock">
Signature dsa = Signature.getInstance("SHA1withDSA");
</pre>
<p>Next, using the key pair generated in the key pair example, we
initialize the object with the private key, then sign a byte array
called <code>data</code>.</p>
<pre class="codeblock">
/* Initializing the object with a private key */
PrivateKey priv = pair.getPrivate();
dsa.initSign(priv);

/* Update and sign the data */
dsa.update(data);
byte[] sig = dsa.sign();
</pre>
<h4><a name="VerifyEx" id="VerifyEx">Verifying a Signature</a></h4>
<p>Verifying the signature is straightforward. (Note that here we
also use the key pair generated in the key pair example.)</p>
<pre class="codeblock">
/* Initializing the object with the public key */
PublicKey pub = pair.getPublic();
dsa.initVerify(pub);

/* Update and verify the data */
dsa.update(data);
boolean verifies = dsa.verify(sig);
System.out.println("signature verifies: " + verifies);
</pre>
<h3><a name="KeyFactoryEx" id="KeyFactoryEx">Generating/Verifying
Signatures Using Key Specifications and
<code>KeyFactory</code></a></h3>
<p>Suppose that, rather than having a public/private key pair (as,
for example, was generated in the <a href="#KPGEx">key pair
example</a> above), you simply have the components of your DSA
private key: <code>x</code> (the private key), <code>p</code> (the
prime), <code>q</code> (the sub-prime), and <code>g</code> (the
base).</p>
<p>Further suppose you want to use your private key to digitally
sign some data, which is in a byte array named
<code>someData</code>. You would do the following steps, which also
illustrate creating a key specification and using a key factory to
obtain a <code>PrivateKey</code> from the key specification
(<code>initSign</code> requires a <code>PrivateKey</code>):</p>
<pre class="codeblock">
DSAPrivateKeySpec dsaPrivKeySpec = new DSAPrivateKeySpec(x, p, q, g);

KeyFactory keyFactory = KeyFactory.getInstance("DSA");
PrivateKey privKey = keyFactory.generatePrivate(dsaPrivKeySpec);

Signature sig = Signature.getInstance("SHA1withDSA");
sig.initSign(privKey);
sig.update(someData);
byte[] signature = sig.sign();
</pre>
<p>Suppose Alice wants to use the data you signed. In order for her
to do so, and to verify your signature, you need to send her three
things:</p>
<ol>
<li>the data,</li>
<li>the signature, and</li>
<li>the public key corresponding to the private key you used to
sign the data.</li>
</ol>
<p>You can store the <code>someData</code> bytes in one file, and
the <code>signature</code> bytes in another, and send those to
Alice.</p>
<p>For the public key, assume, as in the signing example above, you
have the components of the DSA public key corresponding to the DSA
private key used to sign the data. Then you can create a
<code>DSAPublicKeySpec</code> from those components:</p>
<pre class="codeblock">
DSAPublicKeySpec dsaPubKeySpec = new DSAPublicKeySpec(y, p, q, g);
</pre>
<p>You still need to extract the key bytes so that you can put them
in a file. To do so, you can first call the
<code>generatePublic</code> method on the DSA key factory already
created in the example above:</p>
<pre class="codeblock">
PublicKey pubKey = keyFactory.generatePublic(dsaPubKeySpec);
</pre>
Then you can extract the (encoded) key bytes via the following:
<pre class="codeblock">
byte[] encKey = pubKey.getEncoded();
</pre>
<p>You can now store these bytes in a file, and send it to Alice
along with the files containing the data and the signature.</p>
<p>Now, assume Alice has received these files, and she copied the
data bytes from the data file to a byte array named
<code>data</code>, the signature bytes from the signature file to a
byte array named <code>signature</code>, and the encoded public key
bytes from the public key file to a byte array named
<code>encodedPubKey</code>.</p>
<p>Alice can now execute the following code to verify the
signature. The code also illustrates how to use a key factory in
order to instantiate a DSA public key from its encoding
(<code>initVerify</code> requires a <code>PublicKey</code>).</p>
<pre class="codeblock">
    X509EncodedKeySpec pubKeySpec = new X509EncodedKeySpec(encodedPubKey);

    KeyFactory keyFactory = KeyFactory.getInstance("DSA");
    PublicKey pubKey = keyFactory.generatePublic(pubKeySpec);

    Signature sig = Signature.getInstance("SHA1withDSA");
    sig.initVerify(pubKey);
    sig.update(data);
    sig.verify(signature);
</pre>
NOTE: In the above, Alice needed to generate a
<code>PublicKey</code> from the encoded key bits, since
<code>initVerify</code> requires a <code>PublicKey</code>. Once she
has a <code>PublicKey</code>, she could also use the
<code>KeyFactory</code> <code>getKeySpec</code> method to convert
it to a <code>DSAPublicKeySpec</code> so that she can access the
components, if desired, as in:
<pre class="codeblock">
    DSAPublicKeySpec dsaPubKeySpec =
        (DSAPublicKeySpec)keyFactory.getKeySpec(pubKey,
            DSAPublicKeySpec.class)
</pre>
<p>Now she can access the DSA public key components <code>y</code>,
<code>p</code>, <code>q</code>, and <code>g</code> through the
corresponding "get" methods on the <code>DSAPublicKeySpec</code>
class (<code>getY</code>, <code>getP</code>, <code>getQ</code>, and
<code>getG</code>). <a name="Equal" id="Equal"></a></p>
<h3>Determining If Two Keys Are Equal</h3>
<p>In many cases you would like to know if two keys are equal;
however, the default method <code>java.lang.Object.equals</code>
may not give the desired result. The most provider-independent
approach is to compare the encoded keys. If this comparison isn't
appropriate (for example, when comparing an
<code>RSAPrivateKey</code> and an <code>RSAPrivateCrtKey</code>),
you should compare each component. The following code demonstrates
this idea:</p>
<pre class="codeblock">
static boolean keysEqual(Key key1, Key key2) {
    if (key1.equals(key2)) {
        return true;
    }

    if (Arrays.equals(key1.getEncoded(), key2.getEncoded())) {
        return true;
    }

    // More code for different types of keys here.
    // For example, the following code can check if
    // an RSAPrivateKey and an RSAPrivateCrtKey are equal:
    // if ((key1 instanceof RSAPrivateKey) &amp;&amp;
    //     (key2 instanceof RSAPrivateKey)) {
    //     if ((key1.getModulus().equals(key2.getModulus())) &amp;&amp;
    //         (key1.getPrivateExponent().equals(
    //                                      key2.getPrivateExponent()))) {
    //         return true;
    //     }
    // }

    return false;
}
</pre>
<h3><a name="ReadCert" id="ReadCert">Reading Base64-Encoded
Certificates</a></h3>
<p>The following example reads a file with Base64-encoded
certificates, which are each bounded at the beginning by</p>
<pre class="codeblock">
-----BEGIN CERTIFICATE-----
</pre>
and at the end by
<pre class="codeblock">
-----END CERTIFICATE-----
</pre>
We convert the <code>FileInputStream</code> (which does not support
<code>mark</code> and <code>reset</code>) to a
<code>ByteArrayInputStream</code> (which supports those methods),
so that each call to <code>generateCertificate</code> consumes only
one certificate, and the read position of the input stream is
positioned to the next certificate in the file:
<pre class="codeblock">
FileInputStream fis = new FileInputStream(filename);
BufferedInputStream bis = new BufferedInputStream(fis);

CertificateFactory cf = CertificateFactory.getInstance("X.509");

while (bis.available() &gt; 0) {
    Certificate cert = cf.generateCertificate(bis);
    System.out.println(cert.toString());
}
</pre>
<h3><a name="ParseCert" id="ParseCert">Parsing a Certificate
Reply</a></h3>
<p>The following example parses a PKCS7-formatted certificate reply
stored in a file and extracts all the certificates from it:</p>
<pre class="codeblock">
FileInputStream fis = new FileInputStream(filename);
CertificateFactory cf = CertificateFactory.getInstance("X.509");
Collection c = cf.generateCertificates(fis);
Iterator i = c.iterator();
while (i.hasNext()) {
   Certificate cert = (Certificate)i.next();
   System.out.println(cert);
}
</pre>
<h3><a name="SimpleEncrEx" id="SimpleEncrEx">Using
Encryption</a></h3>
<p>This section takes the user through the process of generating a
key, creating and initializing a cipher object, encrypting a file,
and then decrypting it. Throughout this example, we use the
Advanced Encryption Standard (AES).</p>
<h4>Generating a Key</h4>
<p>To create an AES key, we have to instantiate a KeyGenerator for
AES. We do not specify a provider, because we do not care about a
particular AES key generation implementation. Since we do not
initialize the KeyGenerator, a system-provided source of randomness
and a default keysize will be used to create the AES key:</p>
<pre class="codeblock">
    KeyGenerator keygen = KeyGenerator.getInstance("AES");
    SecretKey aesKey = keygen.generateKey();
</pre>
<p>After the key has been generated, the same KeyGenerator object
can be re-used to create further keys.</p>
<h4>Creating a Cipher</h4>
<p>The next step is to create a Cipher instance. To do this, we use
one of the <code>getInstance</code> factory methods of the Cipher
class. We must specify the name of the requested transformation,
which includes the following components, separated by slashes
(/):</p>
<ul>
<li>the algorithm name</li>
<li>the mode (optional)</li>
<li>the padding scheme (optional)</li>
</ul>
<p>In this example, we create an AES cipher in Electronic Codebook
mode, with PKCS5-style padding. We do not specify a provider,
because we do not care about a particular implementation of the
requested transformation.</p>
<p>The standard algorithm name for AES is "AES", the standard name
for the Electronic Codebook mode is "ECB", and the standard name
for PKCS5-style padding is "PKCS5Padding":</p>
<pre class="codeblock">
    Cipher aesCipher;

    // Create the cipher
    aesCipher = Cipher.getInstance("AES/ECB/PKCS5Padding");
</pre>
<p>We use the generated <code>aesKey</code> from above to
initialize the Cipher object for encryption:</p>
<pre class="codeblock">
    // Initialize the cipher for encryption
    aesCipher.init(Cipher.ENCRYPT_MODE, aesKey);

    // Our cleartext
    byte[] cleartext = "This is just an example".getBytes();

    // Encrypt the cleartext
    byte[] ciphertext = aesCipher.doFinal(cleartext);

    // Initialize the same cipher for decryption
    aesCipher.init(Cipher.DECRYPT_MODE, aesKey);

    // Decrypt the ciphertext
    byte[] cleartext1 = aesCipher.doFinal(ciphertext);
</pre>
<p><code>cleartext</code> and <code>cleartext1</code> are
identical.</p>
<h3><a name="PBEEx" id="PBEEx">Using Password-Based
Encryption</a></h3>
<p>In this example, we prompt the user for a password from which we
derive an encryption key.</p>
<p>It would seem logical to collect and store the password in an
object of type <code>java.lang.String</code>. However, here's the
caveat: Objects of type <code>String</code> are immutable, i.e.,
there are no methods defined that allow you to change (overwrite)
or zero out the contents of a <code>String</code> after usage. This
feature makes <code>String</code> objects unsuitable for storing
security sensitive information such as user passwords. You should
always collect and store security sensitive information in a char
array instead.</p>
<p>For that reason, the <code>javax.crypto.spec.PBEKeySpec</code>
class takes (and returns) a password as a char array. See the
<a href="#ReadPassword">ReadPassword</a> class in the sample code
in <a href="#AppD">Appendix D</a> for one possible way of reading
character array passwords from an input stream.</p>
<p>In order to use Password-Based Encryption (PBE) as defined in
PKCS5, we have to specify a <i>salt</i> and an <i>iteration
count</i>. The same salt and iteration count that are used for
encryption must be used for decryption. Newer PBE algorithms use an iteration count of atleast 1000.</p>
<pre class="codeblock">
            PBEKeySpec pbeKeySpec;
            PBEParameterSpec pbeParamSpec;
            SecretKeyFactory keyFac;

            // Salt
            byte[] salt = {
                (byte)0xc7, (byte)0x73, (byte)0x21, (byte)0x8c,
                (byte)0x7e, (byte)0xc8, (byte)0xee, (byte)0x99
            };

            // Iteration count
            int count = 1000;

            // Create PBE parameter set
            pbeParamSpec = new PBEParameterSpec(salt, count);

            // Prompt user for encryption password.
            // Collect user password as char array (using the
            // "readPassword" method from above), and convert
            // it into a SecretKey object, using a PBE key
            // factory.
            System.out.print("Enter encryption password:  ");
            System.out.flush();
            pbeKeySpec = new PBEKeySpec(readPassword(System.in));
            keyFac = SecretKeyFactory.getInstance("PBEWithHmacSHA256AndAES_256");
            SecretKey pbeKey = keyFac.generateSecret(pbeKeySpec);

            // Create PBE Cipher
            Cipher pbeCipher = Cipher.getInstance("PBEWithHmacSHA256AndAES_256");

            // Initialize PBE Cipher with key and parameters
            pbeCipher.init(Cipher.ENCRYPT_MODE, pbeKey, pbeParamSpec);

            // Our cleartext
            byte[] cleartext = "This is another example".getBytes();

            // Encrypt the cleartext
            byte[] ciphertext = pbeCipher.doFinal(cleartext);

</pre>
<h3><a name="KeyAgreeEx" id="KeyAgreeEx">Using Key
Agreement</a></h3>
<p>Please refer to <a href="#AppD">Appendix D</a> for sample
programs exercising the Diffie-Hellman key exchange between 2 and 3
parties.</p>
<hr />
<!-- ==================================================== -->
<h2><a name="AppA" id="AppA">Appendix A: Standard Names</a></h2>
<p>The JDK Security API requires and uses a set of standard names
for algorithms, certificate and keystore types. The specification
names previously found here in Appendix A and in the other security
specifications (JSSE/CertPath/etc.) have been combined in the
<a href="../StandardNames.html">Standard Names document</a>. This
document also contains more information about the algorithm
specifications. Specific provider information can be found in the
<a href="../SunProviders.html">Sun Provider Documentation</a>.</p>
<p>Cryptographic implementations in the JDK are distributed through
several different providers primarily for historical reasons
(<code>Sun</code>, <code>SunJSSE</code>, <code>SunJCE</code>,
<code>SunRsaSign</code>). Note these providers may not be available
on all JDK implementations, and therefore, truly portable
applications should call <code>getInstance()</code> without
specifying specific providers. Applications specifying a particular
provider may not be able to take advantage of native providers
tuned for an underlying operating environment (such as PKCS or
Microsoft's CAPI).</p>
<p>The <code>SunPKCS11</code> provider itself does not contain any
cryptographic algorithms, but instead, directs requests into an
underlying PKCS11 implementation. The <a href=
"../p11guide.html">PKCS11 Reference Guide</a> and the underlying
PKCS11 implementation should be consulted to determine if a desired
algorithm will be available through the PKCS11 provider. Likewise,
on Windows systems, the <code>SunMSCAPI</code> provider does not
provide any cryptographic functionality, but instead routes
requests to the underlying Operating System for handling.</p>
<hr />
<!-- ==================================================== -->
<h2><a name="AppB" id="AppB">Appendix B: Jurisdiction Policy File
Format</a></h2>
<p>JCA represents its jurisdiction policy files as Java style
policy files with corresponding permission statements. As described
in <a href="../PolicyFiles.html">Default Policy Implementation and
Policy File Syntax</a>, a Java policy file specifies what
permissions are allowed for code from specified code sources. A
permission represents access to a system resource. In the case of
JCA, the "resources" are cryptography algorithms, and code sources
do not need to be specified, because the cryptographic restrictions
apply to all code.</p>
<p>A jurisdiction policy file consists of a very basic "grant
entry" containing one or more "permission entries."</p>
<pre class="codeblock">
grant {<br />    &lt;permission entries&gt;;<br />};<br />
</pre>
<p>The format of a permission entry in a jurisdiction policy file
is:</p>
<pre class="codeblock">
permission &lt;crypto permission class name&gt;[ &lt;alg_name&gt;
    [[, &lt;exemption mechanism name&gt;][, &lt;maxKeySize&gt;
    [, &lt;AlgorithmParameterSpec class name&gt;,
    &lt;parameters for constructing an
        AlgorithmParameterSpec object&gt;]]]];
</pre>
<p>A sample jurisdiction policy file that includes restricting the
"Blowfish" algorithm to maximum key sizes of 64 bits is:</p>
<pre class="codeblock">
    grant {
        permission javax.crypto.CryptoPermission "Blowfish", 64;
        // ...
    };

</pre>
<p>A permission entry must begin with the word
<code>permission</code>. The <code>&lt;crypto permission class
name&gt;</code> in the template above would actually be a specific
permission class name, such as
<code>javax.crypto.CryptoPermission</code>. A crypto permission
class reflects the ability of an application/applet to use certain
algorithms with certain key sizes in certain environments. There
are two crypto permission classes: <code>CryptoPermission</code>
and <code>CryptoAllPermission</code>. The special
<code>CryptoAllPermission</code> class implies all
cryptography-related permissions, that is, it specifies that there
are no cryptography-related restrictions.</p>
<p>The &lt;alg_name&gt;, when utilized, is a quoted string
specifying the standard name (see <a href="#AppA">Appendix A</a>)
of a cryptography algorithm, such as "DES" or "RSA".</p>
<p>The &lt;exemption mechanism name&gt;, when specified, is a
quoted string indicating an exemption mechanism which, if enforced,
enables a reduction in cryptographic restrictions. Exemption
mechanism names that can be used include "KeyRecovery" "KeyEscrow",
and "KeyWeakening".</p>
<p>&lt;maxKeySize&gt; is an integer specifying the maximum key size
(in bits) allowed for the specified algorithm.</p>
<p>For some algorithms it may not be sufficient to specify the
algorithm strength in terms of just a key size. For example, in the
case of the "RC5" algorithm, the number of rounds must also be
considered. For algorithms whose strength needs to be expressed as
more than a key size, the permission entry should also specify an
AlgorithmParameterSpec class name (such as
<code>javax.crypto.spec.RC5ParameterSpec</code>) and a list of
parameters for constructing the specified AlgorithmParameterSpec
object.</p>
<p>Items that appear in a permission entry must appear in the
specified order. An entry is terminated with a semicolon.</p>
<p>Case is unimportant for the identifiers (<code>grant</code>,
<code>permission</code>) but is significant for the
<code>&lt;crypto permission class name&gt;</code> or for any string
that is passed in as a value.</p>
<p>NOTE: An "*" can be used as a wildcard for any permission entry
option. For example, an "*" (without the quotes) for an
&lt;alg_name&gt; option means "all algorithms."</p>
<hr />
<!-- ==================================================== -->
<h2><a name="AppC" id="AppC">Appendix C: Maximum Key Sizes Allowed
by "Strong" Jurisdiction Policy Files</a></h2>
<p>Due to import control restrictions, the jurisdiction policy
files shipped with the Java SE Development Kit allow "strong" but
limited cryptography to be used. For more info, please see <a href=
"../SunProviders.html#importlimits">Import Limits on Cryptographic
Algorithms</a>.</p>
<hr />
<!-- ==================================================== -->
<h2><a name="AppD" id="AppD">Appendix D: Sample Programs</a></h2>
<a name="DH2Ex" id="DH2Ex"></a>
<h2>Diffie-Hellman Key Exchange between 2 Parties</h2>
<pre class="codeblock">
/*
 * Copyright (c) 1997, 2001, Oracle and/or its affiliates. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *   - Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *
 *   - Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 *   - Neither the name of Oracle nor the names of its
 *     contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
 * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

import java.io.*;
import java.math.BigInteger;
import java.security.*;
import java.security.spec.*;
import java.security.interfaces.*;
import javax.crypto.*;
import javax.crypto.spec.*;
import javax.crypto.interfaces.*;
import com.sun.crypto.provider.SunJCE;

/**
 * This program executes the Diffie-Hellman key agreement protocol
 * between 2 parties: Alice and Bob.
 *
 * By default, preconfigured parameters (1024-bit prime modulus and base
 * generator used by SKIP) are used.
 * If this program is called with the "-gen" option, a new set of
 * parameters is created.
 */

public class DHKeyAgreement2 {

    private DHKeyAgreement2() {}

    public static void main(String argv[]) {
        try {
            String mode = "USE_SKIP_DH_PARAMS";

            DHKeyAgreement2 keyAgree = new DHKeyAgreement2();

            if (argv.length &gt; 1) {
                keyAgree.usage();
                throw new Exception("Wrong number of command options");
            } else if (argv.length == 1) {
                if (!(argv[0].equals("-gen"))) {
                    keyAgree.usage();
                    throw new Exception("Unrecognized flag: " + argv[0]);
                }
                mode = "GENERATE_DH_PARAMS";
            }

            keyAgree.run(mode);
        } catch (Exception e) {
            System.err.println("Error: " + e);
            System.exit(1);
        }
    }

    private void run(String mode) throws Exception {

        DHParameterSpec dhSkipParamSpec;

        if (mode.equals("GENERATE_DH_PARAMS")) {
            // Some central authority creates new DH parameters
            System.out.println
                ("Creating Diffie-Hellman parameters (takes VERY long) ...");
            AlgorithmParameterGenerator paramGen
                = AlgorithmParameterGenerator.getInstance("DH");
            paramGen.init(512);
            AlgorithmParameters params = paramGen.generateParameters();
            dhSkipParamSpec = (DHParameterSpec)params.getParameterSpec
                (DHParameterSpec.class);
        } else {
            // use some pre-generated, default DH parameters
            System.out.println("Using SKIP Diffie-Hellman parameters");
            dhSkipParamSpec = new DHParameterSpec(skip1024Modulus,
                                                  skip1024Base);
        }

        /*
         * Alice creates her own DH key pair, using the DH parameters from
         * above
         */
        System.out.println("ALICE: Generate DH keypair ...");
        KeyPairGenerator aliceKpairGen = KeyPairGenerator.getInstance("DH");
        aliceKpairGen.initialize(dhSkipParamSpec);
        KeyPair aliceKpair = aliceKpairGen.generateKeyPair();

        // Alice creates and initializes her DH KeyAgreement object
        System.out.println("ALICE: Initialization ...");
        KeyAgreement aliceKeyAgree = KeyAgreement.getInstance("DH");
        aliceKeyAgree.init(aliceKpair.getPrivate());

        // Alice encodes her public key, and sends it over to Bob.
        byte[] alicePubKeyEnc = aliceKpair.getPublic().getEncoded();

        /*
         * Let's turn over to Bob. Bob has received Alice's public key
         * in encoded format.
         * He instantiates a DH public key from the encoded key material.
         */
        KeyFactory bobKeyFac = KeyFactory.getInstance("DH");
        X509EncodedKeySpec x509KeySpec = new X509EncodedKeySpec
            (alicePubKeyEnc);
        PublicKey alicePubKey = bobKeyFac.generatePublic(x509KeySpec);

        /*
         * Bob gets the DH parameters associated with Alice's public key.
         * He must use the same parameters when he generates his own key
         * pair.
         */
        DHParameterSpec dhParamSpec = ((DHPublicKey)alicePubKey).getParams();

        // Bob creates his own DH key pair
        System.out.println("BOB: Generate DH keypair ...");
        KeyPairGenerator bobKpairGen = KeyPairGenerator.getInstance("DH");
        bobKpairGen.initialize(dhParamSpec);
        KeyPair bobKpair = bobKpairGen.generateKeyPair();

        // Bob creates and initializes his DH KeyAgreement object
        System.out.println("BOB: Initialization ...");
        KeyAgreement bobKeyAgree = KeyAgreement.getInstance("DH");
        bobKeyAgree.init(bobKpair.getPrivate());

        // Bob encodes his public key, and sends it over to Alice.
        byte[] bobPubKeyEnc = bobKpair.getPublic().getEncoded();

        /*
         * Alice uses Bob's public key for the first (and only) phase
         * of her version of the DH
         * protocol.
         * Before she can do so, she has to instantiate a DH public key
         * from Bob's encoded key material.
         */
        KeyFactory aliceKeyFac = KeyFactory.getInstance("DH");
        x509KeySpec = new X509EncodedKeySpec(bobPubKeyEnc);
        PublicKey bobPubKey = aliceKeyFac.generatePublic(x509KeySpec);
        System.out.println("ALICE: Execute PHASE1 ...");
        aliceKeyAgree.doPhase(bobPubKey, true);

        /*
         * Bob uses Alice's public key for the first (and only) phase
         * of his version of the DH
         * protocol.
         */
        System.out.println("BOB: Execute PHASE1 ...");
        bobKeyAgree.doPhase(alicePubKey, true);

        /*
         * At this stage, both Alice and Bob have completed the DH key
         * agreement protocol.
         * Both generate the (same) shared secret.
         */
        byte[] aliceSharedSecret = aliceKeyAgree.generateSecret();
        int aliceLen = aliceSharedSecret.length;

        byte[] bobSharedSecret = new byte[aliceLen];
        int bobLen;
        try {
            // show example of what happens if you
            // provide an output buffer that is too short
            bobLen = bobKeyAgree.generateSecret(bobSharedSecret, 1);
        } catch (ShortBufferException e) {
            System.out.println(e.getMessage());
        }
        // provide output buffer of required size
        bobLen = bobKeyAgree.generateSecret(bobSharedSecret, 0);

        System.out.println("Alice secret: " +
          toHexString(aliceSharedSecret));
        System.out.println("Bob secret: " +
          toHexString(bobSharedSecret));

        if (!java.util.Arrays.equals(aliceSharedSecret, bobSharedSecret))
            throw new Exception("Shared secrets differ");
        System.out.println("Shared secrets are the same");

        /*
         * Now let's return the shared secret as a SecretKey object
         * and use it for encryption. First, we generate SecretKeys for the
         * "DES" algorithm (based on the raw shared secret data) and
         * then we use DES in ECB mode
         * as the encryption algorithm. DES in ECB mode does not require any
         * parameters.
         *
         * Then we use DES in CBC mode, which requires an initialization
         * vector (IV) parameter. In CBC mode, you need to initialize the
         * Cipher object with an IV, which can be supplied using the
         * javax.crypto.spec.IvParameterSpec class. Note that you have to use
         * the same IV for encryption and decryption: If you use a different
         * IV for decryption than you used for encryption, decryption will
         * fail.
         *
         * NOTE: If you do not specify an IV when you initialize the
         * Cipher object for encryption, the underlying implementation
         * will generate a random one, which you have to retrieve using the
         * javax.crypto.Cipher.getParameters() method, which returns an
         * instance of java.security.AlgorithmParameters. You need to transfer
         * the contents of that object (e.g., in encoded format, obtained via
         * the AlgorithmParameters.getEncoded() method) to the party who will
         * do the decryption. When initializing the Cipher for decryption,
         * the (reinstantiated) AlgorithmParameters object must be passed to
         * the Cipher.init() method.
         */
        System.out.println("Return shared secret as SecretKey object ...");
        // Bob
        // NOTE: The call to bobKeyAgree.generateSecret above reset the key
        // agreement object, so we call doPhase again prior to another
        // generateSecret call
        bobKeyAgree.doPhase(alicePubKey, true);
        SecretKey bobDesKey = bobKeyAgree.generateSecret("DES");

        // Alice
        // NOTE: The call to aliceKeyAgree.generateSecret above reset the key
        // agreement object, so we call doPhase again prior to another
        // generateSecret call
        aliceKeyAgree.doPhase(bobPubKey, true);
        SecretKey aliceDesKey = aliceKeyAgree.generateSecret("DES");

        /*
         * Bob encrypts, using DES in ECB mode
         */
        Cipher bobCipher = Cipher.getInstance("DES/ECB/PKCS5Padding");
        bobCipher.init(Cipher.ENCRYPT_MODE, bobDesKey);

        byte[] cleartext = "This is just an example".getBytes();
        byte[] ciphertext = bobCipher.doFinal(cleartext);

        /*
         * Alice decrypts, using DES in ECB mode
         */
        Cipher aliceCipher = Cipher.getInstance("DES/ECB/PKCS5Padding");
        aliceCipher.init(Cipher.DECRYPT_MODE, aliceDesKey);
        byte[] recovered = aliceCipher.doFinal(ciphertext);

        if (!java.util.Arrays.equals(cleartext, recovered))
            throw new Exception("DES in CBC mode recovered text is " +
              "different from cleartext");
        System.out.println("DES in ECB mode recovered text is " +
            "same as cleartext");

        /*
         * Bob encrypts, using DES in CBC mode
         */
        bobCipher = Cipher.getInstance("DES/CBC/PKCS5Padding");
        bobCipher.init(Cipher.ENCRYPT_MODE, bobDesKey);

        cleartext = "This is just an example".getBytes();
        ciphertext = bobCipher.doFinal(cleartext);
        // Retrieve the parameter that was used, and transfer it to Alice in
        // encoded format
        byte[] encodedParams = bobCipher.getParameters().getEncoded();

        /*
         * Alice decrypts, using DES in CBC mode
         */
        // Instantiate AlgorithmParameters object from parameter encoding
        // obtained from Bob
        AlgorithmParameters params = AlgorithmParameters.getInstance("DES");
        params.init(encodedParams);
        aliceCipher = Cipher.getInstance("DES/CBC/PKCS5Padding");
        aliceCipher.init(Cipher.DECRYPT_MODE, aliceDesKey, params);
        recovered = aliceCipher.doFinal(ciphertext);

        if (!java.util.Arrays.equals(cleartext, recovered))
            throw new Exception("DES in CBC mode recovered text is " +
              "different from cleartext");
        System.out.println("DES in CBC mode recovered text is " +
            "same as cleartext");
    }

    /*
     * Converts a byte to hex digit and writes to the supplied buffer
     */
    private void byte2hex(byte b, StringBuffer buf) {
        char[] hexChars = { '0', '1', '2', '3', '4', '5', '6', '7', '8',
                            '9', 'A', 'B', 'C', 'D', 'E', 'F' };
        int high = ((b &amp; 0xf0) &gt;&gt; 4);
        int low = (b &amp; 0x0f);
        buf.append(hexChars[high]);
        buf.append(hexChars[low]);
    }

    /*
     * Converts a byte array to hex string
     */
    private String toHexString(byte[] block) {
        StringBuffer buf = new StringBuffer();

        int len = block.length;

        for (int i = 0; i &lt; len; i++) {
             byte2hex(block[i], buf);
             if (i &lt; len-1) {
                 buf.append(":");
             }
        }
        return buf.toString();
    }

    /*
     * Prints the usage of this test.
     */
    private void usage() {
        System.err.print("DHKeyAgreement usage: ");
        System.err.println("[-gen]");
    }

    // The 1024 bit Diffie-Hellman modulus values used by SKIP
    private static final byte skip1024ModulusBytes[] = {
        (byte)0xF4, (byte)0x88, (byte)0xFD, (byte)0x58,
        (byte)0x4E, (byte)0x49, (byte)0xDB, (byte)0xCD,
        (byte)0x20, (byte)0xB4, (byte)0x9D, (byte)0xE4,
        (byte)0x91, (byte)0x07, (byte)0x36, (byte)0x6B,
        (byte)0x33, (byte)0x6C, (byte)0x38, (byte)0x0D,
        (byte)0x45, (byte)0x1D, (byte)0x0F, (byte)0x7C,
        (byte)0x88, (byte)0xB3, (byte)0x1C, (byte)0x7C,
        (byte)0x5B, (byte)0x2D, (byte)0x8E, (byte)0xF6,
        (byte)0xF3, (byte)0xC9, (byte)0x23, (byte)0xC0,
        (byte)0x43, (byte)0xF0, (byte)0xA5, (byte)0x5B,
        (byte)0x18, (byte)0x8D, (byte)0x8E, (byte)0xBB,
        (byte)0x55, (byte)0x8C, (byte)0xB8, (byte)0x5D,
        (byte)0x38, (byte)0xD3, (byte)0x34, (byte)0xFD,
        (byte)0x7C, (byte)0x17, (byte)0x57, (byte)0x43,
        (byte)0xA3, (byte)0x1D, (byte)0x18, (byte)0x6C,
        (byte)0xDE, (byte)0x33, (byte)0x21, (byte)0x2C,
        (byte)0xB5, (byte)0x2A, (byte)0xFF, (byte)0x3C,
        (byte)0xE1, (byte)0xB1, (byte)0x29, (byte)0x40,
        (byte)0x18, (byte)0x11, (byte)0x8D, (byte)0x7C,
        (byte)0x84, (byte)0xA7, (byte)0x0A, (byte)0x72,
        (byte)0xD6, (byte)0x86, (byte)0xC4, (byte)0x03,
        (byte)0x19, (byte)0xC8, (byte)0x07, (byte)0x29,
        (byte)0x7A, (byte)0xCA, (byte)0x95, (byte)0x0C,
        (byte)0xD9, (byte)0x96, (byte)0x9F, (byte)0xAB,
        (byte)0xD0, (byte)0x0A, (byte)0x50, (byte)0x9B,
        (byte)0x02, (byte)0x46, (byte)0xD3, (byte)0x08,
        (byte)0x3D, (byte)0x66, (byte)0xA4, (byte)0x5D,
        (byte)0x41, (byte)0x9F, (byte)0x9C, (byte)0x7C,
        (byte)0xBD, (byte)0x89, (byte)0x4B, (byte)0x22,
        (byte)0x19, (byte)0x26, (byte)0xBA, (byte)0xAB,
        (byte)0xA2, (byte)0x5E, (byte)0xC3, (byte)0x55,
        (byte)0xE9, (byte)0x2F, (byte)0x78, (byte)0xC7
    };

    // The SKIP 1024 bit modulus
    private static final BigInteger skip1024Modulus
    = new BigInteger(1, skip1024ModulusBytes);

    // The base used with the SKIP 1024 bit modulus
    private static final BigInteger skip1024Base = BigInteger.valueOf(2);
}
</pre>
<hr />
<a name="DH3Ex" id="DH3Ex"></a>
<h2>Diffie-Hellman Key Exchange between 3 Parties</h2>
<pre class="codeblock">
/*
 * Copyright (c) 1997, 2001, Oracle and/or its affiliates. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *   - Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *
 *   - Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 *   - Neither the name of Oracle nor the names of its
 *     contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
 * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

import java.io.*;
import java.math.BigInteger;
import java.security.*;
import java.security.spec.*;
import java.security.interfaces.*;
import javax.crypto.*;
import javax.crypto.spec.*;
import javax.crypto.interfaces.*;
import com.sun.crypto.provider.SunJCE;

/**
 * This program executes the Diffie-Hellman key agreement protocol
 * between 3 parties: Alice, Bob, and Carol.
 *
 * We use the same 1024-bit prime modulus and base generator that are
 * used by SKIP.
 */

public class DHKeyAgreement3 {

    private DHKeyAgreement3() {}

    public static void main(String argv[]) {
        try {
            DHKeyAgreement3 keyAgree = new DHKeyAgreement3();
            keyAgree.run();
        } catch (Exception e) {
            System.err.println("Error: " + e);
            System.exit(1);
        }
    }

    private void run() throws Exception {

        DHParameterSpec dhSkipParamSpec;

        System.out.println("Using SKIP Diffie-Hellman parameters");
        dhSkipParamSpec = new DHParameterSpec(skip1024Modulus, skip1024Base);

        // Alice creates her own DH key pair
        System.out.println("ALICE: Generate DH keypair ...");
        KeyPairGenerator aliceKpairGen = KeyPairGenerator.getInstance("DH");
        aliceKpairGen.initialize(dhSkipParamSpec);
        KeyPair aliceKpair = aliceKpairGen.generateKeyPair();

        // Bob creates his own DH key pair
        System.out.println("BOB: Generate DH keypair ...");
        KeyPairGenerator bobKpairGen = KeyPairGenerator.getInstance("DH");
        bobKpairGen.initialize(dhSkipParamSpec);
        KeyPair bobKpair = bobKpairGen.generateKeyPair();

        // Carol creates her own DH key pair
        System.out.println("CAROL: Generate DH keypair ...");
        KeyPairGenerator carolKpairGen = KeyPairGenerator.getInstance("DH");
        carolKpairGen.initialize(dhSkipParamSpec);
        KeyPair carolKpair = carolKpairGen.generateKeyPair();


        // Alice initialize
        System.out.println("ALICE: Initialize ...");
        KeyAgreement aliceKeyAgree = KeyAgreement.getInstance("DH");
        aliceKeyAgree.init(aliceKpair.getPrivate());

        // Bob initialize
        System.out.println("BOB: Initialize ...");
        KeyAgreement bobKeyAgree = KeyAgreement.getInstance("DH");
        bobKeyAgree.init(bobKpair.getPrivate());

        // Carol initialize
        System.out.println("CAROL: Initialize ...");
        KeyAgreement carolKeyAgree = KeyAgreement.getInstance("DH");
        carolKeyAgree.init(carolKpair.getPrivate());


        // Alice uses Carol's public key
        Key ac = aliceKeyAgree.doPhase(carolKpair.getPublic(), false);

        // Bob uses Alice's public key
        Key ba = bobKeyAgree.doPhase(aliceKpair.getPublic(), false);

        // Carol uses Bob's public key
        Key cb = carolKeyAgree.doPhase(bobKpair.getPublic(), false);


        // Alice uses Carol's result from above
        aliceKeyAgree.doPhase(cb, true);

        // Bob uses Alice's result from above
        bobKeyAgree.doPhase(ac, true);

        // Carol uses Bob's result from above
        carolKeyAgree.doPhase(ba, true);


        // Alice, Bob and Carol compute their secrets
        byte[] aliceSharedSecret = aliceKeyAgree.generateSecret();
        System.out.println("Alice secret: " + toHexString(aliceSharedSecret));

        byte[] bobSharedSecret = bobKeyAgree.generateSecret();
        System.out.println("Bob secret: " + toHexString(bobSharedSecret));

        byte[] carolSharedSecret = carolKeyAgree.generateSecret();
        System.out.println("Carol secret: " + toHexString(carolSharedSecret));


        // Compare Alice and Bob
        if (!java.util.Arrays.equals(aliceSharedSecret, bobSharedSecret))
            throw new Exception("Alice and Bob differ");
        System.out.println("Alice and Bob are the same");

        // Compare Bob and Carol
        if (!java.util.Arrays.equals(bobSharedSecret, carolSharedSecret))
            throw new Exception("Bob and Carol differ");
        System.out.println("Bob and Carol are the same");
    }


    /*
     * Converts a byte to hex digit and writes to the supplied buffer
     */
    private void byte2hex(byte b, StringBuffer buf) {
        char[] hexChars = { '0', '1', '2', '3', '4', '5', '6', '7', '8',
                            '9', 'A', 'B', 'C', 'D', 'E', 'F' };
        int high = ((b &amp; 0xf0) &gt;&gt; 4);
        int low = (b &amp; 0x0f);
        buf.append(hexChars[high]);
        buf.append(hexChars[low]);
    }

    /*
     * Converts a byte array to hex string
     */
    private String toHexString(byte[] block) {
        StringBuffer buf = new StringBuffer();

        int len = block.length;

        for (int i = 0; i &lt; len; i++) {
             byte2hex(block[i], buf);
             if (i &lt; len-1) {
                 buf.append(":");
             }
        }
        return buf.toString();
    }

    /*
     * Prints the usage of this test.
     */
    private void usage() {
        System.err.print("DHKeyAgreement usage: ");
        System.err.println("[-gen]");
    }

    // The 1024 bit Diffie-Hellman modulus values used by SKIP
    private static final byte skip1024ModulusBytes[] = {
        (byte)0xF4, (byte)0x88, (byte)0xFD, (byte)0x58,
        (byte)0x4E, (byte)0x49, (byte)0xDB, (byte)0xCD,
        (byte)0x20, (byte)0xB4, (byte)0x9D, (byte)0xE4,
        (byte)0x91, (byte)0x07, (byte)0x36, (byte)0x6B,
        (byte)0x33, (byte)0x6C, (byte)0x38, (byte)0x0D,
        (byte)0x45, (byte)0x1D, (byte)0x0F, (byte)0x7C,
        (byte)0x88, (byte)0xB3, (byte)0x1C, (byte)0x7C,
        (byte)0x5B, (byte)0x2D, (byte)0x8E, (byte)0xF6,
        (byte)0xF3, (byte)0xC9, (byte)0x23, (byte)0xC0,
        (byte)0x43, (byte)0xF0, (byte)0xA5, (byte)0x5B,
        (byte)0x18, (byte)0x8D, (byte)0x8E, (byte)0xBB,
        (byte)0x55, (byte)0x8C, (byte)0xB8, (byte)0x5D,
        (byte)0x38, (byte)0xD3, (byte)0x34, (byte)0xFD,
        (byte)0x7C, (byte)0x17, (byte)0x57, (byte)0x43,
        (byte)0xA3, (byte)0x1D, (byte)0x18, (byte)0x6C,
        (byte)0xDE, (byte)0x33, (byte)0x21, (byte)0x2C,
        (byte)0xB5, (byte)0x2A, (byte)0xFF, (byte)0x3C,
        (byte)0xE1, (byte)0xB1, (byte)0x29, (byte)0x40,
        (byte)0x18, (byte)0x11, (byte)0x8D, (byte)0x7C,
        (byte)0x84, (byte)0xA7, (byte)0x0A, (byte)0x72,
        (byte)0xD6, (byte)0x86, (byte)0xC4, (byte)0x03,
        (byte)0x19, (byte)0xC8, (byte)0x07, (byte)0x29,
        (byte)0x7A, (byte)0xCA, (byte)0x95, (byte)0x0C,
        (byte)0xD9, (byte)0x96, (byte)0x9F, (byte)0xAB,
        (byte)0xD0, (byte)0x0A, (byte)0x50, (byte)0x9B,
        (byte)0x02, (byte)0x46, (byte)0xD3, (byte)0x08,
        (byte)0x3D, (byte)0x66, (byte)0xA4, (byte)0x5D,
        (byte)0x41, (byte)0x9F, (byte)0x9C, (byte)0x7C,
        (byte)0xBD, (byte)0x89, (byte)0x4B, (byte)0x22,
        (byte)0x19, (byte)0x26, (byte)0xBA, (byte)0xAB,
        (byte)0xA2, (byte)0x5E, (byte)0xC3, (byte)0x55,
        (byte)0xE9, (byte)0x2F, (byte)0x78, (byte)0xC7
    };

    // The SKIP 1024 bit modulus
    private static final BigInteger skip1024Modulus
    = new BigInteger(1, skip1024ModulusBytes);

    // The base used with the SKIP 1024 bit modulus
    private static final BigInteger skip1024Base = BigInteger.valueOf(2);
}
</pre>
<hr />
<a name="BlowKeyEx" id="BlowKeyEx"></a>
<h2>Blowfish Cipher Example</h2>
<pre class="codeblock">
/*
 * Copyright (c) 1997, 2001, Oracle and/or its affiliates. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *   - Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *
 *   - Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 *   - Neither the name of Oracle nor the names of its
 *     contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
 * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

import java.security.*;
import javax.crypto.*;
import javax.crypto.spec.*;

/**
 * This program generates a Blowfish key, retrieves its raw bytes, and
 * then reinstantiates a Blowfish key from the key bytes.
 * The reinstantiated key is used to initialize a Blowfish cipher for
 * encryption.
 */

public class BlowfishKey {

    public static void main(String[] args) throws Exception {

        KeyGenerator kgen = KeyGenerator.getInstance("Blowfish");
        SecretKey skey = kgen.generateKey();
        byte[] raw = skey.getEncoded();
        SecretKeySpec skeySpec = new SecretKeySpec(raw, "Blowfish");

        Cipher cipher = Cipher.getInstance("Blowfish");
        cipher.init(Cipher.ENCRYPT_MODE, skeySpec);
        byte[] encrypted =
            cipher.doFinal("This is just an example".getBytes());
    }
}
</pre>
<hr />
<a name="HmacEx" id="HmacEx"></a>
<h2>HMAC-MD5 Example</h2>
<pre class="codeblock">
/*
 * Copyright (c) 1997, 2001, Oracle and/or its affiliates. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *   - Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *
 *   - Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 *   - Neither the name of Oracle nor the names of its
 *     contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
 * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

import java.security.*;
import javax.crypto.*;

/**
 * This program demonstrates how to generate a secret-key object for
 * HMAC-MD5, and initialize an HMAC-MD5 object with it.
 */

public class initMac {

    public static void main(String[] args) throws Exception {

        // Generate secret key for HMAC-MD5
        KeyGenerator kg = KeyGenerator.getInstance("HmacMD5");
        SecretKey sk = kg.generateKey();

        // Get instance of Mac object implementing HMAC-MD5, and
        // initialize it with the above secret key
        Mac mac = Mac.getInstance("HmacMD5");
        mac.init(sk);
        byte[] result = mac.doFinal("Hi There".getBytes());
    }
}
</pre>
<hr />
<a name="ReadPassword" id="ReadPassword"></a>
<h2>Reading ASCII Passwords From an InputStream Example</h2>
<pre class="codeblock">
/*
 * @(#)ReadPassword.java  1.1 06/06/07
 *
 * Copyright (c) 2006, Oracle and/or its affiliates. All rights reserved.
 * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
 */

import java.util.*;
import java.io.*;
import java.security.*;

public class ReadPassword {
    /**
     * Read a password from the InputStream "in".
     * &lt;p&gt;
     * As Strings are immutable, passwords should be stored as an array
     * of characters, which can be blanked out when no longer needed.
     * &lt;p&gt;
     * If the provided InputStream is the System's Console, this method
     * uses the non-echoing readPassword() method of java.io.Console
     * (new to JDK 6).  If not, a fallback implementation is used.
     * &lt;p&gt;
     * NOTE:  For expository purposes, and because some applications do
     * not understand multi-byte characters, only 8-bit ASCII passwords
     * are handled here.
     * &lt;p&gt;
     * NOTE:  If a SecurityManager is used, the default standard
     * java.policy file found in the JDK (i.e.
     * &lt;java-home&gt;/lib/security/java.policy) allows reading the
     * line.separator property.  If your environment is different, this
     * code will need to be granted the appropriate privilege.
     *
     * @param   in
     *          the InputStream used to obtain the password.
     *
     * @return  A character array containing the password or passphrase,
     *          not including the line-termination characters,
     *          or <tt>null</tt> if an end of stream has been reached.
     *
     * @throws  IOException
     *          if an I/O problem occurs
     */
    public static final char[] readPassword(InputStream in)
            throws IOException {

        /*
         * If available, directly use the java.io.Console class to
         * avoid character echoing.
         */
        if (in == System.in &amp;&amp; System.console() != null) {
            // readPassword returns "" if you just print ENTER,
            return System.console().readPassword();
        }

        /*
         * If a console is not available, read the InputStream
         * directly.  This approach may cause password echoing.
         *
         * Since different operating systems have different End-Of-Line
         * (EOL) sequences, this algorithm should allow for
         * platform-independent implementations.  Typical EOL sequences
         * are a single line feed ('\n'), or a carriage return/linefeed
         * combination ('\r\n').  However, some OS's use a single
         * a carriage return ('\r'), which complicates portability.
         *
         * Since we may not have the ability to push bytes back into the
         * InputStream, another approach is used here.  The javadoc for
         * &lt;code&gt;java.lang.System.getProperties()&lt;/code&gt; specifies that
         * the set of system properties will contain a system-specific
         * value for the "line.separator".  Scan for this character
         * sequence instead of hard-coding a particular sequence.
         */

        /*
         * Enclose the getProperty in a doPrivileged block to minimize
         * the call stack permission required.
         */
        char [] EOL = AccessController.doPrivileged(
            new PrivilegedAction&lt;char[]&gt;() {
                public char[] run() {
                    String s = System.getProperty("line.separator");
                    // Shouldn't happen.
                    if (s == null) {
                        throw new RuntimeException(
                            "line.separator not defined");
                    }
                    return s.toCharArray();
                }
            });

        char [] buffer = new char[128];
        try {
            int len = 0;                // len of data in buffer.
            boolean done = false;       // found the EOL sequence
            int b;                      // byte read

            while (!done) {
                /*
                 * realloc if necessary
                 */
                if (len &gt;= buffer.length) {
                    char [] newbuffer = new char[len + 128];
                    System.arraycopy(buffer, 0, newbuffer, 0, len);
                    Arrays.fill(buffer, ' ');
                    buffer = newbuffer;
                }

                /*
                 * End-of-Stream?
                 */
                if ((b = in.read()) == -1) {
                    // Return as much as we have, null otherwise.
                    if (len == 0) {
                        return null;
                    }
                    break;
                } else {
                    /*
                     * NOTE:  In the simple PBE example here,
                     * only 8 bit ASCII characters are handled.
                     */
                    buffer[len++] = (char) b;
                }

                /*
                 * check for the EOL sequence.  Do we have enough bytes?
                 */
                if (len &gt;= EOL.length) {
                    int i = 0;
                    for (i = 0; i &lt; EOL.length; i++) {
                        if (buffer[len - EOL.length + i] != EOL[i]) {
                            break;
                        }
                    }
                    done = (i == EOL.length);
                }
            }

            /*
             * If we found the EOL, strip the EOL chars.
             */
            char [] result = new char[done ? len - EOL.length : len];
            System.arraycopy(buffer, 0, result, 0, result.length);

            return result;
        } finally {
            /*
             * Zero out the buffer.
             */
            if (buffer != null) {
                Arrays.fill(buffer, ' ');
            }
        }
    }
}

</pre>

<!--  footer start -->
<div id="javasefooter">
<div class="hr">
<hr /></div>
<div id="javasecopyright">
<img id="oraclelogofooter" src=
"../../../../images/oraclelogo.gif" alt="Oracle and/or its affiliates"
border="0" width="100" height="29" name=
"oraclelogofooter" />

<a href="../../../../legal/cpyr.html">Copyright
&#169;</a> 1993, 2015, Oracle and/or its affiliates. All rights
reserved.</div>
<div id="javasecontactus">
<a href=
"http://docs.oracle.com/javase/feedback.html">Contact
Us</a>
</div>
</div>
<!-- footer end -->

<!-- STATIC FOOTER -->

</body>
</html>
